<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>(CI logo) CrimIdle ‚Äî Sidebar Nav</title>
<meta content="Fictional idle-game starter: dark theme, autosave, stats XP, heat, debug toggle, and a left sidebar navigation." name="description"/>
<style>
/* Roulette table layout */
.roulette-table { display:grid; grid-template-columns: repeat(13, minmax(34px,1fr)); gap:2px; user-select:none; }
.rt-cell { text-align:center; padding:6px 0; border:1px solid #1f2937; cursor:pointer; border-radius:6px; font-weight:600; }
.rt-zero { grid-row: 1 / span 3; grid-column: 1; writing-mode: vertical-rl; text-orientation: mixed; }
.rt-num { }
.rt-red { background:#731a1a; }
.rt-black { background:#111827; }
.rt-zero, .rt-num { color:#e5e7eb; }
.rt-out { grid-column: span 4; background:#0f172a; color:#e5e7eb; border:1px dashed #334155; }
.rt-col { grid-column: span 4; background:#0f172a; color:#e5e7eb; border:1px dashed #334155; }
.rt-selected { outline:2px solid #fbbf24; }

/* Canvas pointer */
#rouletteCanvas { position:relative; }
#rouletteCanvas::after { content:''; position:absolute; top:50%; left:50%; width:8px; height:8px; margin-left:-4px; margin-top:-4px; border-radius:50%; background:#fbbf24; box-shadow:0 0 0 2px #111827; }

    :root{
      --bg0:#0b0f14;
      --bg1:#0a0f16;
      --panel:#0f172a;
      --ink:#e5e7eb;
      --sub:#94a3b8;
      --muted:#1f2937;
      --muted-2:#334155;
      --accent:#22d3ee;
      --accent-warm:#f59e0b;
      --danger:#ef4444;
      --good:#22c55e;
      --sidebar-w: 250px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink);
      background:linear-gradient(to bottom, var(--bg0), var(--bg1));
    }
    /* Layout */
    .app{display:flex; min-height:100vh; width:100%;}
    aside.sidebar{
      width:var(--sidebar-w);
      background:var(--panel);
      border-right:1px solid var(--muted);
      padding:14px 12px;
      position:sticky; top:0; align-self:flex-start; height:100vh; overflow:auto;
    }
    .brand{display:flex; align-items:center; gap:10px; padding:8px 10px; margin-bottom:10px}
    .brand .logo{
      width:28px; height:28px; border-radius:8px; background:#111827; border:1px solid var(--muted); display:flex; align-items:center; justify-content:center; font-weight:900;
    }
    .brand .name{font-weight:800}
    nav.sidenav{display:flex; flex-direction:column; gap:6px; margin-top:6px}
    .sidelink{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px; border-radius:10px;
      color:var(--ink); text-decoration:none; cursor:pointer;
      border:1px solid transparent;
    }
    .sidelink:hover{ background:#111827; border-color:var(--muted-2); }
    .sidelink[aria-current="page"]{ background:#111827; border-color:var(--muted-2); box-shadow:0 0 0 1px var(--muted-2) inset; }
    .sidelink .k{width:18px; text-align:center; opacity:.9}
    .section-label{margin:12px 8px 6px; font-size:11px; color:var(--sub); letter-spacing:.08em; text-transform:uppercase}
    .sidebar-footer{margin-top:auto; display:flex; flex-direction:column; gap:6px; padding-top:10px}
    .small{font-size:12px}
    .muted{color:var(--sub)}
    .btn{border:1px solid var(--muted-2);background:#111827;color:var(--ink);padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:hover{filter:brightness(1.1)}
    .btn[disabled]{background:#0b1220;border-color:#0b1220;color:#475569;cursor:not-allowed;filter:none}
    .btn.secondary{background:transparent;color:var(--ink);border-color:var(--muted)}
    .btn.toggle{background:#111827;border-color:var(--muted);}
    .btn.toggle[aria-pressed="true"]{border-color:var(--accent); box-shadow:0 0 0 1px var(--accent) inset;}
    
    .pill{background:var(--panel);border:1px solid var(--muted);padding:8px 12px;border-radius:16px;box-shadow:0 1px 2px rgba(0,0,0,.3)}
    .content{flex:1; min-width:0}
    .container{max-width:1200px;margin:0 16px 32px 12px;padding:8px 12px 24px}
    header{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size: clamp(20px, 4vw, 28px);margin:0}
    .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    /* Header info cluster */
    .info-cluster{display:flex;align-items:center;gap:10px;flex-wrap:wrap;background:#0b1220;border:1px solid var(--muted);border-radius:16px;padding:10px 12px}
    .clock-txt{margin-right:12px;display:flex;align-items:center;gap:8px}
    .clock-txt strong{letter-spacing:.2px}


    .row-wrap{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .grid{display:grid;grid-template-columns:repeat(auto-fit, minmax(320px,1fr));gap:16px;align-items:start}
    .row-nowrap{flex-wrap:nowrap;overflow:visible}
    .row-nowrap > *{flex:0 0 auto}
    .pill{white-space:nowrap}
    /* Analytics grid allows spanning */
    .analytics-grid{grid-template-columns:repeat(auto-fit, minmax(360px,1fr))}
    .span-2{grid-column:1 / -1}

    /* Make header sticky with slight blur on scroll */
    header{position:sticky;top:0;z-index:5;background:linear-gradient(to bottom, rgba(11,15,20,.92), rgba(11,15,20,.70));backdrop-filter:saturate(1.2) blur(4px);border-bottom:1px solid var(--muted);padding:12px 16px;margin:0 -4px 16px;border-radius:0 0 12px 12px}

    /* Micro-interactions */
    .btn{transition:transform .06s ease, box-shadow .2s ease}
    .btn:hover{box-shadow:0 4px 14px rgba(0,0,0,.25)}
    .btn:active{transform:translateY(1px) scale(.995)}
    .card{transition:transform .08s ease, box-shadow .2s ease}
    .card:hover{transform:translateY(-1px);box-shadow:0 4px 18px rgba(0,0,0,.35)}
    /* Log as multi-column on wide screens */
    
    
    .card{background:var(--panel);border:1px solid var(--muted);border-radius:16px;padding:14px 14px 12px;box-shadow:0 2px 12px rgba(0,0,0,.35)}
    .card h3{margin:0 0 8px 0;font-size:18px}
    .progress{height:8px;width:100%;background:#0b1220;border-radius:999px;overflow:hidden;border:1px solid var(--muted)}
    .bar{height:8px;width:0;background:var(--accent);border-radius:999px;transition:width .1s linear}
    .list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px}
    .li{background:#0b1220;border:1px solid var(--muted);border-radius:10px;padding:8px 10px;box-shadow:0 1px 3px rgba(0,0,0,.25);font-size:14px}
    /* Log color helpers */
    .logpiece{font-weight:600}
    .txp{color:var(--accent-warm)}        /* orange for XP gains */
    .tmoney{color:var(--good)}            /* green for currency gains */
    .tbad{color:var(--danger)}
    .red{color:var(--danger)}            /* red for failures/deductions */
    .statrow{display:flex;flex-direction:column;gap:6px;border:1px solid var(--muted);border-radius:12px;padding:10px 12px;background:#0b1220;box-shadow:0 1px 3px rgba(0,0,0,.25)}
    .statheader{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .statname{font-weight:700}
    .codepath{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;color:#a3e0ea}
    .heat-hi{color:var(--danger)}
    .heat-mid{color:var(--accent-warm)}
    .hidden{display:none !important}
    /* Chart */
    .chartWrap{background:#0b1220;border:1px solid var(--muted);border-radius:12px;padding:8px}
    .rangebar{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 10px}
    .rangebtn{border:1px solid var(--muted);background:#111827;color:var(--ink);padding:6px 10px;border-radius:999px;font-weight:600;cursor:pointer}
    .rangebtn[aria-pressed="true"]{border-color:var(--accent);box-shadow:0 0 0 1px var(--accent) inset}
    .legend{display:flex;gap:12px;align-items:center;font-size:12px;color:var(--sub);margin-top:6px}
    .dot{display:inline-block;width:10px;height:10px;border-radius:50%}
    .dot.money{background:var(--good)}
    .dot.heat{background:var(--accent-warm)}
    
    /* Debug visibility helpers */
    .debug-inline{display:none}
    .debug-block{display:none}
    body.debug .debug-inline{display:inline}
    body.debug .debug-block{display:block}
    footer{margin-top:28px;text-align:center;font-size:12px;color:var(--sub)}
    /* Sleek dialogs */
    dialog{border:none;padding:0;background:transparent}
    dialog::backdrop{background:rgba(2,6,23,.6);backdrop-filter:saturate(1.1) blur(3px)}
    .modal-card{min-width:360px;max-width:520px;background:#0f172a;border:1px solid var(--muted);border-radius:16px;color:var(--ink);padding:16px 18px;box-shadow:0 16px 44px rgba(0,0,0,.6)}
    .modal-card h3{margin:4px 0 10px 0}
    .modal-card .field{display:flex;flex-direction:column;gap:6px;margin:8px 0}
    .modal-card input[type="text"]{width:100%;padding:12px 12px;border-radius:12px;border:1px solid var(--muted);background:#0b1220;color:var(--ink);font-size:16px}
    /* Shop list styling */
    .shop-row{display:flex;align-items:center;justify-content:space-between;gap:10px;border:1px solid var(--muted);background:#0b1220;border-radius:12px;padding:10px;margin:6px 0}
    .shop-row .meta{display:flex;flex-direction:column;gap:2px}
    .shop-row .name{font-weight:800}
    .shop-row .sub{font-size:12px;color:var(--sub)}
    /* Property cards */
    .prop-card{background:#0b1220;border:1px solid var(--muted);border-radius:14px;padding:12px 14px;box-shadow:0 1px 4px rgba(0,0,0,.25);display:flex;flex-direction:column;gap:8px}
    .prop-head{display:flex;align-items:center;justify-content:space-between}
    .prop-name{font-weight:800}
    .prop-meta{display:flex;gap:8px;flex-wrap:wrap}
    .prop-meta .pill{padding:4px 8px}
    .prop-actions{display:flex;gap:8px;margin-top:auto}
    /* Modal */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.4);display:flex;align-items:center;justify-content:center;z-index:70}
    .modal.hidden{display:none}
    .modal-card{background:#0b1220;border:1px solid var(--muted);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.5);width:min(1000px,90vw);max-height:80vh;overflow:auto;padding:12px}
    .modal-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    .store-item,.inv-item-sm{border:1px solid var(--muted);border-radius:10px;padding:8px;margin:6px 0;display:flex;align-items:center;justify-content:space-between;gap:8px;background:#0f172a}
    .inv-item-sm .name,.store-item .name{font-weight:700}
    .store-actions .btn,.inv-actions .btn{padding:4px 8px}

    /* ===== Fancy property cards ===== */
    .prop-card.luxe{position:relative;overflow:hidden;border-radius:16px;background:linear-gradient(180deg,#0f172a 0%, #0b1220 100%);border:1px solid var(--muted);padding:12px 14px;box-shadow:0 6px 20px rgba(0,0,0,.25);transition:transform .2s ease, box-shadow .2s ease}
    .prop-card.luxe:hover{transform:translateY(-2px);box-shadow:0 10px 28px rgba(0,0,0,.35)}
    .prop-hero{height:84px;border-radius:12px;margin:-6px -6px 10px -6px;opacity:.9}
    .tier-0 .prop-hero{background:linear-gradient(135deg,#22314f 0%, #10243d 100%)}
    .tier-1 .prop-hero{background:linear-gradient(135deg,#2a3a3f 0%, #0f3d2e 100%)}
    .tier-2 .prop-hero{background:linear-gradient(135deg,#3c2a4f 0%, #1d274a 100%)}
    .tier-3 .prop-hero{background:linear-gradient(135deg,#4f2a2a 0%, #3a1e45 100%)}
    .prop-head{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .prop-name{font-weight:900;letter-spacing:.2px}
    .prop-loc{display:flex;align-items:center;gap:6px}
    .ico{display:inline-flex;width:14px;height:14px;line-height:1;opacity:.85}
    .prop-meta.fancy{display:flex;flex-wrap:wrap;gap:8px;margin:4px 0 2px}
    .prop-meta.fancy .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--muted);background:#091224}
    .kv{display:flex;align-items:baseline;gap:6px}
    .kv .label{font-size:12px;color:var(--sub)}
    .kv .val{font-weight:900}
    .prop-price{display:flex;gap:12px;flex-wrap:wrap;margin:2px 0 6px}
    .price{display:flex;align-items:center;gap:8px;border:1px solid var(--muted);border-radius:12px;padding:6px 10px;background:#0b1220}
    .price .main{font-size:18px;font-weight:900}
    .price .per{font-size:12px;color:var(--sub)}
    .prop-actions{display:flex;gap:8px;margin-top:auto}
    .prop-actions .btn{flex:1}


    /* Compact vitals meters */
    .meters{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin-top:6px}
    .meter{background:#0b1220;border:1px solid var(--muted);border-radius:12px;padding:8px 10px}
    .meter .head{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
    .meter .head .label{font-weight:700}
    .progress.slim{height:8px;border-radius:8px}
    .progress.slim .bar{height:100%}
    .meter-inline{display:flex;align-items:center;gap:8px}
    .meter-inline .icon{font-size:14px;line-height:1;filter:saturate(1.1)}
    .meter-inline .codepath{margin-left:8px}
    .meter-inline .progress.tiny{width:120px;height:6px;border-radius:6px}
    .meter-inline .progress.tiny .bar{height:100%}


    .modal-card input[type="text"]:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 2px rgba(59,130,246,.25)}
    .modal-actions{display:flex;justify-content:flex-end;gap:10px;margin-top:14px}

    /* Inventory grid */
    .inv-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px}
    .inv-item{background:#0b1220;border:1px solid var(--muted);border-radius:12px;padding:10px 12px;display:flex;flex-direction:column;gap:8px;box-shadow:0 1px 4px rgba(0,0,0,.25);min-height:128px}
    .inv-item .top{display:flex;align-items:flex-start;justify-content:space-between;gap:8px;margin-bottom:4px}
    .inv-item .name{font-weight:700;font-size:16px;line-height:1.2;word-break:break-word}
    .inv-item .desc{font-size:12px;color:var(--sub);line-height:1.25;margin-top:2px}
    .tag{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--muted);border-radius:999px;padding:4px 8px;font-size:12px;background:#111827;line-height:1.1}
    .tag.slot{}
    .tag.rarity-common{border-color:#374151}
    .tag.rarity-uncommon{border-color:#4ade80}
    .tag.rarity-rare{border-color:#60a5fa}
    .inv-item .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:auto}
    .inv-item.equipped{box-shadow:0 0 0 1px var(--good) inset}
    .btn.sm{padding:6px 10px;font-size:12px;border-radius:10px}

    /* Equipment (silhouette) */
    .equip-wrap{display:grid;grid-template-columns:200px 1fr;gap:16px;align-items:start;margin-top:10px}
    @media (max-width: 720px){ .equip-wrap{grid-template-columns:1fr} }
    .equip-figure{position:relative;width:200px;height:280px;border:1px solid var(--muted);border-radius:14px;background:#0b1220;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03)}
    .equip-figure svg{position:absolute;inset:0;height:100%;width:100%}
    .slot{position:absolute;display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:999px;border:1px solid var(--muted);background:#111827;color:var(--ink);font-weight:700;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.25)}
    .slot small{font-weight:600;color:var(--sub)}
    .slot:hover{border-color:var(--muted-2)}
    .slot .dot{width:8px;height:8px;border-radius:50%;background:#6b7280}
    .slot.filled .dot{background:var(--good)}
    .slot.badge{position:static}
    .slots-list{display:grid;grid-template-columns:repeat(auto-fit, minmax(180px,1fr));gap:8px}
    .equip-panel{display:flex;flex-direction:column;gap:8px}
    .equip-legend{font-size:12px;color:var(--sub)}
    /* Compact overlay dots */
    .slot.dotbtn{padding:0;width:16px;height:16px;border-radius:999px;border:1px solid var(--muted-2);background:#0f172a;box-shadow:none}
    .slot.dotbtn .dot{width:8px;height:8px;margin:0 auto;background:#6b7280}
    .slot.dotbtn.filled .dot{background:var(--good)}
    .slot.dotbtn:hover{border-color:var(--accent)}
    /* Sleek chips list on the right */
    .slots-list{display:grid;grid-template-columns:repeat(auto-fit, minmax(280px,1fr));gap:10px}
    .slot.badge{position:static;display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:16px;background:#111827;border:1px solid var(--muted);box-shadow:0 1px 4px rgba(0,0,0,.25);cursor:pointer}
    .slot.badge .dot{flex:0 0 8px}
    .slot.badge strong{font-weight:800}
    .slot.badge small{margin-left:auto}


    /* Responsive sidebar toggle */
    .collapse-btn{display:none}
    @media (max-width: 860px){
      :root{ --sidebar-w: 220px; }
      .app{ position:relative; }
      .collapse-btn{
        display:inline-flex; align-items:center; justify-content:center;
        border:1px solid var(--muted); background:#111827; color:var(--ink);
        border-radius:10px; padding:6px 10px; cursor:pointer;
      }
      aside.sidebar{ position:fixed; left:0; top:0; transform:translateX(-100%); transition:transform .2s ease; z-index:40; }
      aside.sidebar.open{ transform:translateX(0%); }
      .content{ padding-left:0 }
    }
  
.slotCanvas-frame .fadeMaskTop,.slotCanvas-frame .fadeMaskBot{
  position:absolute; left:0; right:0; height:22px; z-index:2; pointer-events:none;
  background: linear-gradient(180deg, rgba(11,19,42,1), rgba(11,19,42,0));
}
.slotCanvas-frame .fadeMaskBot{ bottom:0; top:auto; transform:scaleY(-1); }
.slotCanvas-frame .bars{ position:absolute; inset:0; pointer-events:none; z-index:2; }

/* Hide inline hint until reels settle */
.slotCanvas-wrap.slot-pending .slotCanvas-hint{
  visibility: hidden;
  opacity: 0;
  transition: opacity .2s ease;
}
/* Optionally dim the frame while spinning */
.slotCanvas-wrap.slot-pending .slotCanvas-frame{ filter: saturate(0.95); }

/* Keep Spin/Auto size consistent and full-width */
.slotCanvas-controls .btn{ width:100%; min-height:48px; padding:12px 16px; }
.slotCanvas-controls .btn:active{ transform:none !important; }
.slotCanvas-box{ flex:1 1 auto; width:100%; }


/* --- Slot controls: lock button size & prevent press-shrink --- */
.slotCanvas-controls .btn{
  width: 100% !important;
  min-height: 52px !important;
  padding: 14px 16px !important;
}
.slotCanvas-controls .btn:hover,
.slotCanvas-controls .btn:active{
  transform: none !important;
}
.slotCanvas-controls .btn[disabled]{
  transform: none !important;
  filter: none !important;
}


/* Layout: stack frame and controls; make both full width to match */
.slotCanvas-wrap{ display:flex; flex-direction:column; align-items:stretch; gap:14px; }
.slotCanvas-box{ width:100%; }
.slotCanvas-frame{ width:100%; }
.slotCanvas-controls{ width:100%; }
.slotCanvas-controls .btn{ width:100% !important; min-height:52px !important; padding:14px 16px !important; }


/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="visual-flair-upgrade">
  /* --- Visual Flair Pack -------------------------------------- */
  :root{
    --bg-1: #0f1224;
    --bg-2: #13162a;
    --panel: #151a2e;
    --panel-2: #0e1327;
    --border: rgba(255,255,255,.06);
    --primary: #8b5cf6;   /* violet */
    --accent:  #22d3ee;   /* cyan   */
    --success: #34d399;
    --warning: #f59e0b;
    --danger:  #f87171;
    --text:    #e5e7eb;
    --muted:   #a7b0c3;
  }

  /* Background: layered gradient with soft vignette */
  body{
    background:
      radial-gradient(1200px 800px at 10% -10%, rgba(139,92,246,.18), transparent 60%),
      radial-gradient(1000px 700px at 100% 0%, rgba(34,211,238,.12), transparent 65%),
      linear-gradient(180deg, var(--bg-1), var(--bg-2));
    color: var(--text);
  }

  /* Cards: glassy panels with soft shadow */
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    border: none;
    border-radius: 16px;
    box-shadow: 0 10px 28px rgba(2,6,23,.35), inset 0 1px 0 rgba(255,255,255,.03);
    backdrop-filter: blur(6px);
    transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
    will-change: transform;
    animation: floatIn .35s ease both;
  }
  .card:hover{
    transform: translateY(-2px);
    box-shadow: 0 16px 36px rgba(2,6,23,.5), inset 0 1px 0 rgba(255,255,255,.04);
    
  }
  @keyframes floatIn{
    from{ opacity:0; transform: translateY(6px); }
    to{ opacity:1; transform: translateY(0); }
  }

  /* Pills (meta chips under rental cards) */
  .pill{
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border: none;
    border-radius: 999px;
  }

  /* Buttons with subtle gradient + ripple */
  .btn{
    position: relative;
    overflow: hidden;
    border-radius: 12px;
    transition: transform .12s ease, box-shadow .12s ease, background .2s ease, border-color .2s ease;
    box-shadow: 0 6px 16px rgba(2,6,23,.25);
  }
  .btn:hover{ transform: translateY(-1px); }
  .btn:active{ transform: translateY(0); }
  .btn.primary, .btn:not(.secondary):not(.ghost){
    background: linear-gradient(90deg, rgba(139,92,246,.28), rgba(34,211,238,.28));
  }
  .btn.secondary{
    background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border: none;
  }
  .btn .ripple{
    position:absolute; pointer-events:none; border-radius:50%;
    transform: scale(0); opacity:.55; background: rgba(255,255,255,.45);
    animation: ripple .6s ease-out;
  }
  @keyframes ripple{
    to{ transform: scale(4); opacity:0; }
  }

  /* Progress bars with animated sheen */
  .progress{ background: rgba(255,255,255,.045); border-radius: 999px; overflow: hidden; }
  .progress .bar{
    background: linear-gradient(90deg, var(--primary), var(--accent));
    transition: width .45s ease;
    position: relative;
  }
  .progress .bar::after{
    content:""; position:absolute; inset:0;
    background: linear-gradient(45deg,
      rgba(255,255,255,.18) 25%, transparent 25%, transparent 50%,
      rgba(255,255,255,.18) 50%, rgba(255,255,255,.18) 75%, transparent 75%, transparent);
    background-size: 24px 24px;
    animation: slideSheen 2s linear infinite;
    mix-blend-mode: overlay;
    opacity: .35;
    pointer-events: none;
  }
  @keyframes slideSheen{
    from{ background-position: 0 0; }
    to{   background-position: 24px 0; }
  }

  /* Tabs or active controls highlighting (generic) */
  .active, .tab.active, .nav .active{
    box-shadow: inset 0 -2px 0 0 var(--accent);
    color: #fff;
  }

  /* Muted text remains readable on dark bg */
  .muted{ color: var(--muted); }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  /* Layout helpers for card headers */
  .row.between{ justify-content: space-between; }
  .row.nowrap{ flex-wrap: nowrap; }
  .hq-head h3{ margin: 0; }
  .hq-head{ margin-bottom: 8px; }
  @media (max-width: 720px){
    .hq-head{ flex-wrap: wrap; gap: 8px 12px; }
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  /* HQ tabs placement */
  .hq-head{ margin-bottom: 10px; }
  .hq-head #hqActions{ margin-bottom: 8px; }
  .hq-head h3{ margin: 0; }
  @media (max-width: 720px){
    .hq-head #hqActions{ gap: 6px; }
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  /* HQ tabs above the HQ card */
  .hq-tabs{ margin: 0 0 -10px 0; padding-left: 12px; }
  .hq-tabs .row{ gap: 8px; flex-wrap: wrap; }
  .hq-tabs .btn{ border-bottom-left-radius: 0; border-bottom-right-radius: 0; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  .hq-col{ display:block; }
  .hq-tabs{ margin: 0 0 -10px 0; padding-left: 12px; }
  .hq-tabs .row{ gap: 8px; flex-wrap: wrap; }
  .hq-tabs .btn{ border-bottom-left-radius: 0; border-bottom-right-radius: 0; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="hq-tabs-nudge">
  /* Move HQ tabs slightly left (‚âà20px), no overlap */
  .hq-tabs{
    margin: 0 0 8px -8px;  /* was 12px; with existing padding-left:12px net ‚âà4px indent */
    position: static;
    z-index: auto;
  }
  .hq-tabs .btn{
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="topbar-darken">
  /* Soften the top info cluster (Clock/Balance/Heat/Autosave/Reset) */
  .info-cluster{
    border: none !important;
    background: var(--panel-2) !important; /* slate black tone */
    box-shadow: inset 0 1px 0 rgba(255,255,255,.03), 0 6px 14px rgba(2,6,23,.28);
  }
  .info-cluster .pill{ border: none; box-shadow: inset 0 1px 0 rgba(255,255,255,.04); }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="analytics-spent-dot">.dot.spent{background:var(--danger);}


/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="log-ts-style">
  #logList .ts{
    color: var(--muted);
    margin-right: .6rem;
    font-size: .95em;
    opacity: .85;
    font-variant-numeric: tabular-nums;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="rarity-text-colors">
  /* Rarity-to-color mapping for Activity Log item mentions */
  .rarity-text-common{ color:#9ca3af; }   /* gray */
  .rarity-text-uncommon{ color:#34d399; } /* emerald/green */
  .rarity-text-rare{ color:#60a5fa; }     /* blue */



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="header-logo-style">
  .header-logo{
    width: 48px;
    height: 48px;
    border-radius: 10px;
    background:#111827;
    border:1px solid var(--muted);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    font-size: 20px;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="recruit-cand-grid-2up">
  /* Recruitment candidates: 2-up grid on desktop, 1-up on small screens */
  #recruitCandidates{
    display: grid;
    grid-template-columns: repeat(2, minmax(260px, 1fr));
    gap: 12px;
    align-items: stretch;
  }
  @media (max-width: 820px){
    #recruitCandidates{ grid-template-columns: 1fr; }
  }
  /* Make nested candidate cards breathe a bit inside the grid */
  #recruitCandidates > .card{ margin: 0; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  .badge{
    margin-left:auto;
    min-width:18px; height:18px;
    border-radius:10px;
    background:var(--danger);
    color:#fff; font-size:11px; font-weight:700;
    display:inline-flex; align-items:center; justify-content:center;
    padding:0 6px; line-height:1; box-shadow:0 0 0 1px rgba(0,0,0,.25) inset;
  }
  .mail-grid{ display:grid; gap:12px; grid-template-columns: 320px 1fr; }
  @media (max-width: 820px){ .mail-grid{ grid-template-columns: 1fr; } }
  .mail-left{ background:var(--panel); border:1px solid var(--muted); border-radius:12px; padding:6px; }
  .mail-right{ background:var(--panel); border:1px solid var(--muted); border-radius:12px; padding:12px; min-height:240px; }
  .mail-item{ display:flex; flex-direction:column; gap:2px; padding:10px; border-radius:10px; cursor:pointer; border:1px solid transparent; }
  .mail-item:hover{ background:#111827; border-color:var(--muted-2); }
  .mail-item.selected{ background:#111827; border-color:var(--accent); box-shadow:0 0 0 1px var(--accent) inset; }
  .mail-item .sender{ font-weight:700; }
  .mail-item.unread .sender::after{ content:' ‚Ä¢'; color:var(--accent); }
  .mail-item .subj{ color:var(--ink); opacity:.9; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .mail-item .meta{ color:var(--sub); font-size:12px; display:flex; gap:8px; }
  .mail-body{ white-space:pre-wrap; line-height:1.5; }
  @keyframes bump { 0%{transform:scale(1)} 40%{transform:scale(1.2)} 100%{transform:scale(1)} }
  .badge.bump { animation:bump .28s ease; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-retro-style">
  /* Email client: retro black terminal vibe */
  #view-mail, #view-mail *{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
    letter-spacing: .2px;
  }
  #view-mail .card,
  #view-mail .mail-left,
  #view-mail .mail-right{
    background: #000 !important;
    border-color: #1b1b1b !important;
    color: var(--ink);
  }
  #view-mail h3, #view-mail h4{ color: var(--ink); }
  #view-mail .mail-item{ background:#000; border-color:#1b1b1b; }
  #view-mail .mail-item:hover{ background:#080808; border-color:#2a2a2a; }
  #view-mail .mail-item.selected{ background:#080808; border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent) inset; }
  #view-mail .mail-body{ color: var(--ink); }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-selection-enhance">
  /* Stronger selection state for left pane */
  #view-mail .mail-item{ position: relative; }
  #view-mail .mail-item.selected{
    background:#0a0a0a !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 1px var(--accent) inset, 0 0 12px rgba(0,0,0,.2);
  }
  #view-mail .mail-item.selected::before{
    content:''; position:absolute; left:-2px; top:6px; bottom:6px; width:4px;
    border-radius:4px; background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
  }
  #view-mail .mail-item.selected .sender{ color:#fff; }
  #view-mail .mail-item.selected .subj{ color:#e6e6e6; opacity:1; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-crt-style">
  /* Toggle chip */
  #view-mail .mail-chip{
    float:right; margin-left:8px; padding:4px 10px; font-size:12px; border-radius:999px;
    background:#0a0a0a; border:1px solid #2a2a2a; color:var(--ink); cursor:pointer;
  }
  #view-mail.crt-on .mail-chip{ border-color: var(--accent); color: var(--accent); }

  /* Positioning for scanline overlay */
  #view-mail .mail-left, #view-mail .mail-right{ position: relative; overflow: hidden; }

  /* CRT theme: soft green text + scanlines + glow */
  #view-mail.crt-on{ --crt-green: #b7ffb7; }
  #view-mail.crt-on, #view-mail.crt-on *{ text-shadow: 0 0 4px rgba(129,255,146,0.34); }
  #view-mail.crt-on .mail-left, #view-mail.crt-on .mail-right, #view-mail.crt-on .card{
    color: var(--crt-green);
  }
  #view-mail.crt-on .mail-item .sender,
  #view-mail.crt-on .mail-item .subj,
  #view-mail.crt-on .mail-body{ color: var(--crt-green); }
  #view-mail.crt-on .mail-left::after, #view-mail.crt-on .mail-right::after{
    content:''; position:absolute; inset:0; pointer-events:none; border-radius:inherit;
    background:
      repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 2px, transparent 4px);
    opacity:.35;
    mix-blend-mode: overlay;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-crt-colors">
  /* CRT color tuning: keep body green, change "white" accents to yellow, sender to cyan */
  #view-mail.crt-on {
    --crt-green: #b7ffb7;
    --crt-yellow: #ffe08a;
    --crt-cyan: #7ad7ff;
  }
  /* Right pane subject (was white) -> yellow */
  #view-mail.crt-on #mailSubj{ color: var(--crt-yellow) !important; }
  /* Meta line: sender -> cyan; time/labels -> soft yellow */
  #view-mail.crt-on #mailFrom{ color: var(--crt-cyan) !important; }
  #view-mail.crt-on .mail-right .small{ color: rgba(255, 224, 138, 0.95) !important; }
  /* Left list: sender -> cyan; selected subject (was near-white) -> yellow */
  #view-mail.crt-on .mail-item .sender{ color: var(--crt-cyan) !important; }
  #view-mail.crt-on .mail-item.selected .sender{ color: var(--crt-cyan) !important; }
  #view-mail.crt-on .mail-item.selected .subj{ color: var(--crt-yellow) !important; opacity:1 !important; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-noncrt-colors">
  /* Non-CRT theme colours for Email */
  #view-mail:not(.crt-on) #mailSubj{ color:#fff !important; }
  #view-mail:not(.crt-on) #mailFrom{ color: var(--accent) !important; }
  #view-mail:not(.crt-on) #mailAgo{ color: var(--accent-warm) !important; font-weight:700; }

  /* Left list */
  #view-mail:not(.crt-on) .mail-item .sender{ color: var(--accent) !important; }
  #view-mail:not(.crt-on) .mail-item .subj{ color: #e5e7eb !important; opacity:.95; }
  #view-mail:not(.crt-on) .mail-item .meta{ color: var(--accent-warm) !important; opacity:.95; }

  /* Selected state refinement */
  #view-mail:not(.crt-on) .mail-item.selected .subj{ color:#fff !important; opacity:1 !important; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
/* === Equipment Panel Hard Alignment Reset (v4) === */
.equip-wrap, .equip-panel, .slots-list {
  text-align: left !important;
  justify-items: start !important;
  align-items: start !important;
}

/* Ensure each slot content anchors left and fills row neatly */
.equip-panel .slot.badge {
  display: flex !important;
  justify-content: flex-start !important;
  align-items: center !important;
  width: 100% !important;
}

/* Reset any auto margins and tiny font on equipped text */
.equip-panel .slot.badge small {
  margin-left: 6px !important;
  margin-right: 0 !important;
  font-size: 1em !important;
  text-align: left !important;
  flex: 0 0 auto !important;
}

/* Nuke global small auto-margins inside the equipment area */
.equip-wrap small, .equip-panel small, .slots-list small {
  margin-left: 0 !important;
  margin-right: 0 !important;
}

/* As a final guard, prevent right alignment via flex on any inner wrappers */
.equip-wrap *[style*="text-align:right"],
.equip-panel *[style*="text-align:right"] {
  text-align: left !important;
}



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-theme-polish-v2">
  /* === Email UI Polish (non-functional) =====================================
     - Read vs Unread: darker text on left pane for read items
     - Visual refresh to better match overall UI theme (violet/cyan accents)
     - Keep CRT theme intact; only non-CRT gets sans-serif + gradients
  ============================================================================ */

  /* Use app's default type in non-CRT mode (CRT keeps monospace) */
  #view-mail:not(.crt-on), 
  #view-mail:not(.crt-on) *{
    font-family: inherit !important;
    letter-spacing: normal !important;
  }

  /* Read vs Unread state in left list */
  /* Treat anything not .unread as read (no JS changes required) */
  #view-mail .mail-item:not(.unread) .sender{
    font-weight: 600 !important;
    color: var(--sub) !important;
    opacity: .9 !important;
  }
  #view-mail .mail-item:not(.unread) .subj{
    color: var(--sub) !important;
    opacity: .85 !important;
  }
  #view-mail .mail-item:not(.unread) .meta{
    color: var(--muted) !important;
    opacity: .85 !important;
  }
  /* Keep unread strong and vivid */
  #view-mail .mail-item.unread .sender{
    font-weight: 800 !important;
  }

  /* Panels adopt "card" look in non-CRT */
  #view-mail:not(.crt-on) .mail-left,
  #view-mail:not(.crt-on) .mail-right{
    background: linear-gradient(180deg, rgba(255,255,255,.055), rgba(255,255,255,.025)) !important;
    border: none !important;
    box-shadow: 0 10px 28px rgba(2,6,23,.30), inset 0 1px 0 rgba(255,255,255,.03) !important;
  }

  /* Left list items: subtle separators + hover/selected harmony */
  #view-mail .mail-item{
    position: relative;
    background: transparent;
    border: 1px solid rgba(255,255,255,.06);
  }
  #view-mail .mail-item + .mail-item{
    margin-top: 6px;
  }
  #view-mail .mail-item:hover{
    background: rgba(255,255,255,.035) !important;
    border-color: rgba(255,255,255,.12) !important;
  }
  #view-mail .mail-item.selected{
    background: rgba(34,211,238,.10) !important; /* cyan tint */
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 1px var(--accent) inset, 0 0 18px rgba(34,211,238,.15) !important;
  }

  /* Right pane headings & meta harmony in non-CRT */
  #view-mail:not(.crt-on) #mailSubj{
    color: #fff !important;
    text-shadow: 0 1px 0 rgba(0,0,0,.2);
  }
  #view-mail:not(.crt-on) .mail-right .small{
    color: var(--muted) !important;
  }

  /* Badge tone siiiightly softer */
  #view-mail .badge{
    background: var(--danger);
    opacity: .95;
  }

  /* Respect existing CRT colors; just ensure read-state still dims inside CRT */
  #view-mail.crt-on .mail-item:not(.unread) .sender,
  #view-mail.crt-on .mail-item:not(.unread) .subj,
  #view-mail.crt-on .mail-item:not(.unread) .meta{
    opacity: .8 !important;
    filter: saturate(.85);
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="slot-canvas-styles">
/* === Canvas Slot (3D-ish) =============================================== */
.slotCanvas-wrap{ display:flex; gap:16px; align-items:center; flex-wrap:wrap; }
.slotCanvas-box{
  position:relative; padding:16px; border-radius:14px;
  background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
  border:1px solid rgba(255,255,255,.08);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 10px 26px rgba(0,0,0,.4);
}
.slotCanvas-frame{ width:100%; border-radius: 12px; overflow:hidden;
  background: radial-gradient(120% 110% at 50% 50%, rgba(20,26,45,.95), rgba(5,9,25,.98));
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), inset 0 8px 22px rgba(255,255,255,.03);
}
.slotCanvas-frame:after{ /* glassy sheen */
  content:""; position:absolute; inset:0; pointer-events:none; border-radius:inherit;
  background: linear-gradient(90deg, rgba(255,255,255,.20), transparent 28%, transparent 72%, rgba(255,255,255,.12));
  opacity:.25; mix-blend-mode: overlay;
}
.slotCanvas-divider{ width:2px; height:72px; background:rgba(255,255,255,.08); border-radius:2px; }
.slotCanvas-controls{ display:flex; flex-direction:column; gap:8px; min-width: 190px;}
.slotCanvas-hint{ min-height:2.2em;}
/* Win pulse */
.slotCanvas-frame.win{ animation: slotCanvasPulse .9s ease-out 0s 1; }
@keyframes slotCanvasPulse{
  0%{ box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), 0 0 0 rgba(0,0,0,0); }
  30%{ box-shadow: inset 0 0 0 1px rgba(52,211,153,.6), 0 0 24px rgba(52,211,153,.55); }
  100%{ box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), 0 0 0 rgba(0,0,0,0); }
}
/* removed fixed small-screen slotCanvas-frame sizing to keep responsive width */



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="slotButtonGuard">
.slotCanvas-controls .btn{ width:100% !important; min-height:52px !important; padding:14px 16px !important; }
.slotCanvas-controls .btn:hover,.slotCanvas-controls .btn:active{ transform:none !important; }

/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="slotWrapGuard">
.slotCanvas-wrap{ display:flex; flex-direction:column; align-items:stretch; gap:14px; }
.slotCanvas-box,.slotCanvas-frame,.slotCanvas-controls{ width:100%; }

/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="brand-logo-css">
.brand-logo-wrap{ display:flex; flex-direction:column; align-items:flex-start; }
.brand-logo-img{ height: 88px; width:auto; display:block; }
.brand-tagline{ margin-top: 6px; font-size: 20px; line-height: 1.3; opacity: 0.95; font-weight: 500; }
@media (max-width: 640px){
  .brand-logo-img{ height: 68px; }
  .brand-tagline{ font-size: 18px; }
}
</style>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#111111">

</head>
<body>
<script>window.slotDelayLog = true;</script>
<!-- DISCLAIMER: This is a purely fictional idle-game prototype.
       It is not advice or instruction for real-world actions. -->
<div class="app">
<aside class="sidebar" id="sidebar">
<div class="brand">
<div class="logo">CI</div>
<div class="name">Crimidle</div>
</div>
<div class="section-label">Main</div>
<nav aria-label="Main Sections" class="sidenav" role="tablist">
<a class="sidelink" data-tab="mail" id="mailLink">
<span class="k">üì´</span>
<span>Email</span>
<span aria-label="unread messages" class="badge hidden" id="mailBadge">0</span>
</a>
<a class="sidelink" data-tab="headquarters"><span class="k">üè¢</span><span>Headquarters</span></a>
<a class="sidelink" data-tab="property"><span class="k">üè†</span><span>Property Market</span></a>
<a aria-current="page" class="sidelink" data-tab="activities"><span class="k">üé≤</span><span>Activities</span></a>
<a class="sidelink" data-tab="gambling"><span class="k">üé∞</span><span>Gambling</span></a>
<a class="sidelink" data-tab="recruitment"><span class="k">üßë‚Äçü§ù‚Äçüßë</span><span>Recruitment</span></a>
<a class="sidelink" data-tab="stats"><span class="k">üìä</span><span>Stats</span></a>
<a class="sidelink" data-tab="inventory"><span class="k">üéí</span><span>Inventory</span></a>
<a class="sidelink" data-tab="territory" id="territoryLink"><span class="k">‚öîÔ∏è</span><span>Territory Battle</span></a>
<a class="sidelink" data-tab="upgrades"><span class="k">üõ†Ô∏è</span><span>Upgrades (WIP)</span></a>
<a class="sidelink" data-tab="shop"><span class="k">üõí</span><span>Shop</span></a>
<a class="sidelink" data-tab="analytics"><span class="k">üìà</span><span>Analytics</span></a>
</nav>
<div class="sidebar-footer">
<button class="btn secondary" id="debugBtn" title="Show or hide code details">Debug: Off</button>
<button class="btn secondary collapse-btn" id="toggleSidebarBtn">Close Menu</button>
<div class="small muted">Fictional prototype</div>
</div>
</aside>
<main class="content">
<div class="container">
<header>
<div class="row">
<button class="collapse-btn" id="openSidebarBtn">Menu</button>
<div class="row" style="align-items:center; gap:10px"><img alt="CrimIdle ‚Äî Start with nothing. Become legend." class="brand-logo-img" src="crimidle-logo-ui-nobg.png"/></div>
</div>
<div class="row headerbar" style="justify-content:flex-end"><div class="info-cluster">
<div class="clock-txt" id="clockTxt">Clock: <strong><span id="clockText">Day 1 ‚Äî 00:00</span></strong>
<span class="small muted codepath debug-block">Source: <strong>state.time.epochMs + state.time.gameMs</strong> ‚Ä¢ scale <strong>GAME_TIME_SCALE</strong> ‚Ä¢ advanced by <strong>advanceGameTime(dtMs)</strong></span>
</div>
<div class="pill">Balance: <strong>¬£<span id="balanceValue">0</span></strong></div>
<div class="pill" id="heatPill">
              Heat: <strong><span id="heatValue">0</span></strong>
<div class="small codepath debug-block">
                Source: <strong>state.heat</strong> (0..100) ‚Ä¢ Decay: <span id="heatDecayText">-1 per 5s</span> ‚Ä¢ Gains: <span id="heatGainsText">+4 success, +7 fail</span><br/>
                Penalty: <span id="heatPenaltyText">successChance() ‚àí (0.002 √ó heat)</span>
</div></div>
<div class="pill" id="autosavePill">
<span class="muted">Autosave</span>:
              <span class="codepath debug-inline"><strong id="saveKeyText">localStorage['idle-underworld-save-v1']</strong></span>
<span class="muted debug-inline"> ‚Ä¢ Last save: <span id="lastSaveText">never</span></span>
<button class="btn secondary debug-inline" id="copyKeyBtn" style="padding:6px 10px">Copy key</button>
</div>
<button class="btn secondary debug-block" id="sim10mBtn" title="Simulate 10 minutes offline (real time)">Sim +10m</button>
<button class="btn secondary debug-block" id="sim1hBtn" title="Simulate 1 hour offline (real time)">Sim +1h</button>
<button class="btn secondary debug-block" id="giveCashBtn" title="Grant ¬£100">+¬£100</button>
<button class="btn secondary debug-block" id="giveXPBtn" title="Grant XP to all stats">+XP</button>
<button class="btn secondary" id="resetBtn">Reset</button>
</div>
</div>
</header>
<!-- Views -->
<section aria-hidden="true" class="hidden" id="view-headquarters" role="tabpanel">
<div class="grid two">
<div class="hq-col">
<div class="hq-tabs"><div class="row" id="hqActions" style="gap:8px;flex-wrap:wrap">
<button class="btn" id="btnHQStorage">Storage</button>
<button class="btn secondary" id="btnHQGarage">Garage</button>
</div></div>
<div class="card">
<div class="hq-head">
<h3>Headquarters</h3>
</div>
<div class="muted" id="hqNone">No headquarters selected. Go to <strong>Property ‚Üí Holdings</strong> and choose <em>Set as HQ</em>.
                <div class="small codepath debug-block">Debug: hqId=<strong id="hqDbgId">null</strong>; holdings=<strong id="hqDbgHoldN">0</strong>; offers=<strong id="hqDbgOffN">0</strong>; pool=<strong id="hqDbgPoolN">?</strong></div>
<div class="row"><button class="btn secondary debug-block" id="hqRefresh">Refresh HQ</button></div>
</div>
<div class="hidden" id="hqDetails">
<div class="row" style="gap:8px;flex-wrap:wrap">
<div class="pill">Name: <strong id="hqName">‚Äî</strong></div>
<div class="row" style="gap:12px;flex-wrap:wrap;margin:10px 0 12px 0">
<button class="btn" id="btnCrewJobs">Crew Jobs</button>
<span class="muted debug-inline">‚Ä¢ UI: <strong>renderCrewActionsPanel()</strong></span>
</div>
<div aria-hidden="true" class="card hidden" id="hqCrewPanel">
<h4>Crew Actions</h4>
<div id="hqCrewList"></div>
<div class="small codepath debug-block">Source: <strong>state.recruitment.crew</strong> ‚Ä¢ UI: <strong>renderCrewActionsPanel()</strong></div>
</div>
<div class="pill">Location: <strong id="hqLoc">‚Äî</strong></div>
</div>
<div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
<div class="pill">Storage: <strong id="hqStorage">‚Äî</strong></div>
<div class="pill">Occupied: <strong id="hqStorageUsed">0</strong>/<strong id="hqStorageCap">0</strong></div>
<div class="pill">Garage: <strong id="hqGarage">‚Äî</strong></div>
<div class="pill">Monthly: <strong id="hqMonthly">‚Äî</strong></div>
</div>
<div class="small codepath debug-block">Source: <strong>state.hq.propertyId</strong> ‚Üí lookup in <strong>state.properties.holdings</strong></div>
</div>
</div>
</div>
  <div id="hqBasement3D" class="hidden" style="margin-top:12px">
    <div class="small muted" style="margin-bottom:6px">HQ: Virtual Space</div>
    <div id="basement3DWrap" style="position:relative; height:260px; background:#0b0f14; border:1px solid var(--muted-2); border-radius:10px; overflow:hidden">
      <canvas id="basement3DCanvas"></canvas>
      <div id="basement3DHint" style="position:absolute; left:8px; bottom:8px; font-size:12px; color:#94a3b8; background:rgba(15,23,42,0.6); padding:4px 6px; border-radius:6px">
        Click to look around ‚Ä¢ WASD to move ‚Ä¢ Esc to release mouse
      </div>
    </div>
  </div>

<div class="card">
<h3>Planned Systems</h3>
<ul class="list">
<li class="li">Upgrades: security, stash size, counterfeit lab</li>
<li class="li">Staff: recruiters, fences, fixers</li>
<li class="li">Passive income buildings &amp; upkeep</li>
</ul>
<p class="small muted">These are placeholders ‚Äî no mechanics wired yet.</p>
</div>
</div>
<div aria-hidden="true" aria-label="HQ Storage Manager" class="modal hidden" id="storageModal" role="dialog">
<div class="modal-card">
<div class="modal-head">
<h4>HQ Storage</h4>
<button class="btn sm secondary" id="closeStorage">Close</button>
</div>
<div class="row" style="gap:8px;flex-wrap:wrap;margin-bottom:8px">
<div class="pill">Capacity: <strong id="storeCap">0</strong></div>
<div class="pill">Used: <strong id="storeUsed">0</strong></div>
<div class="pill">Free: <strong id="storeFree">0</strong></div>
</div>
<div class="grid two">
<div class="card">
<h4>Inventory</h4>
<div id="invForStore"></div>
</div>
<div class="card">
<h4>HQ Storage</h4>
<div id="gridStorage"></div>
</div>
</div>
<div class="small codepath debug-block">Source: <strong>state.storage</strong> (items[], cap from HQ holding.storage) ‚Ä¢ UI: <strong>renderStorageManager()</strong></div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-recruitment" role="tabpanel">
<div class="row" style="gap:12px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Daily rotation: <strong id="recruitDayKey">‚Äî</strong></div>
<div class="pill">Next refresh: <strong id="recruitNextRefresh">‚Äî</strong></div>
<span class="muted debug-inline">‚Ä¢ Data: <strong>RECRUIT_NAME_POOL</strong></span>
</div>
<div class="grid two">
<div class="card">
<h3>Daily Candidates</h3>
<div id="recruitCandidates"></div>
<div class="small codepath debug-block" id="recruitDbg">Debug: dayKey=<strong id="recruitDbgKey">‚Äî</strong>; cands=<strong id="recruitDbgN">0</strong>; crew=<strong id="recruitDbgCrewN">0</strong></div>
<div class="small codepath debug-block">Source: <strong>state.recruitment.daily</strong> ‚Ä¢ UI: <strong>renderRecruitmentView()</strong></div>
</div>
<div class="card">
<h3>Your Crew <span class="muted small">(max 3)</span></h3>
<div id="crewList"></div>
<div class="small codepath debug-block">Source: <strong>state.recruitment.crew</strong> ‚Ä¢ Actions: <strong>doCrewPickpocket()</strong></div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-property" role="tabpanel">
<div class="row" id="propertyCats" style="margin:6px 0 10px 0">
<button aria-pressed="true" class="btn toggle" id="btnPropRent" title="Category: Rent">Rent</button>
<button aria-pressed="false" class="btn toggle" id="btnPropBuy" title="Category: Buy">Buy</button>
<button aria-pressed="false" class="btn toggle" id="btnPropHoldings" title="Category: Holdings">Holdings</button>
</div>
<div class="catwrap" id="prop-rent">
<div class="row" style="gap:12px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Daily rotation: <strong id="rentDayKey">‚Äî</strong></div>
<div class="pill">Next refresh: <strong id="rentNextRefresh">‚Äî</strong></div>
</div>
<div class="grid" id="rentOffers"></div>
<div class="small codepath debug-block">Source: <strong>state.properties.daily</strong> ‚Ä¢ Pool: <strong>RENTAL_POOL</strong> ‚Ä¢ UI: <strong>renderRentOffers()</strong></div>
</div>
<div class="catwrap hidden" id="prop-buy">
<div class="grid">
<div class="card">
<h3>Buy a Property</h3>
<p class="small">Purchase **fronts**, **lockups**, and **workshops**. (Placeholder)</p>
<div class="row"><button class="btn secondary" disabled="">Open Marketplace (WIP)</button></div>
<div class="small codepath debug-block">Source: <strong>view-property ‚Üí prop-buy</strong></div>
</div>
</div>
</div>
<div class="catwrap hidden" id="prop-holdings">
<div class="grid" id="holdingsList"></div>
<div class="small codepath debug-block">Source: <strong>state.properties.holdings[]</strong> ‚Ä¢ UI: <strong>renderHoldings()</strong></div>
</div>
</section>
<section id="view-activities" role="tabpanel">
<div class="row" id="activityCats" style="margin:6px 0 10px 0">
<button aria-pressed="true" class="btn toggle" id="btnCatPetty" title="Category: Petty Crime">Petty Crime</button>
<button aria-pressed="false" class="btn toggle" id="btnCatSmall" title="Category: Small Jobs">Small Jobs</button>
</div>
<div class="catwrap" id="cat-petty">
<div class="grid">
<div class="card" data-category="petty">
<h3>Pickpocket (Starter Action)</h3>
<p class="small">Make a quick attempt to lift some spare change. Outcomes are random and purely fictional.</p>
<div class="row" style="margin:10px 0 8px">
<div aria-label="Cooldown progress" aria-live="polite" class="progress">
<div class="bar" id="progressBar"></div>
</div>
</div>
<div class="row">
<div class="small muted">
                  Chance of success: <strong><span id="chanceValue">50</span>%</strong>
<span class="small debug-inline">(<span id="chanceDetail"></span>)</span>
</div>
<button class="btn" id="pickBtn">Attempt Pickpocket</button>
</div>
</div>
</div>
</div>
<div class="card" data-category="petty" id="card-searchbags">
<h3>Search bags (Unlocks at Sleight L1)</h3>
<p class="small">Higher rewards than pickpocketing, but a lower base chance. Purely fictional.</p>
<div class="row" style="margin:10px 0 8px">
<div aria-label="Cooldown progress (shared)" aria-live="polite" class="progress">
<div class="bar" id="searchProgressBar"></div>
</div>
</div>
<div class="row">
<div class="small muted">
      Chance of success: <strong><span id="searchChanceValue">35</span>%</strong>
<span class="small debug-inline">(<span id="searchChanceDetail"></span>)</span>
<span class="small red" id="searchLockedNote" style="margin-left:8px; display:none">Locked: Sleight of Hand L1</span>
</div>
<button class="btn" id="searchBtn">Search Bags</button>
</div>
</div>
<div class="catwrap hidden" id="cat-small">
<div class="grid">
<div class="card" data-category="petty">
<h3>Small Jobs (Placeholder)</h3>
<p class="small">General odd jobs and favors. This category will hold abstract, safe mini-tasks (no real-world methods).</p>
<div class="row">
<button class="btn" disabled="" id="smallJobBtn">Coming soon</button>
</div>
</div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-stats" role="tabpanel">
<div class="grid">
<div class="card">
<h3>Player Info</h3>
<div class="row" style="gap:12px;flex-wrap:wrap">
<div class="pill">Alias: <strong id="aliasText">(unset)</strong> <button class="btn sm secondary" id="aliasEditBtn" style="margin-left:8px">Edit</button></div>
<div class="pill">Reputation: <strong>Neutral</strong></div>
<div class="pill meter-inline">
<span class="icon">‚ù§Ô∏è</span><span class="small muted">Health</span>
<div class="progress tiny"><div class="bar" id="healthBar" style="width:100%"></div></div>
<span id="healthPct">100%</span>
<span class="small muted codepath debug-block">Source: <strong>state.vitals.health</strong> ‚Ä¢ updated by <strong>addHealth(pct)</strong></span>
</div>
<div class="pill meter-inline">
<span class="icon">üçû</span><span class="small muted">Hunger</span>
<div class="progress tiny"><div class="bar" id="hungerBar" style="width:100%"></div></div>
<span id="hungerPct">100%</span>
<span class="small muted codepath debug-block">Source: <strong>state.vitals.hunger</strong> ‚Ä¢ decays via <strong>decayHunger(dt)</strong> ‚Ä¢ restored by <strong>addHunger(pct)</strong> / <strong>useConsumable()</strong></span>
</div>
</div>
<div class="small codepath debug-block">Source: <strong>state.profile.alias</strong></div>
<div class="equip-wrap">
<div aria-label="Equipment silhouette" class="equip-figure">
<!-- Simple inline SVG silhouette -->
<svg aria-hidden="true" viewbox="0 0 180 300">
<defs>
<lineargradient id="sil_g" x1="0" x2="0" y1="0" y2="1">
<stop offset="0" stop-color="#0f172a"></stop>
<stop offset="1" stop-color="#0b1220"></stop>
</lineargradient>
</defs>
<!-- Head -->
<circle cx="90" cy="40" fill="url(#sil_g)" r="26" stroke="#1f2937"></circle>
<!-- Body -->
<rect fill="url(#sil_g)" height="80" rx="16" stroke="#1f2937" width="70" x="55" y="70"></rect>
<!-- Arms -->
<rect fill="url(#sil_g)" height="60" rx="10" stroke="#1f2937" width="25" x="30" y="78"></rect>
<rect fill="url(#sil_g)" height="60" rx="10" stroke="#1f2937" width="25" x="125" y="78"></rect>
<!-- Legs -->
<rect fill="url(#sil_g)" height="90" rx="10" stroke="#1f2937" width="24" x="58" y="152"></rect>
<rect fill="url(#sil_g)" height="90" rx="10" stroke="#1f2937" width="24" x="98" y="152"></rect>
<!-- Feet -->
<rect fill="url(#sil_g)" height="16" rx="6" stroke="#1f2937" width="32" x="50" y="244"></rect>
<rect fill="url(#sil_g)" height="16" rx="6" stroke="#1f2937" width="32" x="98" y="244"></rect>
</svg>
<style>
  /* Map sizing tweaks */
  #tbMap{ max-width:560px; }
  @media (max-width: 900px){
    #tbMap{ height:160px; } /* avoid crowding on smaller widths */
  }
</style>
<!-- Clickable slots -->
<button class="slot dotbtn" data-slot="head" style="left:50%;transform:translateX(-50%); top:8px" title="Head"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="chest" style="left:50%;transform:translateX(-50%); top:96px" title="Chest"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="hands" style="left:8px; top:104px" title="Hands"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="legs" style="left:50%;transform:translateX(-50%); top:190px" title="Legs"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="feet" style="left:50%;transform:translateX(-50%); top:254px" title="Feet"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="accessory" style="right:8px; top:104px" title="Accessory"><span class="dot"></span></button>
</div>
<div class="equip-panel">
<div class="slots-list">
<div class="slot badge" data-slot="head"><span class="dot"></span><strong>Head</strong> <span class="muted" id="slot-head-label">(Empty)</span></div>
<div class="slot badge" data-slot="chest"><span class="dot"></span><strong>Chest</strong> <span class="muted" id="slot-chest-label">(Empty)</span></div>
<div class="slot badge" data-slot="hands"><span class="dot"></span><strong>Hands</strong> <span class="muted" id="slot-hands-label">(Empty)</span></div>
<div class="slot badge" data-slot="legs"><span class="dot"></span><strong>Legs</strong> <span class="muted" id="slot-legs-label">(Empty)</span></div>
<div class="slot badge" data-slot="feet"><span class="dot"></span><strong>Feet</strong> <span class="muted" id="slot-feet-label">(Empty)</span></div>
<div class="slot badge" data-slot="accessory"><span class="dot"></span><strong>Accessory</strong> <span class="muted" id="slot-accessory-label">(Empty)</span></div>
</div>
<div class="equip-legend muted small debug-block">
                Source: <strong>state.equipment</strong> ‚Üí head, chest, hands, legs, feet, accessory
              </div>
<div class="small muted">Click a slot or chip to open the equip panel. Loot is WIP.</div>
</div>
</div>
<div class="buffs" style="margin-top:12px">
<h4 style="margin:6px 0 8px 0">Equipment Buffs</h4>
<div class="row" id="buffPills" style="gap:8px;flex-wrap:wrap">
<span class="pill muted">No active buffs</span>
</div>
<div class="small codepath debug-block">Source: <strong>getEquippedBuffTotals(state)</strong> (derived)</div>
</div>
</div>
<div class="card">
<h3>Skills &amp; Progress</h3>
<div class="small muted" id="statsEmpty">No stats yet.</div>
<div aria-busy="false" aria-live="polite" class="stack" id="statsList">
<!-- Filled by updateUI() via renderStatRow(...) -->
</div>
</div></div>
</section>
<section aria-hidden="true" class="hidden" id="view-inventory" role="tabpanel">
<div class="grid">
<div class="card span-2">
<h3>Inventory</h3>
<p class="small" id="invSpaceText">Space: <span id="invUsed">0</span>/<span id="invCap">6</span></p>
<div class="small codepath debug-block">Source: <strong>state.inventory[]</strong> (id, name, slot, rarity, equipped)</div>
<p class="small muted" id="invEmpty">Your inventory is empty.</p>
<div class="inv-grid hidden" id="invGrid"></div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-shop" role="tabpanel">
<div class="grid">
<div class="card span-2">
<h3>Shop</h3>
<div class="row" style="gap:8px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Balance: <strong>¬£<span id="shopBalance">0</span></strong></div>
<span class="muted debug-inline">‚Ä¢ Data: <strong>SHOP_ITEMS</strong></span>
</div>
<h4>Food &amp; Drink</h4>
<ul class="list" id="shopFood"></ul>
<h4>Medical</h4>
<ul class="list" id="shopMed"></ul>
<div class="small codepath debug-block">
        Source: <strong>SHOP_ITEMS</strong> ‚Ä¢ UI: <strong>renderShop()</strong> ‚Ä¢ Purchase: <strong>buyShop(id)</strong><br/>
        Inventory add: <strong>addConsumableToInventory(item)</strong> ‚Ä¢ Use: <strong>useConsumable(itemId)</strong><br/>
        Effect: <strong>target="hunger"</strong> ‚Ä¢ <strong>pct=40</strong> for Burger
      </div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-analytics" role="tabpanel">
<div class="grid analytics-grid">
<div class="card">
<h3>Economy Analytics</h3>
<div class="row" style="flex-wrap:wrap; gap:12px">
<div class="pill">Earned: <strong id="metricEarned">¬£0</strong></div>
<div class="pill">Outgoings: <strong id="metricSpent">¬£0</strong></div>
<div class="pill">Net: <strong id="metricNet">¬£0</strong></div>
</div>
<div class="small codepath debug-block">Source: <strong>state.metrics.money</strong> ‚Üí earned=<span id="metricEarnedSrc">0</span>, spent=<span id="metricSpentSrc">0</span>, net=earned‚àíspent</div>
</div>
<div class="card span-2">
<h3>Heat Analytics</h3>
<div class="row row-nowrap" style="gap:12px">
<div class="pill">Current: <strong><span id="metricHeatCurrent">0</span></strong></div>
<div class="pill">Peak: <strong><span id="metricHeatPeak">0</span></strong></div>
<div class="pill">Gained: <strong><span id="metricHeatGained">0</span></strong></div>
<div class="pill">Cooled: <strong><span id="metricHeatCooled">0</span></strong></div>
<div class="pill">Avg (session): <strong><span id="metricHeatAvg">0</span></strong></div>
</div>
<div aria-label="Current heat" class="progress">
<div class="bar" id="metricHeatBar" style="width:0%"></div>
</div>
<div class="small codepath debug-block">Source: <strong>state.metrics.heat</strong> ‚Üí peak=<span id="metricHeatPeakSrc">0</span>, gained=<span id="metricHeatGainedSrc">0</span>, cooled=<span id="metricHeatCooledSrc">0</span>, avg=<span id="metricHeatAvgSrc">0</span></div>
</div>
<div class="card span-2">
<h3>Realtime Graph</h3>
<div class="rangebar" id="chartRanges">
<button aria-pressed="false" class="rangebtn" data-range="60000">1m</button>
<button aria-pressed="true" class="rangebtn" data-range="300000">5m</button>
<button aria-pressed="false" class="rangebtn" data-range="900000">15m</button>
<button aria-pressed="false" class="rangebtn" data-range="3600000">1h</button>
<button aria-pressed="false" class="rangebtn" data-range="session">Session</button>
<button aria-pressed="false" class="rangebtn" data-range="all">All-time</button>
</div>
<div class="chartWrap">
<canvas height="220" id="analyticsChart" width="1000"></canvas>
</div>
<div class="legend"><span class="dot money"></span> Balance ‚Ä¢ <span class="dot heat"></span> Heat ‚Ä¢ <span class="dot spent"></span> Outgoings</div>
<div class="small codepath debug-block">Source: <strong>history/session</strong> + <strong>history/lifetime</strong> ‚Ä¢ sample=<span id="dbgSampleCt">0</span> ‚Ä¢ range=<span id="dbgRangeLabel">5m</span> ‚Ä¢ y=[<span id="dbgYMin">0</span>, <span id="dbgYMax">0</span>] ‚Ä¢ last hist save=<span id="dbgHistSave">never</span></div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-upgrades" role="tabpanel">
<div class="grid">
<div class="card">
<h3>Upgrades (Placeholder)</h3>
<ul class="small">
<li>Skill tree (unlock faster cooldowns, better chances)</li>
<li>Locations (safer areas vs. risky areas)</li>
<li>Passive systems (purely fictional)</li>
<li>Heat/Attention meter (rises with failures)</li>
<li>Simple save/load via localStorage</li>
</ul>
</div>
</div>
</section>
<!-- Global Activity Log (always visible) -->
<section aria-hidden="true" class="hidden" id="view-mail" role="tabpanel">
<div class="card span-2">
<h3>Email <button class="mail-chip" id="mailThemeToggle" title="Toggle CRT theme">CRT: OFF</button></h3>
<div class="mail-grid">
<div class="mail-left">
<ul aria-busy="false" aria-live="polite" class="list mail-list" id="mailList"></ul>
</div>
<div class="mail-right">
<div class="small muted" id="mailEmpty">No messages yet.</div>
<div aria-hidden="true" class="hidden" id="mailRead">
<h4 id="mailSubj">‚Äî</h4>
<div class="small muted" style="margin:-6px 0 10px 0">
            From: <strong id="mailFrom">‚Äî</strong> ‚Ä¢ <span id="mailAgo">‚Äî</span>
</div>
<div class="mail-body" id="mailBody"></div>
</div>
</div>
</div>
<div class="small codepath debug-block">Source: <strong>state.mail.inbox[]</strong> ‚Ä¢ UI: <strong>renderMailView()</strong></div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-gambling" role="tabpanel">
<div class="grid">
<div class="card span-2">
<h3>Gambling</h3>
<!-- Tier toggles (similar placement to Property page buy/rent/holdings) -->
<div class="row" id="gamblingTiers" style="margin:6px 0 10px 0">
<button aria-pressed="true" class="btn toggle" id="btnTier1" title="Tier 1">Tier 1</button>
<button aria-pressed="false" class="btn toggle" id="btnTier2" title="Tier 2 (Placeholder)">Tier 2</button>
<button aria-pressed="false" class="btn toggle" id="btnTier3" title="Tier 3 (Placeholder)">Tier 3</button>
</div>
<!-- Tier 1: Fruit Machine -->
<div class="catwrap" id="tier-1">
<div class="row" style="gap:12px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Balance: <strong>¬£<span id="gambleBalance">0</span></strong></div>
<div class="pill">Bet per spin: <input id="betInput" min="1" step="1" style="width:80px;margin-left:6px" type="number" value="1"/></div>
</div>
<div class="grid">
<div class="card">
<h4>Fruit Machine</h4>
<div class="slotCanvas-wrap">
<div class="slotCanvas-box">
<div class="slotCanvas-frame" id="slotCanvasFrame">
<canvas aria-label="Slot reels" height="140" id="slotCanvas" width="360"></canvas><div class="fadeMaskTop"></div><div class="fadeMaskBot"></div><div class="bars"></div>
</div>
</div>
<div class="slotCanvas-divider"></div>
<div class="slotCanvas-controls">
<button class="btn" id="spinBtn">Spin (¬£<span id="spinCost">1</span>)</button>
<button class="btn secondary" id="spinAutoBtn" title="Auto spins 10x if funds allow">Auto x10</button>
<div class="small muted slotCanvas-hint" id="slotMsg">Match symbols to win. Three of a kind pays best; any two pays small; cherry in first reel refunds bet.</div>
</div>
</div>
</div>
<div class="card">
<h4>Payouts</h4>
<ul class="list small">
<li class="li">7Ô∏è‚É£7Ô∏è‚É£7Ô∏è‚É£ ‚Üí <strong>20√ó bet</strong></li>
<li class="li">‚≠ê‚≠ê‚≠ê ‚Üí <strong>10√ó bet</strong></li>
<li class="li">üîîüîîüîî ‚Üí <strong>6√ó bet</strong></li>
<li class="li">üçíüçíüçí ‚Üí <strong>4√ó bet</strong></li>
<li class="li">Two 7Ô∏è‚É£ ‚Üí <strong>3√ó bet</strong></li>
<li class="li">Two ‚≠ê ‚Üí <strong>2√ó bet</strong></li>
<li class="li">Two üîî ‚Üí <strong>1√ó bet</strong></li>
<li class="li">Two üçí ‚Üí <strong>1√ó bet</strong></li>
<li class="li">üçí in the first reel ‚Üí <strong>1√ó bet</strong> (refund)</li>
</ul>
<div class="small codepath debug-block">Module: slotCanvas ‚Üí initSlotCanvas(), doCanvasSpin(), applyCanvasPayout()</div>
</div>
</div>
</div>
<!-- Placeholders for T2/T3 -->
<div class="catwrap hidden" id="tier-2">
<div class="row" style="gap:12px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Balance: <strong>¬£<span id="rouletteBalance">0</span></strong></div>
<div class="pill">Chip: ¬£<input id="rouletteChip" min="1" step="1" style="width:80px;margin-left:6px" type="number" value="1"/></div>
<div class="pill">Total Bet: <strong>¬£<span id="rouletteTotal">0</span></strong></div>
</div>
<div class="grid">
<div class="card span-2">
<h4>Roulette (European)</h4>
<div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">
<canvas height="340" id="rouletteCanvas" style="background:#0b0f14;border-radius:50%;box-shadow:0 0 0 1px #1f2937 inset" width="340"></canvas>
<div style="min-width:260px;max-width:420px">
<div class="small" id="rouletteExplainer">
                  Place chips on numbers or outside bets. European roulette uses a single 0 (house edge ‚âà 2.70%). Payouts: straight 35:1, dozen/column 2:1, even-money (red/black, odd/even, low/high) 1:1. Choose a chip value, click bets to add them, then press <em>Spin</em>. The wheel spins every round; results and history appear below.
                </div>
<div class="row" style="gap:8px;margin-top:8px;flex-wrap:wrap">
<button class="btn" id="rouletteSpin">Spin</button>
<button class="btn secondary" id="rouletteClear">Clear Bets</button>
<button class="btn secondary" id="rouletteRebet">Rebet</button>
</div>
<div class="small muted" id="rouletteMsg" style="margin-top:8px"></div>
<div class="small" style="margin-top:8px">Last 10: <span id="rouletteHistory"></span></div>
</div>
</div>
</div>
<div class="card span-2">
<h4>Betting Table</h4>
<div class="roulette-table" id="rouletteTable"></div>
<div class="small muted" style="margin-top:8px">Tip: Click again on a placed bet in the list to remove it. You can place multiple bets before spinning.</div>
<h5 style="margin-top:10px">Placed Bets</h5>
<ul class="list" id="rouletteBets"></ul>
</div>
</div>
</div>
<div class="catwrap hidden" id="tier-3">
<div class="card"><h4>Tier 3</h4><p class="small">Placeholder ‚Äî coming soon.</p></div>
</div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-territory" role="tabpanel">
<div class="grid">
<div class="card span-2">
<h3>Territory Battle</h3>
<div class="card" style="margin-bottom:10px">
<h4>City Map</h4>
<div class="tbMapWrap" style="display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap;">
<div class="tbMapCol" style="flex:1 1 420px; min-width:320px;">
<svg aria-label="Territory Map (6 regions)" height="190" id="tbMap" role="img" viewbox="0 0 300 200" width="100%">
<style>
    #tbMap [data-r]{ stroke:#121821; stroke-width:2; stroke-linejoin:round; stroke-linecap:round; }
  </style>
<!-- 2 rows x 3 cols -->
<!-- Stylized city territories (irregular, but same 2x3 layout) -->
<path d="M0,0 L100,0 L94,40 L108,80 L98,100 L0,100 Z" data-r="0"></path>
<path d="M100,0 L200,0 L206,40 L192,70 L202,100 L140,106 L98,100 L108,80 L94,40 Z" data-r="1"></path>
<path d="M200,0 L300,0 L300,102 L260,102 L202,100 L192,70 L206,40 Z" data-r="2"></path>
<path d="M0,100 L98,100 L104,140 L96,180 L100,200 L0,200 Z" data-r="3"></path>
<path d="M98,100 L140,106 L202,100 L190,140 L210,172 L200,200 L100,200 L96,180 L104,140 Z" data-r="4"></path>
<path d="M202,100 L260,102 L300,102 L300,200 L200,200 L210,172 L190,140 Z" data-r="5"></path>
<!-- labels -->
<g dominant-baseline="middle" fill="#ddd" font-size="12" id="tbMapLabels" text-anchor="middle">
<text x="50" y="50"></text>
<text x="150" y="50"></text>
<text x="250" y="50"></text>
<text x="50" y="150"></text>
<text x="150" y="150"></text>
<text x="250" y="150"></text>
</g>
</svg>
<div class="small codepath debug-block" id="tbDebug"></div>
</div>
<div class="tbExplainCol" style="flex:1 1 360px; min-width:300px;">
<style>
    /* Scoped styles for the map help panel */
    .tbHelpPanel{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.06);
      border-radius:12px;padding:12px 14px;}
    .tbHelpPanel h5{margin:4px 0 10px 0;}
    .tbHelpPanel .tbLegendTitle{font-size:12px;opacity:.8;letter-spacing:.04em;text-transform:uppercase;margin:2px 0 6px 0;}
    .tbHelpPanel .tbLegend{display:grid;grid-template-columns:auto 1fr;gap:8px 12px;margin:0 0 10px 0;align-items:center}
    .tbHelpPanel .badge{padding:6px 12px;border-radius:999px;font-weight:600;box-shadow:inset 0 0 0 1px rgba(0,0,0,.2)}
    .tbHelpPanel .badge.target{background:#f1c40f;color:#0e141b}
    .tbHelpPanel .badge.captured{background:#2ecc71;color:#0e141b}
    .tbHelpPanel .badge.locked{background:#2c3e50;color:#d6e1ea}
    .tbHelpPanel ul{margin:0;padding-left:18px}
    .tbHelpPanel li{margin:0 0 8px 0;line-height:1.5}
  </style>
<div class="tbHelpPanel">
<h5 class="muted">How Territory Works</h5>
<div class="tbLegendTitle">Legend</div>
<div class="tbLegend">
<div class="badge target">Target</div><div>Current objective</div>
<div class="badge captured">Captured</div><div>Under your control</div>
<div class="badge locked">Locked</div><div>Capture more to unlock</div>
</div>
<ul>
<li><strong>Goal:</strong> Capture all 6 regions.</li>
<li><strong>Runs &amp; Waves:</strong> Each run has 10 waves. Win waves to advance; a loss ends the run.</li>
<li><strong>Capture:</strong> Clearing wave 10 captures the current <em>Target</em> region and the next locked region becomes the new target.</li>
<li><strong>Tiers:</strong> Tier <em>N</em> unlocks after capturing <em>N‚àí1</em> regions (Tier = captured + 1, max T6). Higher tiers spawn tougher enemies.</li>
<li><strong>Combat:</strong> <em>Strength</em> becomes your <em>Power</em> (damage &amp; max HP). <em>Toughness</em> reduces incoming damage and boosts regen. The message shows estimated TTK and expected damage if you win.</li>
<li><strong>Loot:</strong> Wins can drop gear. Use <em>Transfer</em> to move items to your inventory; <em>Discard</em> to skip.</li>
<li><strong>Tip:</strong> Use <em>Quick Sim (10 waves)</em> to speed through a run once you‚Äôre healthy enough.</li>
</ul>
</div>
</div>
</div>
<div class="row" style="gap:8px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Tier: 
          <button aria-pressed="true" class="btn toggle" id="tbTier1">T1</button>
<button aria-pressed="false" class="btn toggle" id="tbTier2">T2</button>
<button aria-pressed="false" class="btn toggle" id="tbTier3">T3</button>
<button aria-pressed="false" class="btn toggle" id="tbTier4">T4</button>
<button aria-pressed="false" class="btn toggle" id="tbTier5">T5</button>
<button aria-pressed="false" class="btn toggle" id="tbTier6">T6</button>
</div>
<div class="small muted" id="tbTierHint" style="margin-left:8px"></div>
<div class="pill">Wave: <strong id="tbWave">1</strong>/10</div>
</div>
<div class="grid">
<div class="card">
<h4>You</h4>
<div class="row" style="gap:12px;flex-wrap:wrap">
<div class="pill">Strength: <strong id="tbYouStr">0</strong></div>
<div class="pill">Toughness: <strong id="tbYouTgh">0</strong></div>
<div class="pill">Power: <strong id="tbYouPow">0</strong></div>
<div class="pill meter-inline">
<span class="icon">‚ù§Ô∏è</span><span class="small muted">Your Health</span>
<div class="progress tiny"><div class="bar" id="tbHealthBar" style="width:100%"></div></div>
<span id="tbHealthPct">100%</span>
</div>
</div>
</div>
<div class="card">
<h4>Enemy</h4>
<div class="row" style="gap:12px;flex-wrap:wrap">
<div class="pill">Name: <strong id="tbEnemyName">‚Äî</strong></div>
<div class="pill">Strength: <strong id="tbEnemyStr">0</strong></div>
<div class="pill">Toughness: <strong id="tbEnemyTgh">0</strong></div>
<div class="pill">Power: <strong id="tbEnemyPow">0</strong></div>
<div class="pill meter-inline">
<span class="icon">üíÄ</span><span class="small muted">Enemy Health</span>
<div class="progress tiny"><div class="bar" id="tbEnemyHealthBar" style="width:100%"></div></div>
<span id="tbEnemyHealthPct">100%</span>
</div></div>
</div>
</div>
<div class="row" style="gap:10px;margin-top:10px;flex-wrap:wrap">
<button class="btn" id="tbStartBtn">Start / Next Wave</button>
<button class="btn secondary" id="tbSimBtn">Quick Sim (10 waves)</button>
<span class="small muted">Win waves to advance. Loss ends the run.</span>
</div>
<div class="pill meter-inline" id="tbBattleProgWrap" style="margin-top:6px">
<span class="icon">‚è≥</span><span class="small muted">Battle</span>
<div class="progress tiny"><div class="bar" id="tbBattleProgBar" style="width:0%"></div></div> <span id="tbBattleProgText">Ready</span>
</div>
<div class="small muted" id="tbMsg" style="margin-top:8px"></div>
<h4 style="margin-top:10px">Battle Log</h4>
<ul class="list" id="tbLog"></ul>
<div class="card" id="tbLootArea" style="margin-top:12px;">
<h4>Dropped Loot (Unclaimed)</h4>
<p class="small muted" id="tbLootEmpty">No unclaimed drops yet.</p>
<ul class="list" id="tbLootList"></ul>
</div>
</div>
</div>
</div></section>
<section aria-labelledby="activity-log-title" id="activity-log-global" role="region">
<div class="grid" style="margin-top:14px">
<div class="card">
<h3 id="activity-log-title">Activity Log</h3>
<p class="small muted" id="logEmpty">No activity yet. Try an action to begin.</p>
<ul aria-live="polite" class="list hidden" id="logList"></ul>
</div>
</div>
</section>
<footer>Fictional game prototype. Do not use as real-life guidance.</footer>
</div>
</main>
</div>
<script>
    // === PUBLIC API (stats) ===================================================
    window.getAllStats = function(){ return JSON.parse(JSON.stringify(state.stats)); };
    window.getStat = function(name){ return state.stats[name] ? { level: state.stats[name].level, xp: state.stats[name].xp } : null; };
    window.getStatLevel = function(name){ return state.stats[name]?.level ?? null; };
    window.getStatXP = function(name){ return state.stats[name]?.xp ?? null; };
    // ==========================================================================

    // === AUTOSAVE =============================================================
    const SAVE_KEY = 'idle-underworld-save-v1'; // shown in Debug
    const DEBUG_KEY = 'idle-underworld-debug';  // persists debug on/off
    window.getSaveKey = () => SAVE_KEY;
    window.forceSave = () => saveGame({ silent: false });
    window.clearSave = () => { localStorage.removeItem(SAVE_KEY); try{ if(state && state.territory){ delete state.territory; } }catch(e){} lastSavedAt = null; updateAutoSaveUI(); };

    let lastSavedAt = null;
    let saveTimer = null;
    function scheduleSave(){
      if(saveTimer) return;
      saveTimer = setTimeout(() => { saveTimer = null; saveGame({ silent: true }); }, 250);
    }
    function saveGame({ silent } = { silent: true }){
      try{
        const payload = {
version: 2,
          money: state.money,
          heat: state.heat,
          stats: state.stats,
          inventory: state.inventory,
          log: state.log.slice(0, MAX_LOG),
          equipment: state.equipment,
          profile: state.profile,
          vitals: state.vitals,
          metrics: state.metrics,
          history: { session: state.history.session.slice(-MAX_SESSION_SAMPLES) },
          time: state.time,
          properties: state.properties,
          recruitment: state.recruitment,
          storage: state.storage,
          hq: state.hq,
          territory: state.territory,
          lifetime: { all: state.lifetime.all.slice(-MAX_ALL_SAMPLES) },
          pickEndsAt,
          ts: Date.now(),
  mail: state.mail
};
        localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
        lastSavedAt = Date.now();
        if(!silent) addLog('Game saved.');
        updateAutoSaveUI();
      }catch(e){
        console.error('Save failed', e);
      }
    }
    function sanitizeNumber(n, d=0){ return (Number.isFinite(n) ? n : d); }
    function sanitizeStats(obj){
      const out = {};
      for(const [name, val] of Object.entries(obj || {})){
        if(!val || typeof val !== 'object') continue;
        let level = Number.isFinite(val.level) ? Math.max(0, Math.floor(val.level)) : 0;
        let xp = Number.isFinite(val.xp) ? Math.max(0, Math.floor(val.xp)) : 0;
        out[name] = { level, xp };
      }
      return out;
    }
    function sanitizeLogEntries(arr){
      const out = [];
      if(!Array.isArray(arr)) return out;
      for(const entry of arr.slice(0, MAX_LOG)){
        if(typeof entry === 'string'){
          out.push(String(entry).slice(0, 300));
        }else if(entry && typeof entry === 'object' && typeof entry.html === 'string'){
          let s = String(entry.html);
          if(s.length > 500) s = s.slice(0, 500);
          // strip any script tags if tampered
          s = s.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
          out.push({ html: s });
        }
      }
      return out;
    }

    function sanitizeMetrics(m){
      const mm = m && typeof m === 'object' ? m : {};
      const money = mm.money && typeof mm.money === 'object' ? mm.money : {};
      const heat = mm.heat && typeof mm.heat === 'object' ? mm.heat : {};
      return {
        money: {
          earned: sanitizeNumber(money.earned, 0),
          spent: sanitizeNumber(money.spent, 0)
        },
        heat: {
          peak: sanitizeNumber(heat.peak, 0),
          gained: sanitizeNumber(heat.gained, 0),
          cooled: sanitizeNumber(heat.cooled, 0),
          avg: sanitizeNumber(heat.avg, 0),
          _samples: sanitizeNumber(heat._samples, 0),
          _sum: sanitizeNumber(heat._sum, 0)
        }
      };
    }

    function sanitizeHistory(h){
      const obj = h && typeof h === 'object' ? h : {};
      return {
        session: sanitizeSamples(obj.session),
      };
    }
    function sanitizeLifetime(h){
      const obj = h && typeof h === 'object' ? h : {};
      return {
        all: sanitizeSamples(obj.all),
        seededOnce: !!obj.seededOnce
      };
    }

    function sanitizeEquipment(eq){
      const def = { head:null, chest:null, hands:null, legs:null, feet:null, accessory:null };
      const out = { ...def };
      if(eq && typeof eq === 'object'){
        for(const k of Object.keys(def)){
          const v = eq[k];
          out[k] = (typeof v === 'string' && v.length <= 60) ? v : null;
        }
      }
      return out;
    }
    function sanitizeProfile(p){
      const out = { alias: "" };
      if(p && typeof p === 'object'){
        let a = String(p.alias || "").trim();
        // allow letters, numbers, spaces, hyphen and underscore
        a = a.replace(/[^a-zA-Z0-9 _-]/g, "").slice(0,24);
        out.alias = a;
      }
      return out;
    }

    function sanitizeVitals(v){
      const out = { health: 100, hunger: 100 };
      if(v && typeof v === 'object'){
        let h = Number(v.health); if(!Number.isFinite(h)) h = 100; out.health = Math.max(0, Math.min(100, h));
        let g = Number(v.hunger); if(!Number.isFinite(g)) g = 100; out.hunger = Math.max(0, Math.min(100, g));
      }
      return out;
    }
    
    

function sanitizeTerritory(obj){
  const def = { tier:1, wave:1, active:false, enemy:null, lootQueue: [], regions: null, currentTarget: 0 };
  try{
    const o = obj || {};
    const out = {};
    // Core fields
    out.tier = Number.isFinite(o.tier) ? Math.max(1, Math.min(6, Math.floor(o.tier))) : 1;
    out.wave = Number.isFinite(o.wave) ? Math.max(1, Math.min(10, Math.floor(o.wave))) : 1;
    out.active = !!o.active;
    out.enemy = null;
    // Loot queue (safe)
    const q = Array.isArray(o.lootQueue) ? o.lootQueue : [];
    out.lootQueue = q.filter(it => it && typeof it==='object' && typeof it.id!=='undefined' && Array.isArray(it.mods)).slice(0, 50);
    // Regions (6 fixed)
    const names = ['Downtown','Harbor','Old Town','Heights','Industrial','Suburbs'];
    let regs = Array.isArray(o.regions) ? o.regions : [];
    if(regs.length !== 6){
      regs = names.map((name,i)=>({ id:i, name, status: i===0?'target':'locked' }));
    }else{
      regs = regs.map((r,i)=>({ id:i, name: String((r && r.name) || names[i]), status: (r && r.status)==='captured' ? 'captured' : ((r && r.status)==='target' ? 'target' : 'locked') }));
    }
    out.regions = regs;
    // Current target
    if(Number.isFinite(o.currentTarget)){
      out.currentTarget = Math.max(0, Math.min(5, Math.floor(o.currentTarget)));
    }else{
      const idx = regs.findIndex(r=>r.status==='target');
      out.currentTarget = idx>=0 ? idx : Math.min(5, regs.findIndex(r=>r.status!=='captured'));
    }
    // Preserve persisted battle log history (sanitized)
    try{
      const lh = Array.isArray(o.logHistory) ? o.logHistory.slice(0,200) : [];
      out.logHistory = lh.map(it => ({
        ts: (it && typeof it.ts!=='undefined') ? String(it.ts) : '',
        html: (it && typeof it.html!=='undefined') ? String(it.html) : ''
      }));
    }catch(e){ out.logHistory = []; }
    return Object.assign({}, def, out);
    }catch(e){
    return def;
  }
}


    function sanitizeTime(t){
      const now = Date.now();
      const out = { gameMs: 0, startedAt: now, epochMs: now - (now % (24*60*60*1000)) };
      if(t && typeof t === 'object'){
        const gm = Number(t.gameMs);
        out.gameMs = Number.isFinite(gm) && gm >= 0 ? Math.floor(gm) : 0;
        const sa = Number(t.startedAt);
        out.startedAt = Number.isFinite(sa) ? sa : now;
        const em = Number(t.epochMs);
        if(Number.isFinite(em) && em > 0) out.epochMs = em;
      }
      return out;
    }
    
    function sanitizeProperties(p){
      const out = { holdings: [], daily:{ dayKey:'', offers: [] } };
      if(!p || typeof p !== 'object') return out;
      // holdings
      if(Array.isArray(p.holdings)){
        for(const h of p.holdings.slice(0,50)){
          if(!h || typeof h!=='object') continue;
          const id = String(h.id||'').slice(0,60);
          const name = String(h.name||'').slice(0,80);
          const loc = String(h.loc||'').slice(0,80);
          const storage = Math.max(0, Math.min(9999, Number(h.storage)||0));
          const garage = Math.max(0, Math.min(9, Number(h.garage)||0));
          const monthly = Math.max(0, Math.min(1e7, Number(h.monthly)||0));
          const deposit = Math.max(0, Math.min(1e7, Number(h.deposit)||0));
          const nextRentDue = Math.max(0, Number(h.nextRentDue)||0);
          const overdue = !!h.overdue;
          const paid = Math.max(0, Number(h.paid)||0);
          const isHQ = !!h.isHQ;
          if(id && name){
            const storeItems = Array.isArray(h.storeItems) ? h.storeItems.slice(0,200).map(it=>({ id:String(it.id||'').slice(0,80), name:String(it.name||'').slice(0,80), slot: it.slot?String(it.slot):undefined, rarity: it.rarity?String(it.rarity):'common', type: it.type?String(it.type):undefined })) : [];
            out.holdings.push({ id, name, loc, storage, garage, monthly, deposit, nextRentDue, overdue, paid, isHQ, storeItems });
          }
        }

    function sanitizeRecruitment(r){
try{ window.sanitizeRecruitment = sanitizeRecruitment; }catch(e){}

      const out = { daily: { dayKey:'', candidates: [] }, crew: [] };
      if(!r || typeof r!=='object') return out;
      // daily
      const d = r.daily && typeof r.daily==='object' ? r.daily : {};
      out.daily.dayKey = String(d.dayKey||'');
      out.daily.candidates = Array.isArray(d.candidates) ? d.candidates.slice(0,12).map(c=>{
        if(!c || typeof c!=='object') return null;
        const id = String(c.id||'').slice(0,80);
        const name = String(c.name||'').slice(0,60);
        const alias = String(c.alias||'').slice(0,60);
        const bio = String(c.bio||'').slice(0,180);
        const cut = 0.5; // clamp to 50%
        const hireCost = 500;
        return { id, name, alias, bio, cut, hireCost };
      }).filter(Boolean) : [];
      // crew
      if(Array.isArray(r.crew)){
        for(const m of r.crew.slice(0,10)){
          if(!m || typeof m!=='object') continue;
          const id = String(m.id||'').slice(0,80);
          const name = String(m.name||'').slice(0,60);
          const alias = String(m.alias||'').slice(0,60);
          const bio = String(m.bio||'').slice(0,180);
          const cut = 0.5;
          const role = (typeof m.role==='string' && (m.role==='pick' || m.role==='pickpocket')) ? (m.role==='pick'?'pick':'pickpocket') : 'pickpocket';
          const auto = !!m.auto;

          const hiredAt = Math.max(0, Math.floor(Number(m.hiredAt)||0));
          const nextReadyAt = Math.max(0, Math.floor(Number(m.nextReadyAt)||0));
          out.crew.push({ id, name, alias, bio, cut, hiredAt, nextReadyAt, role, auto });
        }
      }
      return out;
    }

      }
      // daily offers
      if(p.daily && typeof p.daily==='object'){
        out.daily.dayKey = String(p.daily.dayKey||'');
        out.daily.offers = Array.isArray(p.daily.offers) ? p.daily.offers.filter(Boolean).slice(0,20) : [];
      }
      return out;
    }
    function sanitizeHQ(h){
      const out = { propertyId: null };
      if(h && typeof h === 'object'){
        const id = h.propertyId;
        if(typeof id === 'string' && id.length <= 60){ out.propertyId = id; }
      }
      return out;
    }
    function sanitizeStorage(s){
      const out = { items: [] };
      if(!s || typeof s!=='object') return out;
      if(Array.isArray(s.items)){
        for(const it of s.items.slice(0,200)){
          if(!it || typeof it!=='object') continue;
          const id = String(it.id||'').slice(0,80);
          const name = String(it.name||'').slice(0,80);
          const slot = it.slot ? String(it.slot) : undefined;
          const rarity = it.rarity ? String(it.rarity) : 'common';
          const type = it.type ? String(it.type) : undefined;
          out.items.push({ id, name, slot, rarity, type });
        }
      }
      return out;
    }
    
// --- Fallback to ensure sanitizeRecruitment exists before loadGame ---
if (typeof sanitizeRecruitment !== 'function') {
  function sanitizeRecruitment(r){
    const out = { daily: { dayKey:'', candidates: [] }, crew: [] };
    if(!r || typeof r!=='object') return out;
    const d = r.daily && typeof r.daily==='object' ? r.daily : {};
    out.daily.dayKey = String(d.dayKey||'');
    out.daily.candidates = Array.isArray(d.candidates) ? d.candidates.slice(0,12).map(c=>{
      if(!c || typeof c!=='object') return null;
      const id = String(c.id||'').slice(0,80);
      const name = String(c.name||'').slice(0,60);
      const alias = String(c.alias||'').slice(0,60);
      const bio = String(c.bio||'').slice(0,180);
      const cut = 0.5;
const hireCost = 500;
      return { id, name, alias, bio, cut, hireCost };
    }).filter(Boolean) : [];
    if(Array.isArray(r.crew)){
      for(const m of r.crew.slice(0,10)){
        if(!m || typeof m!=='object') continue;
        const id = String(m.id||'').slice(0,80);
        const name = String(m.name||'').slice(0,60);
        const alias = String(m.alias||'').slice(0,60);
        const bio = String(m.bio||'').slice(0,180);
        const cut = 0.5;
        const hiredAt = Math.max(0, Math.floor(Number(m.hiredAt)||0));
        const nextReadyAt = Math.max(0, Math.floor(Number(m.nextReadyAt)||0));
                  const role = (typeof m.role==='string' && (m.role==='pick' || m.role==='pickpocket')) ? (m.role==='pick'?'pick':'pickpocket') : 'pickpocket';
          const auto = !!m.auto;
out.crew.push({ id, name, alias, bio, cut, hiredAt, nextReadyAt, role, auto });
      }
    }
    return out;
  }
}

function loadGame(){
      try{
        const raw = localStorage.getItem(SAVE_KEY);
        if(!raw) return false;
        const data = JSON.parse(raw);
        if(!data || typeof data !== 'object') return false;
        state.money = Number.isFinite(data.money) && data.money >= 0 ? Math.floor(data.money) : 0;
        state.heat = Number.isFinite(data.heat) ? clamp(data.heat, HEAT_MIN, HEAT_MAX) : 0;
        state.stats = sanitizeStats(data.stats);
        ensureDefaultStats();
        state.inventory = sanitizeInventory(data.inventory);
        try{ const _hood=(state.inventory||[]).find(x=>x.id==='itm-hoodie'); if(_hood && typeof _hood.invCapAdd!=='number'){ _hood.invCapAdd=2; } }catch(e){}; state.log = sanitizeLogEntries(data.log);
        state.equipment = sanitizeEquipment(data.equipment);
        state.profile = sanitizeProfile(data.profile);
        state.vitals = sanitizeVitals(data.vitals);
        state.metrics = sanitizeMetrics(data.metrics);
        state.history = sanitizeHistory(data.history);
        state.lifetime = sanitizeLifetime(data.lifetime);
        state.recruitment = sanitizeRecruitment(data.recruitment);
        
        // Migration: mark seededOnce for existing saves so we don't re-seed on HQ-less refresh
        try{ if(!state.lifetime.seededOnce){ state.lifetime.seededOnce = true; scheduleSave(); } }catch(e){}        
state.time = sanitizeTime(data.time);
        state.properties = sanitizeProperties(data.properties);
        state.storage = sanitizeStorage(data.storage);
        state.hq = sanitizeHQ(data.hq);
        // Territory (persisted)
        try{
          state.territory = sanitizeTerritory(data.territory);
        }catch(e){
          if(!state.territory){
            state.territory = { tier:1, wave:1, active:false, enemy:null, lootQueue: [] };
          }
        }

        
        // Load persisted mail (read status, selection, CRT)
        state.mail = (typeof window.sanitizeMail === 'function'
  ? window.sanitizeMail(data.mail)
  : (data.mail && typeof data.mail==='object' ? data.mail : { inbox: [], unread: 0, nextId: 1, seededWelcome: false, crt: false }));
try{ if(typeof window.ensureMailState==='function') window.ensureMailState(); }catch(e){}
if(!hasSeededOnce() && !state.inventory.length && getHQStore().length===0){ seedFakeItems(); }
        reconcileEquipment();
        // Reconcile HQ from holdings if missing
        try{
          if(!state.hq || !state.hq.propertyId){
            const mark = (state.properties?.holdings||[]).find(x=>x.isHQ);
            if(mark){ state.hq = { propertyId: mark.id }; }
          }
        }catch(e){
        // Migrate legacy global storage (state.storage.items) into current HQ property's storeItems
        try{
          const legacy = (state.storage?.items)||[];
          if(legacy.length){
            const h = getHQRecord();
            if(h){
              if(!Array.isArray(h.storeItems)) h.storeItems = [];
              for(const it of legacy.slice(0,200)){
                if(it && typeof it==='object'){
                  h.storeItems.push({ id: String(it.id||'').slice(0,80), name: String(it.name||'').slice(0,80), slot: it.slot?String(it.slot):undefined, rarity: it.rarity?String(it.rarity):'common', type: it.type?String(it.type):undefined });
                }
              }
              state.storage = { items: [] };
              try{ addLog('Migrated legacy storage into HQ property.'); }catch(e){}
              try{ scheduleSave(); }catch(e){}
            }
          }
        }catch(e){}}

        try{ renderHeadquarters(); 
      // Recruitment view
      renderRecruitmentView();
      const btnCrew = document.getElementById('btnCrewJobs');
      if(btnCrew && !btnCrew.dataset.bound){
        btnCrew.addEventListener('click', ()=> {
          const p = document.getElementById('hqCrewPanel'); if(p){ p.classList.toggle('hidden'); p.setAttribute('aria-hidden', String(p.classList.contains('hidden'))); }
          renderCrewActionsPanel();
        });
        btnCrew.dataset.bound='1';
      }
}catch(e){}
        pickEndsAt = (typeof data.pickEndsAt === 'number' && data.pickEndsAt > Date.now()) ? data.pickEndsAt : null;
        lastSavedAt = Number.isFinite(data.ts) ? data.ts : null;
        if(lastSavedAt){ try{ applyOfflineCatchup(Date.now() - lastSavedAt); }catch(e){} }
        ensureDailyOffers();
        
  ensureRecruitmentDaily(); // recruitment
processRentDue();
        lastSampleAt = Date.now();
        return true;
      }catch(e){
        console.warn('Load failed', e);
        return false;
      }
    }
    function formatTimeAgo(ts){
      if(!ts) return 'never';
      const s = Math.max(0, Math.floor((Date.now() - ts) / 1000));
      if(s < 60) return s + 's ago';
      const m = Math.floor(s / 60);
      if(m < 60) return m + 'm ago';
      const h = Math.floor(m / 60);
      return h + 'h ago';
    }
    function updateAutoSaveUI(){
      const keyEl = document.getElementById('saveKeyText');
      const lastEl = document.getElementById('lastSaveText');
      if(keyEl) keyEl.textContent = "localStorage['" + SAVE_KEY + "']";
      if(lastEl) lastEl.textContent = formatTimeAgo(lastSavedAt);
    }
    // ==========================================================================

    // --- Config (tweak here) ---
    const COOLDOWN_MS = 5000;           
// Track active petty job
let currentJob = null;
// 5 seconds
    const TICK_MS = 1000;              // game loop tick (ms)
    const GAME_TIME_SCALE = 60;        // 1 real sec = 60 in-game seconds
    const BASE_SUCCESS = 0.50;          // 50%
    const PICK_MIN_CASH = 5;            // ¬£5
    const PICK_MAX_CASH = 20;           
// --- Search Bags (unlocks at Sleight of Hand L1) ---
const SEARCH_BASE_SUCCESS = 0.35;   // Lower base chance than pickpocket
const SEARCH_MIN_CASH = 10;         // ¬£10
const SEARCH_MAX_CASH = 60;         // ¬£60
const SEARCH_UNLOCK_LEVEL = 1;      // Requires Sleight of Hand level 1
// ¬£20
    const MAX_LOG = 8;                  // keep last 8 entries

    // XP & Leveling
    const XP_BASE = 100;                   // XP needed for level 0 -> 1
    const XP_GROWTH = 1.25;                // exponential growth per level
    const SLEIGHT_BONUS_PER_LEVEL = 0.02;  // +2% success per Sleight of Hand level
    const XP_AWARD_SUCCESS = { "Sleight of Hand": 15, "Street Smarts": 8 };
    const XP_AWARD_FAIL    = { "Sleight of Hand": 3 }; // consolation XP for trying

    // HEAT system
    const HEAT_MIN = 0;
    const HEAT_MAX = 100;
    const HEAT_GAIN_SUCCESS = 4;
    const HEAT_GAIN_FAIL = 7;
    const HEAT_PENALTY_PER_HEAT = 0.002;     // -0.2 at 100 heat
    const HEAT_DECAY_INTERVAL_MS = 5000;     // -1 heat every 5s
    let lastHeatDecayAt = Date.now();

    // --- State ---
    const state = {
      money: 0,
      heat: 0,
      stats: {},       // { [name]: { level, xp } }
      inventory: [],
      log: [],
      equipment: { head:null, chest:null, hands:null, legs:null, feet:null, accessory:null },
      profile: { alias: "" },
      vitals: { health: 100, hunger: 100 },
      metrics: {
        money: { earned: 0, spent: 0 },
        heat: { peak: 0, gained: 0, cooled: 0, avg: 0, _samples: 0, _sum: 0 }
      },
      history: { session: [] },
      lifetime: { all: [] },
      recruitment: { daily: { dayKey: '', candidates: [] }, crew: [] },

      time: { gameMs: 0, startedAt: Date.now(), epochMs: (function(){ const n=Date.now(); const DAY=24*60*60*1000; return n - (n % DAY); })() },
      properties: { holdings: [], daily:{ dayKey:'', offers: [] } },
      hq: { propertyId: null },
      storage: { items: [] }
    };
    let pickEndsAt = null; // timestamp or null

    // --- Utilities ---
    const qs = (sel, root=document) => root.querySelector(sel);
    const qsa = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));

    function changeMoney(delta, reason='misc'){
      const before = state.money;
      const next = Math.max(0, Math.floor(before + delta));
      const applied = next - before; // in case floor clamps
      state.money = next;
      if(applied >= 0){ state.metrics.money.earned += applied; }
      else{ state.metrics.money.spent += -applied; }
      scheduleSave(); try{ saveGame({silent:true}); }catch(e){}
    }
    function randInt(min, max){
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function addLog(message){
      // Delegate to pushLog so we always get consistent objects ({html}|{text})
      pushLog(message);
    }

    // Rich log helper: store safe HTML fragments we generate (not user input)
    
    // Format ISO timestamp as local HH:MM
    function fmtTime(ts){
      try{ return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
      catch(e){ return '--:--'; }
    }
function pushLog(entry){
      const ts = new Date().toISOString();
      let item;
      if (entry && typeof entry === 'object' && (('html' in entry) || ('text' in entry))) {
        item = Object.assign({ ts }, entry);
      } else if (typeof entry === 'string') {
        if (/<\/?[a-z][\s\S]*>/i.test(entry)) {
          const safe = entry.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
          item = { ts, html: safe };
        } else {
          item = { ts, text: entry };
        }
      } else {
        item = { ts, text: String(entry ?? '') };
      }
      state.log.unshift(item);
      if (state.log.length > MAX_LOG) state.log.pop();
      scheduleSave();
    }

// Hook: drive the canvas from Activity Log entries (fallback)
if(!window.__slotLogHooked){
  window.__slotLogHooked = true;
  (function(){
    const _origPushLog = pushLog;
    window.pushLog = function(entry){
      const ret = _origPushLog(entry);
      try{
        let raw = (typeof entry==='string') ? entry : (entry && (entry.html||entry.text) || '');
        // Strip tags to handle HTML log variants
        raw = String(raw).replace(/<[^>]+>/g,'');
        const m = raw.match(/Fruit machine\s+([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])\s+([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])\s+([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])/i);
        if(m && window.slot && typeof window.slot.visualSpin === 'function'){
          const toSeven = {'7':'7Ô∏è‚É£'};
          const trip = [m[1],m[2],m[3]].map(ch=> toSeven[ch] || ch);
          window.slot.visualSpin(trip);
        }
      }catch(e){}
      return ret;
    };
  })();
}


    function spanXP(amount, stat){
      const s = escapeHtml(stat);
      return `<span class="logpiece txp">+${amount} XP ${s}</span>`;
    }
    function spanMoney(amount){
      return `<span class="logpiece tmoney">+¬£${amount}</span>`;
    }
    function spanBad(text){
      return `<span class="logpiece tbad">${escapeHtml(text)}</span>`;
    }
    function escapeHtml(str){
      return String(str).replace(/[&<>'"]/g, (c)=>({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        "'": '&#39;',
        '"': '&quot;'
      }[c]));
    }
    function slug(name){
      return String(name).toLowerCase().replace(/[^a-z0-9\s-]/g,"").trim().replace(/\s+/g,"-").replace(/-+/g,"-");
    }

    
    // === Rarity helpers for Activity Log ===
    function rarityFrom(it){
      if(!it) return 'common';
      if (it.rarity) return String(it.rarity).toLowerCase();
      const tier = typeof it.tier === 'number' ? it.tier : 0;
      if (tier >= 2) return 'rare';
      if (tier >= 1) return 'uncommon';
      return 'common';
    }
    function rarityColor(r){
      const key = String(r||'common').toLowerCase();
      if(key === 'uncommon') return '#34d399'; // green
      if(key === 'rare') return '#60a5fa'; // blue
      return '#9ca3af'; // grey
    }
    function spanItemName(name, rarity){
      const color = rarityColor(rarity);
      return `<span class="logpiece" style="color:${color}">${escapeHtml(name)}</span>`;
    }
    function spanItem(it){
      if(!it) return `<span class="logpiece">${escapeHtml('item')}</span>`;
      const rar = rarityFrom(it);
      return spanItemName(it.name || 'item', rar);
    }

    // === History / Chart =====================================================
    const SAMPLE_EVERY_MS = 1000;      // 1s
    const MAX_SESSION_SAMPLES = 7200;  // last 2 hours at 1s
    const MAX_ALL_SAMPLES = 28800;     // ~8 hours total cap

    let lastSampleAt = 0;
    let chartRange = 300000; // default 5m in ms; can be "session" or "all"
    let chartNeedsDraw = true;

    function pushSample(){
      const now = Date.now();
            if(typeof window.__prevSpentTotal !== "number"){ window.__prevSpentTotal = (state.metrics?.money?.spent|0) || 0; }
      const totalSpent = (state.metrics?.money?.spent|0) || 0;
      const sampleSpent = Math.max(0, totalSpent - window.__prevSpentTotal)|0;
      window.__prevSpentTotal = totalSpent;
state.history.session.push({ t: now, heat: state.heat|0, money: state.money|0, spent: sampleSpent });
      if(state.history.session.length > MAX_SESSION_SAMPLES) state.history.session.shift();

      state.lifetime.all.push({ t: now, heat: state.heat|0, money: state.money|0, spent: sampleSpent });
      if(state.lifetime.all.length > MAX_ALL_SAMPLES) state.lifetime.all.shift();

      // Throttled autosave so history survives refresh even without actions
      if(!window.__lastHistorySaveAt || (now - window.__lastHistorySaveAt) >= 15000){
        window.__lastHistorySaveAt = now;
        scheduleSave();
      }
    }

    function sanitizeSamples(list){
      const out = [];
      if(!Array.isArray(list)) return out;
      for(const s of list){
        if(s && typeof s === 'object' && Number.isFinite(s.t) && Number.isFinite(s.heat) && Number.isFinite(s.money)){
          out.push({ t: s.t|0, heat: s.heat|0, money: s.money|0, spent: (Number(s.spent)||0)|0 });
        }
        if(out.length >= MAX_ALL_SAMPLES) break;
      }
      return out;
    }

    function getSamplesForRange(){
      const now = Date.now();
      if(chartRange === 'all') return state.lifetime.all.slice();
      if(chartRange === 'session') return state.history.session.slice();
      const ms = Number(chartRange) || 300000;
      const start = now - ms;
      // Prefer lifetime for coverage; fallback to session
      const base = state.lifetime.all.length ? state.lifetime.all : state.history.session;
      const sliced = base.filter(s => s.t >= start);
      if(sliced.length > 1) return sliced;
      // If empty due to time gaps, show last N points
      const N = Math.min(120, base.length);
      return base.slice(Math.max(0, base.length - N));
    }

    function mapY(value, minY, maxY, h, pad=8){
      if(maxY === minY) return h/2;
      const pct = (value - minY) / (maxY - minY);
      return Math.round((1 - pct) * (h - pad*2) + pad);
    }

    // Back-compat wrapper called from tick(); simply renders the analytics chart
    function drawLiveChart(){ try{ drawChart(); }catch(e){} }

    function drawChart(){
      const c = document.getElementById('analyticsChart');
      if(!c) return;
      const ctx = c.getContext('2d');
      const w = c.width = c.clientWidth || c.width;
      const h = c.height = 220;

      const series = getSamplesForRange();
      const count = series.length;
      // gather Y bounds from both lines, with padding
      let minY = Infinity, maxY = -Infinity;
      for(const s of series){
        if(s.money < minY) minY = s.money;
        if(s.money > maxY) maxY = s.money;
        if(s.heat  < minY) minY = s.heat;
        if(s.heat  > maxY) maxY = s.heat;
        if((s.spent||0) < minY) minY = (s.spent||0);
        if((s.spent||0) > maxY) maxY = (s.spent||0);
      }
      if(!Number.isFinite(minY) || !Number.isFinite(maxY)){
        minY = 0; maxY = 1;
      }
      if(minY === maxY){ maxY = minY + 1; }
      // clear
      ctx.clearRect(0,0,w,h);
      // grid
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted-2') || '#334155';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let i=0;i<=4;i++){
        const y = Math.round((h-16) * (i/4) + 8);
        ctx.moveTo(0,y); ctx.lineTo(w,y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;

      // X scaling
      if(count < 2) return;
      const t0 = series[0].t;
      const tN = series[count-1].t;
      const span = Math.max(1, tN - t0);
      const xFor = (t)=> Math.round(((t - t0) / span) * (w - 10) + 5);

      const style = getComputedStyle(document.documentElement);
      const colSpent = style.getPropertyValue('--danger') || '#ef4444';
      const colMoney = style.getPropertyValue('--good') || '#22c55e';
      const colHeat  = style.getPropertyValue('--accent-warm') || '#f59e0b';

      // draw line helper
      function drawLine(getY, color){
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = color.trim();
        for(let i=0;i<count;i++){
          const s = series[i];
          const x = xFor(s.t);
          const y = getY(s);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }

      drawLine(s => mapY(s.money, minY, maxY, h), colMoney);
      drawLine(s => mapY(s.heat,  minY, maxY, h), colHeat);
      drawLine(s => mapY((s.spent||0),  minY, maxY, h), colSpent);

      // Debug labels
      const dbgCt = document.getElementById('dbgSampleCt'); if(dbgCt) dbgCt.textContent = String(count);
      const dbgYMin = document.getElementById('dbgYMin'); if(dbgYMin) dbgYMin.textContent = String(minY);
      const dbgYMax = document.getElementById('dbgYMax'); if(dbgYMax) dbgYMax.textContent = String(maxY);
    }
    // =========================================================================
    
    
    

    // Stats helpers
    function ensureStat(name){
      if(!state.stats[name]) state.stats[name] = { level: 0, xp: 0 };
      return state.stats[name];
    }
    function xpToNext(level){
      return Math.floor(XP_BASE * Math.pow(XP_GROWTH, level));
    }
    function emitStatChange(name, leveled){
      const s = state.stats[name];
      if(!s) return;
      window.dispatchEvent(new CustomEvent('statchange', {
        detail: { name, stat: { level: s.level, xp: s.xp }, leveled: !!leveled }
      }));
      scheduleSave(); // autosave on stat change
    }
    function awardXP(name, amount){
      const s = ensureStat(name);
      s.xp += amount;
      let leveled = false;
      let needed = xpToNext(s.level);
      while(s.xp >= needed){
        s.xp -= needed;
        s.level++;
        leveled = true;
        addLog(`${name} leveled up! Now L${s.level}.`);
        needed = xpToNext(s.level);
      }
      emitStatChange(name, leveled);
      return leveled;
    }
    function getLevel(name){
      return (state.stats[name]?.level) || 0;
    }

    // Inventory helpers =======================================================
    const VALID_SLOTS = ['head','chest','hands','legs','feet','accessory'];
    const VALID_RARITY = ['common','uncommon','rare'];

      // === Inventory capacity (base 6, expandable by equipped items) ===
      function BASE_INV_CAPACITY(){ return 6; } // use function for hoisting friendliness

      
    // (removed duplicate getEquippedItems; using original)


      function getInventoryCapacity(){
        // Base capacity + any equipped item modifiers
        let cap = BASE_INV_CAPACITY();
        try{
          const equipped = getEquippedItems();
          for(const it of equipped){
            if(!it) continue;
            // Simple numeric property support
            if(typeof it.invCapAdd === 'number'){ cap += Math.max(0, it.invCapAdd|0); }
            // Mods array support: { kind:'invCapAdd', value:number }
            if(Array.isArray(it.mods)){
              for(const m of it.mods){
                if(m && (m.kind === 'invCapAdd' || m.type === 'invCapAdd')){
                  const v = Number(m.value||m.amount||0);
                  if(!isNaN(v)) cap += Math.max(0, v|0);
                }
              }
            }
          }
        }catch(e){}
        return Math.max(1, cap|0);
      }

      function inventoryUsed(){
        try{ return (state.inventory && state.inventory.length) ? state.inventory.length|0 : 0; }catch(e){ return 0; }
      }

      function hasInventorySpace(extraSlots){
        const need = Math.max(1, Number(extraSlots)||1);
        return (inventoryUsed() + need) <= getInventoryCapacity();
      }
    function sanitizeInventory(arr){
      const out = [];
      if(!Array.isArray(arr)) return out;
      for(const it of arr.slice(0,50)){
        if(!it || typeof it !== 'object') continue;
        let id = String(it.id || '').slice(0, 40);
        let name = String(it.name || '').slice(0, 60);
        const type = (it.type === 'consumable') ? 'consumable' : null;
        if(type === 'consumable'){
          const qty = Math.max(0, Math.min(99, Number(it.qty)||0));
          const eff = it.effect && typeof it.effect === 'object' ? { target: (it.effect.target==='hunger'?'hunger':'health'), pct: Math.max(0, Math.min(100, Number(it.effect.pct)||0)) } : null;
          if(id && name && eff){ out.push({ id, name, type, qty: qty||1, effect: eff, rarity:'common' }); }
          continue;
        }
        let slot = VALID_SLOTS.includes(it.slot) ? it.slot : null;
        let rarity = VALID_RARITY.includes(it.rarity) ? it.rarity : 'common';
        let equipped = !!it.equipped;
        if(id && name && slot){
          const invCapAdd = (typeof it.invCapAdd === 'number') ? it.invCapAdd|0 : undefined;
          const mods = Array.isArray(it.mods) ? it.mods.slice(0,10) : undefined;
          const obj = { id, name, slot, rarity, equipped };
          if(typeof invCapAdd === 'number') obj.invCapAdd = invCapAdd;
          if(mods) obj.mods = mods;
          out.push(obj);
        }
      }
      return out;
    }
    function hasSeededOnce(){ try{ return !!(state.lifetime && state.lifetime.seededOnce); }catch(e){ return false; } }

function seedFakeItems(){
      if(Array.isArray(state.inventory) && state.inventory.length) return;
      state.inventory = [
        { id:'itm-beanie',   name:'Worn Beanie',        slot:'head',      rarity:'common',   equipped:false },
        { id:'itm-hoodie',   name:'Threadbare Hoodie',  slot:'chest',     rarity:'common',   invCapAdd: 2, equipped:false },{ id:'itm-gloves',   name:'Work Gloves',        slot:'hands',     rarity:'common',   equipped:false },
        { id:'itm-trousers', name:'Cargo Trousers',     slot:'legs',      rarity:'common',   equipped:false },
        { id:'itm-trainers', name:'Old Trainers',       slot:'feet',      rarity:'common',   equipped:false },
        { id:'itm-charm',    name:'Lucky Charm',        slot:'accessory', rarity:'uncommon', equipped:false }
      ];
    
      state.lifetime = state.lifetime || {}; state.lifetime.seededOnce = true;
    }
    function getEquippedId(slot){
      const v = state.equipment[slot];
      if(!v) return null;
      return String(v);
    }
    function itemById(id){
      return (state.inventory || []).find(i => i.id === id);
    }
    function reconcileEquipment(){
      // If equipment points to non-existent items, clear it.
      for(const s of VALID_SLOTS){
        const id = getEquippedId(s);
        if(!id || !itemById(id)){
          state.equipment[s] = null;
        }
      }
      // If any items marked equipped but slot not set, set them.
      for(const it of state.inventory){
        if(it.equipped){
          const cur = getEquippedId(it.slot);
          if(!cur){ state.equipment[it.slot] = it.id; }
          else if(cur !== it.id){ it.equipped = false; }
        }
      }
    }
    function equipItem(itemId){
      const it = itemById(itemId);
      if(!it) return;
      const slot = it.slot;
      const prev = getEquippedId(slot);
      if(prev){
        const old = itemById(prev);
        if(old) old.equipped = false;
      }
      state.equipment[slot] = it.id;
      it.equipped = true;
      pushLog(`Equipped ${spanItem(it)} ‚Üí ${slot}`);
      scheduleSave();
      updateUI();
    }
    function unequipSlot(slot){
      const prev = getEquippedId(slot);
      if(!prev) return;
      const it = itemById(prev);
      const _logFrag = it ? spanItem(it) : 'item';
      if(it) it.equipped = false;
      state.equipment[slot] = null;
      pushLog(`Unequipped ${_logFrag} from ${slot}`);
      scheduleSave();
      updateUI();
    }
    
    // Helper: summarize item mods into a short human-readable buff line
    function getItemBuffLine(it){
      try{
        const mods = Array.isArray(it && it.mods) ? it.mods : [];
        const parts = [];
        for(const m of mods){
          if(!m || typeof m!=='object') continue;
          const v = Number(m.value)||0;
          if(m.kind === 'strAdd'){ parts.push(`+${v} Strength`); }
          else if(m.kind === 'toughAdd'){ parts.push(`+${v} Toughness`); }
          else if(m.kind === 'moneyMult'){ parts.push(`${v>0?'+':''}${Math.round(v*100)}% Money`); }
          else if(m.kind === 'heatGainMult'){ parts.push(`${v>0?'+':''}${Math.round(v*100)}% Heat Gain`); }
          else if(m.kind === 'heatDecayMult'){ parts.push(`${v>0?'+':''}${Math.round(v*100)}% Heat Decay`); }
          else if(m.kind === 'successAdd' && m.action){ parts.push(`${v>0?'+':''}${Math.round(v*100)}% ${String(m.action)} success`); }
        }
        return parts.length ? `Provides ${parts.join(', ')}.` : '';
      }catch(e){ return ''; }
    }

    function renderInventoryGrid(){
      const grid = document.getElementById('invGrid');
      const empty = document.getElementById('invEmpty');
      if(!grid || !empty) return;
      const items = state.inventory || [];
      // Update inventory space text
      try{
        const usedEl = document.getElementById('invUsed');
        if(usedEl) usedEl.textContent = String(inventoryUsed());
        const capEl = document.getElementById('invCap');
        if(capEl) capEl.textContent = String(getInventoryCapacity());
      }catch(e){}
      if(items.length === 0){
        empty.classList.remove('hidden');
        grid.classList.add('hidden');
        grid.innerHTML = '';
        return;
      }
      empty.classList.add('hidden');
      grid.classList.remove('hidden');
      grid.innerHTML = items.map(it => {
        const isEquip = it.slot && !it.type;
        const isCons = it.type === 'consumable';
        const eq = isEquip && (getEquippedId(it.slot) === it.id);
        const rightTag = isCons ? `<span class="tag">x${it.qty||1}</span>` : `<span class="tag rarity-${escapeHtml(it.rarity)}">${escapeHtml(it.rarity||'')}</span>`;
        const subTag  = isCons ? `<span class="tag">Use: ${escapeHtml((it.effect?.target||'')+ ' +' + (it.effect?.pct||0) + '%')}</span>` : `<span class="tag slot">Slot: ${escapeHtml(it.slot||'')}</span>`;
        const btns = isCons
          ? `<button class="btn sm" data-use="${it.id}">Use</button>`
          : (eq ? `<button class="btn sm secondary" data-unequip="${it.slot}">Unequip</button>` : `<button class="btn sm" data-equip="${it.id}">Equip</button>`);
                const descHtml = (function(){
          // Base flavor for known items
          let base = (function(){
            switch(it.id){
              case 'itm-beanie':   return 'Keeps your head just warm enough.';
              case 'itm-hoodie':   return 'Roomy and familiar. Grants +2 inventory space.';
              case 'itm-gloves':   return 'Scuffed work gloves‚Äîbetter grip; fewer splinters.';
              case 'itm-trousers': return 'Beat-up cargos with too many pockets.';
              case 'itm-trainers': return 'Old but comfy. Better than barefoot.';
              case 'itm-charm':    return 'A trinket said to tilt the odds in your favour.';
              default: return '';
            }
          })();
          const buffLine = typeof getItemBuffLine==='function' ? getItemBuffLine(it) : '';
          const full = [base, buffLine].filter(Boolean).join(' ');
          return full ? `<div class="desc">${escapeHtml(full)}</div>` : '';
        })();
return `
          <div class="inv-item ${eq ? 'equipped':''}" data-id="${escapeHtml(it.id)}">
            <div class="top"><div class="name">${escapeHtml(it.name)}</div>
              ${rightTag}
            </div>
                        ${descHtml}
            <div class="row" style="gap:6px">${subTag}</div>

            <div class="actions">${btns}</div>
          </div>`;
      }).join('');
      // Wire buttons
      grid.querySelectorAll('[data-equip]').forEach(btn => { btn.addEventListener('click', () => equipItem(btn.getAttribute('data-equip'))); });
      grid.querySelectorAll('[data-unequip]').forEach(btn => { btn.addEventListener('click', () => unequipSlot(btn.getAttribute('data-unequip'))); });
      grid.querySelectorAll('[data-use]').forEach(btn => { btn.addEventListener('click', () => useConsumable(btn.getAttribute('data-use'))); });
      enhanceInventoryWithStoreButtons();
    }

    
    // Add contextual "Store" buttons to inventory cards when HQ has capacity
    function enhanceInventoryWithStoreButtons(){
      try{
        const grid = document.getElementById('invGrid'); if(!grid) return;
        const h = getHQRecord();
        if(!h) return; // no HQ, no store buttons
        const cap = getHQCapacity();
        const used = storageUsed();
        const full = used >= cap;
        grid.querySelectorAll('.inv-item').forEach(el => {
          if(el.classList.contains('equipped')) return; // don't allow storing equipped items
          const id = el.getAttribute('data-id');
          if(!id) return;
          const actions = el.querySelector('.actions'); if(!actions) return;
          if(actions.querySelector('[data-store]')) return; // already added
          const btn = document.createElement('button');
          btn.className = 'btn sm';
          btn.textContent = 'Store';
          btn.setAttribute('data-store', id);
          if(full) btn.disabled = true;
          actions.appendChild(btn);
        });
        // Wire listeners
        grid.querySelectorAll('[data-store]').forEach(btn => {
          btn.addEventListener('click', () => moveToStorage(btn.getAttribute('data-store')));
        });
      }catch(e){}
    }

    // Default stats to seed into state so the Stats screen isn't empty.
    const DEFAULT_STATS = [
      "Sleight of Hand",
      "Street Smarts",
      "Awareness",
      "Negotiation",
      "Charm",
      "Leadership",
      "Logistics",
      "Reputation"
    ];
    function ensureDefaultStats(){
      DEFAULT_STATS.forEach(n => ensureStat(n));
    }

    // HEAT helpers
    function addHeat(delta){
      const before = state.heat;
      state.heat = clamp(state.heat + delta, HEAT_MIN, HEAT_MAX);
      const change = state.heat - before;
      if(change !== 0){
        if(change > 0){ state.metrics.heat.gained += change; } else { state.metrics.heat.cooled += -change; }
        if(state.heat > state.metrics.heat.peak) state.metrics.heat.peak = state.heat;
        addLog(`Heat ${change > 0 ? "+"+change : change} (now ${state.heat})`);
        scheduleSave();
      }
    }
    function decayHeat(){
      const now = Date.now();
      if(state.heat <= HEAT_MIN) { lastHeatDecayAt = now; return; }
      const elapsed = now - lastHeatDecayAt;
      if(elapsed >= HEAT_DECAY_INTERVAL_MS){
        const steps = Math.floor(elapsed / HEAT_DECAY_INTERVAL_MS);
        lastHeatDecayAt += steps * HEAT_DECAY_INTERVAL_MS;
        addHeat(-steps);
      }
    }

    // Success chance depends on Sleight of Hand level and Heat penalty
    function successChance(){
      const base = BASE_SUCCESS;
      const bonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
      const penalty = state.heat * HEAT_PENALTY_PER_HEAT;
      const raw = base + bonus - penalty;
      return clamp(raw, 0.05, 0.90);
    }
    function isCooling(){ return !!(pickEndsAt && Date.now() < pickEndsAt); }
    function timeLeft(){ return Math.max(0, (pickEndsAt || 0) - Date.now()); }

    // Keep chance debug text in sync for both actions
    function updateChanceDebug(){
      // Pickpocket
      try{
        const ch = successChance();
        const base = BASE_SUCCESS;
        const bonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
        const penalty = state.heat * HEAT_PENALTY_PER_HEAT;
        const detEl = document.getElementById("chanceDetail");
        if(detEl){ detEl.textContent = `base ${Math.round(base*100)}% + sleight ${Math.round(bonus*100)}% ‚àí heat ${Math.round(penalty*100)}% (clamped 5‚Äì90%)`; }
        const cv = document.getElementById("chanceValue");
        if(cv){ cv.textContent = Math.round(ch * 100); }
      }catch(e){}
      // Search Bags
      try{
        const sch = successChanceSearch();
        const sDet = document.getElementById("searchChanceDetail");
        if(sDet){
          const sBase = SEARCH_BASE_SUCCESS;
          const sBonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
          const sPenalty = state.heat * HEAT_PENALTY_PER_HEAT;
          sDet.textContent = `base ${Math.round(sBase*100)}% + sleight ${Math.round(sBonus*100)}% ‚àí heat ${Math.round(sPenalty*100)}% (clamped 5‚Äì90%)`;
        }
        const sVal = document.getElementById("searchChanceValue");
        if(sVal){ sVal.textContent = Math.round(sch * 100); }
      }catch(e){}
    }

    function syncActionButtons(){
      const pickBtn = document.getElementById("pickBtn");
      const searchBtn = document.getElementById("searchBtn");
      const searchLockedNote = document.getElementById("searchLockedNote");
      const unlocked = typeof canUseSearchBags === 'function' ? canUseSearchBags() : true;
      const cooling = isCooling();
      if (pickBtn){
        pickBtn.disabled = cooling;
        pickBtn.textContent = cooling ? `Cooling‚Ä¶ ${Math.ceil(timeLeft()/1000)}s` : "Attempt Pickpocket";
      }
      if (searchBtn){
        searchBtn.disabled = cooling || !unlocked;
      }
      if (searchLockedNote){
        searchLockedNote.style.display = unlocked ? 'none' : 'inline';
      }
    }

    // --- Core action ---
function doPickpocket(){
  if(isCooling()) return;
  currentJob = 'pick';
  pickEndsAt = Date.now() + COOLDOWN_MS;

  const roll = Math.random();
  if(roll < successChance()){
    const cash = randInt(PICK_MIN_CASH, PICK_MAX_CASH);
    changeMoney(cash, 'pickpocket');
    Object.entries(XP_AWARD_SUCCESS).forEach(([name, amt]) => awardXP(name, amt));
    addHeat(HEAT_GAIN_SUCCESS);
    pushLog(`Success: you lifted ${spanMoney(cash)}. (${spanXP(XP_AWARD_SUCCESS["Sleight of Hand"], "Sleight of Hand")}, ${spanXP(XP_AWARD_SUCCESS["Street Smarts"], "Street Smarts")})`);
  }else{
    Object.entries(XP_AWARD_FAIL).forEach(([name, amt]) => awardXP(name, amt));
    addHeat(HEAT_GAIN_FAIL);
    pushLog(`${spanBad('Failed attempt')}: no gain. (${spanXP(XP_AWARD_FAIL["Sleight of Hand"], "Sleight of Hand")}, Heat +${HEAT_GAIN_FAIL})`);
  }
  scheduleSave();
  updateUI();
}

// --- New Action: Search Bags ---

function successChanceSearch(){
  const base = SEARCH_BASE_SUCCESS;
  const bonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
  const penalty = state.heat * HEAT_PENALTY_PER_HEAT;
  return clamp(base + bonus - penalty, 0.05, 0.90);
}
function canUseSearchBags(){
  return getLevel("Sleight of Hand") >= SEARCH_UNLOCK_LEVEL;
}
function doSearchBags(){
  if(isCooling()) return;
  if(!canUseSearchBags()) return;
  currentJob = 'search';
  pickEndsAt = Date.now() + COOLDOWN_MS;

  const roll = Math.random();
  if(roll < successChanceSearch()){
    const cash = randInt(SEARCH_MIN_CASH, SEARCH_MAX_CASH);
    changeMoney(cash, 'searchbags');
    Object.entries(XP_AWARD_SUCCESS).forEach(([name, amt]) => awardXP(name, amt));
    addHeat(HEAT_GAIN_SUCCESS);
    pushLog(`Success: you searched a bag and found ${spanMoney(cash)}. (${spanXP(XP_AWARD_SUCCESS["Sleight of Hand"], "Sleight of Hand")}, ${spanXP(XP_AWARD_SUCCESS["Street Smarts"], "Street Smarts")})`);
  }
else{
        Object.entries(XP_AWARD_FAIL).forEach(([name, amt]) => awardXP(name, amt));
        addHeat(HEAT_GAIN_FAIL);
        pushLog(`${spanBad('Failed attempt')}: no gain. (${spanXP(XP_AWARD_FAIL["Sleight of Hand"], "Sleight of Hand")}, Heat +${HEAT_GAIN_FAIL})`);
      }
      scheduleSave();
      updateUI();
    }

    // --- UI update ---
    function renderStatRow(name, s){
      const needed = xpToNext(s.level);
      const pct = needed > 0 ? Math.min(1, s.xp / needed) : 1;
      const id = slug(name);
      // Show gear contribution for Strength/Toughness
      const buffs = getEquippedBuffTotals();
      const gearAdd = name === 'Strength' ? (buffs.strAdd||0) : (name === 'Toughness' ? (buffs.toughAdd||0) : 0);
      const gearFrag = gearAdd ? ` <span class="pill sm">+${gearAdd} gear</span>` : '';
      return `
        <div class="statrow" id="stat-${id}" data-stat-name="${escapeHtml(name)}" data-level="${s.level}" data-xp="${s.xp}">
          <div class="statheader">
            <div class="statname">${escapeHtml(name)}</div>
            <div class="small muted">L<span id="stat-${id}-level">${s.level}</span>${gearFrag} ‚Ä¢ <span id="stat-${id}-pct">${Math.round(pct*100)}%</span> (<span id="stat-${id}-xp">${s.xp}</span>/<span id="stat-${id}-need">${needed}</span> XP)</div>
          </div>
          <div class="progress" aria-label="${escapeHtml(name)} XP progress">
            <div class="bar" id="stat-${id}-bar" style="width:${(pct*100).toFixed(2)}%"></div>
          </div>
          <div class="small codepath debug-block">
            Source: <strong>state.stats['${escapeHtml(name)}']</strong>, xp=<span id="stat-${id}-xp-inline">${s.xp}</span>, toNext=<span id="stat-${id}-need-inline">${needed}</span>
          </div>
        </div>
      `;
    }

    function applyDebugUI(){
      const debug = localStorage.getItem(DEBUG_KEY) === '1';
      document.body.classList.toggle('debug', debug);
      const btn = document.getElementById('debugBtn');
      if(btn){ btn.textContent = 'Debug: ' + (debug ? 'On' : 'Off'); }
      updateAutoSaveUI();
      // Analytics render
      const m = state.metrics;
      const eEl = document.getElementById("metricEarned");
      if(eEl){
        const earned = m.money.earned|0, spent = m.money.spent|0, net = Math.max(0, earned - spent);
        eEl.textContent = "¬£" + earned;
        const sEl = document.getElementById("metricSpent"); if(sEl) sEl.textContent = "¬£" + spent;
      // Refresh debug chance lines on toggle
      try{ updateChanceDebug(); }catch(e){}
        const nEl = document.getElementById("metricNet"); if(nEl){ nEl.textContent = "¬£" + net; nEl.style.color = (net >= 0 ? "var(--good)" : "var(--danger)"); }
        const eSrc = document.getElementById("metricEarnedSrc"); if(eSrc) eSrc.textContent = String(earned);
        const sSrc2 = document.getElementById("metricSpentSrc"); if(sSrc2) sSrc2.textContent = String(spent);
        // Heat
        const hc = document.getElementById("metricHeatCurrent"); if(hc) hc.textContent = String(state.heat);
        const hp = document.getElementById("metricHeatPeak"); if(hp) hp.textContent = String(m.heat.peak|0);
        const hg = document.getElementById("metricHeatGained"); if(hg) hg.textContent = String(m.heat.gained|0);
        const hco = document.getElementById("metricHeatCooled"); if(hco) hco.textContent = String(m.heat.cooled|0);
        const ha = document.getElementById("metricHeatAvg"); if(ha) ha.textContent = String(m.heat.avg||0);
        const hSrcP = document.getElementById("metricHeatPeakSrc"); if(hSrcP) hSrcP.textContent = String(m.heat.peak|0);
        const hSrcG = document.getElementById("metricHeatGainedSrc"); if(hSrcG) hSrcG.textContent = String(m.heat.gained|0);
        const hSrcC = document.getElementById("metricHeatCooledSrc"); if(hSrcC) hSrcC.textContent = String(m.heat.cooled|0);
        const hSrcA = document.getElementById("metricHeatAvgSrc"); if(hSrcA) hSrcA.textContent = String(m.heat.avg||0);
        const hb = document.getElementById("metricHeatBar"); if(hb){ hb.style.width = Math.min(100, (state.heat/HEAT_MAX)*100).toFixed(2) + "%"; }
      }

    }

    function toggleDebug(){
      const debug = localStorage.getItem(DEBUG_KEY) === '1';
      localStorage.setItem(DEBUG_KEY, debug ? '0' : '1');
      applyDebugUI();
    }

    function setActiveTab(id){
      // side links
      
      // Category buttons
      const bPetty = document.getElementById("btnCatPetty");
      const bSmall = document.getElementById("btnCatSmall");
      
      
      renderPropertyMarket();
      renderHeadquarters();
      const btnHqRef=document.getElementById('hqRefresh'); if(btnHqRef){ btnHqRef.addEventListener('click', ()=>renderHeadquarters()); }
      const bStore=document.getElementById('btnHQStorage'); if(bStore){ bStore.addEventListener('click', openStorageManager); }
      const bGarage=document.getElementById('btnHQGarage'); if(bGarage){ bGarage.addEventListener('click', ()=> addLog('Garage UI WIP')); }
      const closeS=document.getElementById('closeStorage'); if(closeS){ closeS.addEventListener('click', closeStorageManager); }
      const bRent = document.getElementById('btnPropRent');
      const bBuy  = document.getElementById('btnPropBuy');
      const bHold = document.getElementById('btnPropHoldings');
      if(bRent && !bRent.dataset.bound){ bRent.addEventListener('click', () => setPropertyCategory('rent')); bRent.dataset.bound='1'; }
      if(bBuy  && !bBuy.dataset.bound ){ bBuy .addEventListener('click', () => setPropertyCategory('buy'));  bBuy.dataset.bound='1'; }
      if(bHold && !bHold.dataset.bound){ bHold.addEventListener('click', () => setPropertyCategory('holdings')); bHold.dataset.bound='1'; }
document.querySelectorAll(".sidelink").forEach(link => {
        const active = link.dataset.tab === id;
        link.setAttribute("aria-current", active ? "page" : "");
      });
      const views = ["headquarters", "property", "activities", "recruitment", "stats", "inventory", "upgrades", "shop", "analytics","mail","gambling"]; const catsRow = document.getElementById("activityCats");
      views.forEach(v => {
        const el = document.getElementById("view-" + v);
        const active = (v === id);
        el.classList.toggle("hidden", !active); if(catsRow){ catsRow.classList.toggle("hidden", id !== "activities"); }
        el.setAttribute("aria-hidden", (!active).toString());
      });
      if(id === "analytics"){ const label = document.getElementById("dbgRangeLabel"); if(label){ label.textContent = (chartRange === "all" ? "all" : chartRange === "session" ? "session" : (Math.round((chartRange/60000)) + "m")); } chartNeedsDraw = true; drawChart(); }
      if(id === "shop"){ renderShop(); }
      if(id === "property"){ renderPropertyMarket(); }
      if(id === "headquarters"){ renderHeadquarters(); }
    }

    
    function renderEquipmentUI(){
      const slots = ['head','chest','hands','legs','feet','accessory'];
      slots.forEach(slot => {
        const val = state.equipment[slot];
        const label = document.getElementById(`slot-${slot}-label`);
        const badges = document.querySelectorAll(`.slot[data-slot="${slot}"]`);
        const filled = !!val;
        badges.forEach(b => b.classList.toggle('filled', filled));
        if(label){
          let txt = '(Empty)';
          if(filled){ const it = itemById(String(val)); txt = it ? it.name : String(val); }
          label.textContent = txt;
          label.classList.toggle('muted', !filled);
        }
      });
    }
    
function renderEquipChoices(slot){
  const list = document.getElementById('equipList');
  const none = document.getElementById('equipNone');
  const unequipBtn = document.getElementById('equipUnequipBtn');

  if(!list || !none || !unequipBtn) return;

  const inv = Array.isArray(state.inventory) ? state.inventory : [];
  const items = inv.filter(it => it && it.slot === slot);
  const equippedId = getEquippedId(slot);

  list.innerHTML = items.map(it => {
    const isEquipped = equippedId === it.id;
    const action = isEquipped
      ? `<span class="pill">Equipped</span>`
      : `<button class="btn" data-equip="${escapeHtml(it.id)}">Equip</button>`;
    const rarity = it.rarity ? String(it.rarity) : '';
    const name = it.name ? String(it.name) : `Item ${escapeHtml(it.id)}`;
    return `
      <li class="shop-row" data-id="${escapeHtml(it.id)}">
        <div class="meta">
          <div class="name">${escapeHtml(name)}</div>
          <div class="sub">
            ${rarity ? `<span class="tag rarity-${escapeHtml(rarity)}">${escapeHtml(rarity)}</span>` : ''}
            <span class="tag slot">Slot: ${escapeHtml(slot)}</span>
          </div>
        </div>
        <div class="row" style="gap:8px">${action}</div>
      </li>`;
  }).join('');

  none.textContent = `You don't have any ${slot} items to equip.`;
  none.style.display = items.length ? 'none' : 'block';

  unequipBtn.disabled = !equippedId;

  list.querySelectorAll('[data-equip]').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.getAttribute('data-equip');
      equipItem(id);
      // Close dialog (support browsers without <dialog>)
      const dlg = document.getElementById('equipDialog');
      try{ dlg.close(); }catch(e){ dlg.removeAttribute('open'); }
    }, { once: true });
  });

  unequipBtn.onclick = (e) => {
    e.preventDefault();
    unequipSlot(slot);
    const dlg = document.getElementById('equipDialog');
    try{ dlg.close(); }catch(e){ dlg.removeAttribute('open'); }
  };
}


function openEquipSlot(slot){
  const dlg = document.getElementById('equipDialog');
  if(!dlg) return;
  const nameMap = { head:'Head', chest:'Chest', hands:'Hands', legs:'Legs', feet:'Feet', accessory:'Accessory' };
  document.getElementById('equipSlotName').textContent = nameMap[slot] || slot;
  document.getElementById('equipSlotKey').textContent = slot;

  // Populate choices for this slot
  renderEquipChoices(slot);

  try{ dlg.showModal(); }catch(e){ dlg.setAttribute('open',''); }
}


    
    function setAlias(name){
      const trimmed = String(name || '').trim();
      const safe = trimmed.replace(/[^a-zA-Z0-9 _-]/g, '').slice(1-1, 24); // keep 0..24 safe chars
      state.profile.alias = safe;
      addLog(safe ? `Alias set to: ${safe}` : 'Alias cleared');
      scheduleSave();
      updateUI();
    }
    function openAliasDialog(){
      const dlg = document.getElementById('aliasDialog');
      const input = document.getElementById('aliasInput');
      const err = document.getElementById('aliasError');
      if(!dlg || !input || !err) return;
      input.value = state.profile.alias || '';
      err.style.display = 'none';
      try{ dlg.showModal(); }catch(e){ dlg.setAttribute('open',''); }
    }

    
    // === Buff Totals (derived from equipped items) ===========================
    // Supported mod kinds per item: 
    //  - { kind:'moneyMult', value:+0.05 }
    //  - { kind:'heatGainMult', value:-0.10 }
    //  - { kind:'heatDecayMult', value:+0.15 }
    //  - { kind:'successAdd', action:'pickpocket', value:+0.02 }
    //  - { kind:'statXpMult', stat:'Sleight of Hand', value:+0.10 }
    function getEquippedItems(){
      const slots = ['head','chest','hands','legs','feet','accessory'];
      const out = [];
      for(const s of slots){
        const id = state.equipment[s];
        if(!id) continue;
        const it = itemById(String(id));
        if(it) out.push(it);
      }
      return out;
    }
    function getEquippedBuffTotals(){
      const totals = {
        moneyMult: 0,
        heatGainMult: 0,
        heatDecayMult: 0,
        successAdd: { pickpocket: 0 },
        statXpMult: {},
        strAdd: 0,
        toughAdd: 0
      };
      const items = getEquippedItems();
      for(const it of items){
        const mods = Array.isArray(it.mods) ? it.mods : [];
        for(const m of mods){
          if(!m || typeof m !== 'object') continue;
          const kind = m.kind;
          const val = Number(m.value) || 0;
          if(kind === 'moneyMult'){ totals.moneyMult += val; }
          else if(kind === 'heatGainMult'){ totals.heatGainMult += val; }
          else if(kind === 'heatDecayMult'){ totals.heatDecayMult += val; }
          else if(kind === 'successAdd'){
            const a = m.action || 'pickpocket';
            totals.successAdd[a] = (totals.successAdd[a]||0) + val;
          }
          else if(kind === 'statXpMult' && m.stat){
            const s = String(m.stat);
            totals.statXpMult[s] = (totals.statXpMult[s]||0) + val;
          }
          else if(kind === 'strAdd'){ totals.strAdd += val; }
          else if(kind === 'toughAdd'){ totals.toughAdd += val; }
        }
      }
      return totals;
    }
    
function renderBuffSummary(){
  const el = document.getElementById('buffPills'); if(!el) return;
  const t = getEquippedBuffTotals();
  const pills = [];
  const pct = (x)=> `${x>0?'+':''}${Math.round(x*100)}%`;
  if(t.moneyMult) pills.push(`<span class="pill">Money ${pct(t.moneyMult)}</span>`);
  if(t.heatGainMult) pills.push(`<span class="pill">Heat gain ${pct(t.heatGainMult)}</span>`);
  if(t.heatDecayMult) pills.push(`<span class="pill">Heat decay ${pct(t.heatDecayMult)}</span>`);
  if(t.successAdd && t.successAdd.pickpocket) pills.push(`<span class="pill">Pickpocket success ${pct(t.successAdd.pickpocket)}</span>`);
  // Stat XP multipliers
  if(t.statXpMult){
    for(const [stat,val] of Object.entries(t.statXpMult)){ if(val) pills.push(`<span class="pill">${escapeHtml(stat)} XP ${pct(val)}</span>`); }
  }
  // New: flat stat adds from gear
  if(t.strAdd)   pills.push(`<span class="pill">Strength +${t.strAdd}</span>`);
  if(t.toughAdd) pills.push(`<span class="pill">Toughness +${t.toughAdd}</span>`);
  if(!pills.length) pills.push('<span class="pill muted">No active buffs</span>');
  el.innerHTML = pills.join('');
}

// === Vitals & Shop =======================================================
    const HUNGER_DECAY_PER_SEC = 0.02; // % per second
    function clampPct(x){ const n = Number(x); return Math.max(0, Math.min(100, Number.isFinite(n)? n : 0)); }
    function addHealth(pct){ const before = state.vitals.health; state.vitals.health = clampPct(before + pct); addLog(`Health ${pct>0?'+':''}${pct}% (now ${Number(state.vitals.health).toFixed(0)}%)`); scheduleSave(); }
    function addHunger(pct){ const before = state.vitals.hunger; state.vitals.hunger = clampPct(before + pct); addLog(`Hunger ${pct>0?'+':''}${pct}% (now ${Number(state.vitals.hunger).toFixed(0)}%)`); scheduleSave(); }
    function decayHunger(dtSec){ if(dtSec<=0) return; const delta = HUNGER_DECAY_PER_SEC * dtSec; if(delta>0){ state.vitals.hunger = clampPct(state.vitals.hunger - delta); } }

    const SHOP_ITEMS = {
      food: [
        { id:'food-bread',   name:'Bread Roll',   pct:10, cost:5,  desc:'Restore 10% hunger', target:'hunger' },
        { id:'food-burger',  name:'Burger',       pct:40, cost:10, desc:'Restore 40% hunger', target:'hunger' },
        { id:'food-sand',    name:'Sandwich',     pct:25, cost:15, desc:'Restore 25% hunger', target:'hunger' },
        { id:'food-ramen',   name:'Hot Ramen',    pct:40, cost:30, desc:'Restore 40% hunger', target:'hunger' },
      ],
      med: [
        { id:'med-small',    name:'Small Medkit', pct:20, cost:25, desc:'Restore 20% health', target:'health' },
        { id:'med-large',    name:'Medkit',       pct:50, cost:60, desc:'Restore 50% health', target:'health' },
      ]
    };

    function renderShop(){
      const bal = document.getElementById('shopBalance'); if(bal) bal.textContent = String(state.money|0);
      const food = document.getElementById('shopFood'); const med = document.getElementById('shopMed');
      if(food){ food.innerHTML = SHOP_ITEMS.food.map(it => `<li class="shop-row"><div class="meta"><div class="name">${escapeHtml(it.name)}</div><div class="sub">${escapeHtml(it.desc)}</div></div><div class="row" style="gap:8px"><div class="pill">¬£${it.cost}</div><button class="btn" data-buy="${it.id}">Buy</button></div></li>`).join(''); }
      if(med){  med.innerHTML  = SHOP_ITEMS.med .map(it => `<li class="shop-row"><div class="meta"><div class="name">${escapeHtml(it.name)}</div><div class="sub">${escapeHtml(it.desc)}</div></div><div class="row" style="gap:8px"><div class="pill">¬£${it.cost}</div><button class="btn" data-buy="${it.id}">Buy</button></div></li>`).join(''); }
      document.querySelectorAll('[data-buy]').forEach(btn => btn.addEventListener('click', () => buyShop(btn.getAttribute('data-buy'))));
    }

    function buyShop(id){
      const it = SHOP_ITEMS.food.find(x=>x.id===id) || SHOP_ITEMS.med.find(x=>x.id===id);
      if(!it) return;
      // Capacity check: if this would create a new stack and there's no space, block purchase
      const willStack = !!(state.inventory||[]).find(x => x.type==='consumable' && x.id===it.id);
      if(!willStack && !hasInventorySpace(1)){ addLog('<span class="red">Inventory full</span>: no space for '+escapeHtml(it.name)); return; }
      if((state.money|0) < it.cost){ addLog('<span class="red">Not enough money</span> to buy '+escapeHtml(it.name)); return; }
      changeMoney(-it.cost, 'shop');
      addConsumableToInventory(it);
      pushLog(`<span class="red">-¬£${it.cost}</span> Bought ${spanItem(it)}`);
      renderInventoryGrid(); renderShop(); updateUI();
    }

    function addConsumableToInventory(shopItem){
      // Stack by id if already in inventory (consumable)
      const existing = (state.inventory||[]).find(x => x.type==='consumable' && x.id===shopItem.id);
      if(existing){ existing.qty = Math.min(99, (existing.qty||0)+1); return true; }
      if(!hasInventorySpace(1)){ addLog('<span class="red">Inventory full</span>: no space for '+escapeHtml(shopItem.name)); return false; }
      state.inventory.push({ 
        id: shopItem.id, name: shopItem.name, type:'consumable', qty:1,
        effect:{ target: shopItem.target, pct: shopItem.pct }, rarity:'common'
      });
      return true;
    };
    function dateKeyFromGameTime(){
      const d = new Date((state.time?.epochMs||0) + (state.time?.gameMs||0));
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }

    // ---- Restored helpers ----
function seededShuffle(arr, seed){
      let s = seed >>> 0;
      function rnd(){ s = (1664525 * s + 1013904223) >>> 0; return s / 4294967296; }
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(rnd()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
}
      return a;
    }

function endOfMonthMsFrom(ms){
      const d = new Date((state.time?.epochMs||0) + ms);
      // set to last day of month 23:59
      const y = d.getFullYear();
      const m = d.getMonth();
      const last = new Date(y, m+1, 0, 23, 59, 0, 0);
      return last.getTime() - (state.time?.epochMs||0);
    }

function useConsumable(itemId){
      const it = (state.inventory||[]).find(x => x.type==='consumable' && x.id===itemId);
      if(!it) return;
      const { target, pct } = it.effect || {};
      if(target==='hunger') addHunger(pct||0);
      else if(target==='health') addHealth(pct||0);
      // decrement qty/remove
      it.qty = Math.max(0, (it.qty||1) - 1);
      if(it.qty === 0){
        const idx = state.inventory.indexOf(it);
        if(idx >= 0) state.inventory.splice(idx,1);
      }
      scheduleSave();
      renderInventoryGrid(); updateUI();
    }

function simulateOffline(ms){ applyOfflineCatchup(ms); updateUI(); }

function applyOfflineCatchup(elapsedMs){
      if(!elapsedMs || elapsedMs <= 0) return;
      // advance in-game clock
      advanceGameTime(elapsedMs);
      // heat cool-down in batches (no hunger change)
      if(state.heat > HEAT_MIN){
        const steps = Math.floor(elapsedMs / HEAT_DECAY_INTERVAL_MS);
        if(steps > 0){
          addHeat(-steps);
        }
        // reset heat timer baseline so next decay happens after the remaining remainder
        lastHeatDecayAt = Date.now() - (elapsedMs % HEAT_DECAY_INTERVAL_MS);
      } else {
        lastHeatDecayAt = Date.now();
      }
      addLog(`Offline catch-up: +${formatDuration(elapsedMs)} (clock only), heat adjusted; hunger unchanged.`);
    }
    // Restored RENTAL_POOL
    const RENTAL_POOL = [
      { id:'rm-basement-1', name:'Damp Basement', loc:'South Quarter', storage:20, garage:0, monthly:60,  deposit:30, tier:0 },
      { id:'rm-locker-1',   name:'Storage Locker A12', loc:'Central Depot', storage:10, garage:0, monthly:35,  deposit:20, tier:0 },
      { id:'rm-locker-2',   name:'Storage Locker B7',  loc:'North Depot',   storage:16, garage:0, monthly:48,  deposit:24, tier:0 },
      { id:'rm-bedsit-1',   name:'Tiny Bedsit',       loc:'Old Town',      storage:12, garage:0, monthly:85,  deposit:50, tier:1 },
      { id:'rm-garage-1',   name:'Single Garage',     loc:'Riverside',     storage:8,  garage:1, monthly:120, deposit:80, tier:1 },
      { id:'rm-garage-2',   name:'Lock-up Garage',    loc:'Industrial Park',storage:14,garage:1, monthly:140, deposit:100, tier:1 },
      { id:'rm-shop-1',     name:'Corner Kiosk (Backroom)', loc:'Market Row', storage:25, garage:0, monthly:180, deposit:120, tier:2 },
      { id:'rm-workshop-1', name:'Tiny Workshop',     loc:'Back Alley',     storage:30, garage:0, monthly:220, deposit:160, tier:2 },
      { id:'rm-flat-1',     name:'Studio Flat',       loc:'Harbour',        storage:28, garage:0, monthly:250, deposit:200, tier:2 },
      { id:'rm-warehouse-1',name:'Half Warehouse Bay',loc:'Docks',          storage:60, garage:2, monthly:480, deposit:300, tier:3 },
      { id:'rm-warehouse-2',name:'Small Warehouse Unit',loc:'Ring Road',    storage:80, garage:1, monthly:520, deposit:360, tier:3 },
      { id:'rm-office-1',   name:'Back Office Space', loc:'Arcade',         storage:18, garage:0, monthly:160, deposit:120, tier:2 },
      { id:'rm-lockup-3',   name:'Hidden Lockup',     loc:'Canal Side',     storage:34, garage:0, monthly:260, deposit:180, tier:2 },
      { id:'rm-yard-1',     name:'Yard Shed',         loc:'Scrap Yard',     storage:22, garage:0, monthly:140, deposit:100, tier:1 },
      { id:'rm-shopback-2', name:'Back of Shop (Sublet)', loc:'High Street',storage:20, garage:0, monthly:210, deposit:150, tier:2 }
    ];






    function ensureDailyOffers(){

      if(!state.properties.daily) state.properties.daily = { dayKey:'', offers: [] };
      if(!state.hq || typeof state.hq !== 'object') state.hq = { propertyId: null };
      if(!state.storage || typeof state.storage !== 'object') state.storage = { items: [] };
      const key = dateKeyFromGameTime();
      if((state.properties.daily?.dayKey ?? '') !== key){
        // new day: choose 4-6 offers
        const seed = key.split('-').reduce((acc, s)=> (acc*131 + parseInt(s,10))|0, 7) >>> 0;
        const shuffled = seededShuffle(RENTAL_POOL, seed);
        const count = 4 + Math.floor((seed % 3)); // 4..6
        state.properties.daily.dayKey = key;
        state.properties.daily.offers = shuffled.slice(0, count);
        scheduleSave();
        addLog(`Property Market refreshed (${count} offers).`);
      }
    }
function renderRentOffers(){
      const wrap = document.getElementById('rentOffers'); if(!wrap) return;
      ensureDailyOffers();
      const dayEl = document.getElementById('rentDayKey'); if(dayEl) dayEl.textContent = state.properties.daily.dayKey || '‚Äî';
      const nextEl = document.getElementById('rentNextRefresh'); if(nextEl){
        // compute next midnight
        const d = new Date((state.time?.epochMs||0) + (state.time?.gameMs||0));
        const next = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1, 0, 0, 0, 0);
        nextEl.textContent = next.toDateString();
      }
      const offers = state.properties.daily.offers || [];
      if(offers.length === 0){
        wrap.innerHTML = '<div class="card"><p class="muted">No offers right now. Check back after midnight.</p></div>';
        return;
      }
      const owned = new Set((state.properties.holdings||[]).map(h=>h.id));
      
      wrap.innerHTML = offers.map(it => {
        const rented = owned.has(it.id);
        const tier = typeof it.tier === 'number' ? it.tier : 0;
        return `<div class="prop-card luxe tier-${tier}">
          <div class="prop-hero" aria-hidden="true"></div>
          <div class="prop-head">
            <div class="prop-name">${escapeHtml(it.name)}</div>
            <div class="prop-loc"><span class="ico">üìç</span><span class="muted small">${escapeHtml(it.loc)}</span></div>
          </div>
          <div class="prop-meta fancy">
            <span class="pill"><span class="ico">üì¶</span> <span class="kv"><span class="label">Storage</span><span class="val">${it.storage}</span></span></span>
            <span class="pill"><span class="ico">üöó</span> <span class="kv"><span class="label">Garage</span><span class="val">${it.garage}</span></span></span>
          
          </div>
          <p class="small muted">${escapeHtml(describeProperty(it))}</p>
          <div class="prop-price">
            <div class="price" title="Monthly rent">
              <div class="main">¬£${it.monthly}</div>
              <div class="per">/month</div>
            </div>
            <div class="price" title="Refundable deposit (rules WIP)">
              <div class="main">¬£${it.deposit}</div>
              <div class="per">deposit</div>
            </div>
          </div>
          <div class="prop-actions">
            <button class="btn" ${rented?'disabled':''} data-rent="${it.id}">${rented?'Already Rented':'Rent this'}</button>
          </div>
        </div>`;
      }).join('');


      wrap.querySelectorAll('[data-rent]').forEach(btn => {
        btn.addEventListener('click', () => tryRent(btn.getAttribute('data-rent')));
      });
    }

    function tryRent(id){
      const it = (state.properties?.daily?.offers||[]).find(x=>x.id===id);
      if(!it) return;
      // check already rented
      if((state.properties.holdings||[]).some(h=>h.id===id)){
        addLog('You already rent this property.'); return;
      }
      if(state.money < it.deposit){
        addLog('<span class="red">Not enough money</span> for the deposit.');
        return;
      }
      changeMoney(-it.deposit, 'deposit');
      // first rent due = last day of current month 23:59 (game time)
      const due = endOfMonthMsFrom(state.time.gameMs||0);
      const rec = { id: it.id, name: it.name, loc: it.loc, storage: it.storage, garage: it.garage, monthly: it.monthly, deposit: it.deposit, nextRentDue: due, overdue:false, paid:0 };
      state.properties.holdings = state.properties.holdings || [];
      state.properties.holdings.push(rec);
      addLog(`Rented ${escapeHtml(it.name)} ‚Äî deposit <span class="red">-¬£${it.deposit}</span>, first rent due at month end.`);
      scheduleSave();
      renderHoldings();
      renderRentOffers();
      updateUI();
    }

    function renderHoldings(){
      const list = document.getElementById('holdingsList'); if(!list) return;
      const arr = state.properties?.holdings || [];
      if(arr.length === 0){ list.innerHTML = '<div class="card"><p class="muted">No properties yet.</p></div>'; return; }
      
      list.innerHTML = arr.map(h => {
        const due = new Date((state.time?.epochMs||0) + h.nextRentDue);
        const dueStr = due.toDateString();
        const isHQ = ( (state.hq && state.hq.propertyId === h.id) || h.isHQ );
        const hqTag = isHQ ? `<span class="tag">HQ</span>` : '';
        const hqBtn = isHQ ? `<button class="btn secondary" disabled>Current HQ</button>`
                           : `<button class="btn" data-sethq="${h.id}">Set as HQ</button>`;
        return `<div class="prop-card">
          <div class="prop-head"><div class="prop-name">${escapeHtml(h.name)} ${hqTag}</div><div class="muted small">${escapeHtml(h.loc)}</div></div>
          <div class="prop-meta">
            <span class="pill">Storage: <strong>${h.storage}</strong></span>
            <span class="pill">Garage: <strong>${h.garage}</strong></span>
            <span class="pill">Monthly: <strong>¬£${h.monthly}</strong></span>
            <span class="pill">Next Due: <strong>${escapeHtml(dueStr)}</strong></span>
          </div>
          <div class="prop-actions">
            ${hqBtn}
            <button class="btn secondary" data-end="${h.id}">End Lease (forfeit deposit)</button>
          </div>
        </div>`;
      }).join('');


      list.querySelectorAll('[data-sethq]').forEach(btn => { btn.addEventListener('click', () => setHQ(btn.getAttribute('data-sethq'))); });
      list.querySelectorAll('[data-end]').forEach(btn => {
        btn.addEventListener('click', () => endLease(btn.getAttribute('data-end')));
      });
    }

    function endLease(id){
      const arr = state.properties?.holdings || [];
      const idx = arr.findIndex(h=>h.id===id);
      if(idx<0) return;
      const h = arr[idx];
      arr.splice(idx,1);
      if(state.hq && state.hq.propertyId === id){ state.hq.propertyId = null; }
      try{ if(h) h.isHQ = false; }catch(e){}
      addLog(`Ended lease for ${escapeHtml(h.name)}. Deposit forfeited.`);
      scheduleSave();
      renderHoldings();
      renderRentOffers();
      renderHeadquarters();
      updateUI();
    }

    function setHQ(id){
      const h = (state.properties?.holdings||[]).find(x=>x.id===id);
      if(!h){ addLog('Invalid HQ selection.'); return; }
      state.hq = { propertyId: id };
      try{ (state.properties?.holdings||[]).forEach(hh => hh.isHQ = (hh.id === id)); }catch(e){}
      addLog(`Headquarters set to: ${escapeHtml(h.name)} (${escapeHtml(h.loc)}) <span class=\"small muted debug-block\">(state.hq.propertyId = ${id})</span>`);
      scheduleSave();
      renderHoldings();
      renderHeadquarters();
      updateUI();
      setActiveTab('headquarters');
    }

    function processRentDue(){
      const nowMs = state.time?.gameMs || 0;
      const arr = state.properties?.holdings || [];
      for(const h of arr){
        if(nowMs >= h.nextRentDue){
          if(state.money >= h.monthly){
            changeMoney(-h.monthly, 'rent');
            h.paid = (h.paid||0) + h.monthly;
            addLog(`<span class="red">-¬£${h.monthly}</span> Rent paid for ${escapeHtml(h.name)}.`);
            // schedule next month due
            h.nextRentDue = endOfMonthMsFrom(h.nextRentDue + 24*60*60*1000); // next month end
          } else {
            h.overdue = true;
            addLog(`<span class="red">Rent overdue</span> for ${escapeHtml(h.name)} (need ¬£${h.monthly}).`);
            // still move next due to next month to avoid infinite loop; arrears handling can be added later
            h.nextRentDue = endOfMonthMsFrom(h.nextRentDue + 24*60*60*1000);
          }
          scheduleSave();
        }
      }
    }

    function renderPropertyMarket(){
      renderRentOffers();
      renderHoldings();
    }

    
    
    
    let __hqRecoveredOnce = false;
    function getHQRecord(){
      // 1) If we already have an id, resolve it and return
      let id = state.hq?.propertyId;
      const holdings = (state.properties?.holdings||[]);
      if(id){
        const hold = holdings.find(x=>x.id===id);
        if(hold) return hold;
        try{
          if(state.properties?.daily?.offers){
            const off = state.properties.daily.offers.find(x=>x.id===id);
            if(off) return off;
          }
          if(typeof RENTAL_POOL!=='undefined' && RENTAL_POOL){
            const base = RENTAL_POOL.find(x=>x.id===id);
            if(base) return base;
          }
        }catch(e){}
      }
      // 2) Try to recover from holdings.isHQ or single holding
      const candidate = holdings.find(x=>x.isHQ) || (holdings.length===1 ? holdings[0] : null);
      if(candidate){
        // Set id silently; guard to avoid repeated logs/saves
        state.hq = { propertyId: candidate.id };
        if(!__hqRecoveredOnce){
          __hqRecoveredOnce = true;
          try{ saveGame({silent:true}); }catch(e){}
          try{ addLog(`Recovered HQ: ${escapeHtml(candidate.name)} (${escapeHtml(candidate.loc)})`); }catch(e){}
        }
        return candidate;
      }
      return null;
    }
    
    // Human-friendly blurb for a rental based on attributes
    function describeProperty(p){
      const parts = [];
      const loc = String(p.loc||'').trim();
      if(loc) parts.push(`${loc} area.`);
      // Tier vibe
      const t = Number(p.tier)||0;
      if(t <= 0) parts.push('Basic, no‚Äëfrills.');
      else if(t === 1) parts.push('Modest starter space.');
      else if(t >= 2) parts.push('Better condition; suitable as a main base.');
      // Storage
      const s = Math.max(0, Number(p.storage)||0);
      if(s === 0) parts.push('No on‚Äësite storage.');
      else if(s <= 10) parts.push(`Small on‚Äësite storage (${s} items).`);
      else if(s <= 25) parts.push(`Moderate storage (${s} items).`);
      else parts.push(`Large storage (${s} items).`);
      // Garage
      const g = Math.max(0, Number(p.garage)||0);
      if(g === 1) parts.push('Single‚Äëbay garage.');
      else if(g > 1) parts.push(`${g}-bay garage.`);
      return parts.join(' ');
    }

    
    
    // ===== HQ Storage Manager =====
    function getHQCapacity(){
      const h = getHQRecord();
      return h ? Math.max(0, Number(h.storage)||0) : 0;
    }
    
    // Returns the storage items array for the current HQ property.
    function getHQStore(){
      const h = getHQRecord();
      if(!h) return [];
      if(!Array.isArray(h.storeItems)) h.storeItems = [];
      return h.storeItems;
    }
function storageUsed(){ return getHQStore().length; }
    function openStorageManager(){
      const h = getHQRecord();
      if(!h){ addLog('No HQ selected.'); return; }
      const modal = document.getElementById('storageModal'); if(!modal) return;
      modal.classList.remove('hidden');
      renderStorageManager();
    }
    function closeStorageManager(){
      const modal = document.getElementById('storageModal'); if(!modal) return;
      modal.classList.add('hidden');
    }
    function renderStorageManager(){
      const capEl = document.getElementById('storeCap');
      const usedEl= document.getElementById('storeUsed');
      const freeEl= document.getElementById('storeFree');
      const cap = getHQCapacity();
      const used = storageUsed();
      if(capEl) capEl.textContent = cap;
      if(usedEl) usedEl.textContent = used;
      if(freeEl) freeEl.textContent = Math.max(0, cap - used);
      // Inventory list (items that are NOT equipped and not consumables in-use)
      const inv = (state.inventory||[]).filter(it => !it.equipped);
      const invBox = document.getElementById('invForStore');
      if(invBox){
        invBox.innerHTML = inv.length ? inv.map(it => `
          <div class="inv-item-sm">
            <div class="name">${escapeHtml(it.name)}</div>
            <div class="inv-actions">
              <button class="btn sm" data-tostore="${it.id}">Store</button>
            </div>
          </div>`).join('') : '<p class="small muted">No storable items.</p>';
      }
      const sitems = getHQStore();
      const gridS = document.getElementById('gridStorage');
      if(gridS){
        gridS.innerHTML = sitems.length ? sitems.map(it => `
          <div class="store-item">
            <div class="name">${escapeHtml(it.name)}</div>
            <div class="store-actions">
              <button class="btn sm secondary" data-fromstore="${String(it.id)}" data-name="${escapeHtml(it.name)}">Retrieve</button>
            </div>
          </div>`).join('') : '<p class="small muted">Storage is empty.</p>';
      }
      // Wire moves
      if(invBox){
        invBox.querySelectorAll('[data-tostore]').forEach(btn => {
          btn.addEventListener('click', () => moveToStorage(btn.getAttribute('data-tostore')));
        });
      }
      if(gridS){
        gridS.querySelectorAll('[data-fromstore]').forEach(btn => {
          btn.addEventListener('click', () => { const id = btn.getAttribute('data-fromstore'); moveFromStorage(id); });
        });
      }
    }
    function moveToStorage(id){
  const cap = getHQCapacity();
  if(storageUsed() >= cap){ addLog('<span class="red">HQ storage full</span>.'); return; }
  const inv = state.inventory || [];
  const idx = inv.findIndex(x=>x.id===id);
  if(idx<0){ addLog('Item not found.'); return; }
  const it = inv[idx];
  const store = getHQStore();
  // Handle consumables as single-unit moves
  if(it && it.type === 'consumable'){
    // Move exactly one unit of the stack into storage
    const qty = Math.max(1, Number(it.qty)||1);
    if(qty > 1){
      it.qty = qty - 1;
    }else{
      inv.splice(idx,1);
    }
    // Store a lightweight record; retrieval will reconstruct full effect via SHOP_ITEMS
    store.push({ id: it.id, name: it.name, type: 'consumable' });
    pushLog(`Stored 1√ó ${escapeHtml(it.name)} in HQ.`);
  }else{
    // Equipment/other: move whole item
    inv.splice(idx,1);
    store.push({ id: it.id, name: it.name, slot: it.slot, rarity: it.rarity, type: it.type, invCapAdd: it.invCapAdd, mods: it.mods });
    pushLog(`Stored ${spanItem(it)} in HQ.`);
  }
  scheduleSave();
  renderStorageManager();
  renderInventoryGrid();
  renderHeadquarters();
}
    
    
    function moveFromStorage(id){
  const arr = getHQStore();
  const want = String(id || '').trim();
  let idx = arr.findIndex(x => String(x.id).trim() === want);
  if(idx < 0){
    // Fallback: try by name if unique (helps if ids got sanitized elsewhere)
    const byNameIdx = arr.findIndex(x => String((x.name||'')).trim().toLowerCase() === want.toLowerCase());
    if(byNameIdx >= 0){ idx = byNameIdx; }
  }
  if(idx < 0){
    addLog(`Item not in storage. <span class="small muted debug-block">(id='${escapeHtml(want)}', have=[${arr.map(x=>x.id).join(', ')}])</span>`);
    return;
  }

  const peek = arr[idx];
  // Capacity check BEFORE removing from storage
  // If a consumable will stack, allow even when no free slots (mirrors shop logic)
  let willStack = false;
  if(peek && peek.type === 'consumable'){
    const existing = (state.inventory||[]).find(x => x.type==='consumable' && x.id===peek.id);
    willStack = !!existing;
  }
  if(!willStack && !hasInventorySpace(1)){ addLog('<span class="red">Inventory full</span>.'); return; }

  const [it] = arr.splice(idx,1);

  if(it && it.type === 'consumable'){
    // Rebuild from SHOP_ITEMS by id (or name fallback) and add a single unit
    const shopItem = (SHOP_ITEMS.food.find(x=>x.id===it.id) || SHOP_ITEMS.med.find(x=>x.id===it.id))
                  || (SHOP_ITEMS.food.find(x=>x.name===it.name) || SHOP_ITEMS.med.find(x=>x.name===it.name))
                  || { id: it.id, name: it.name, target: 'hunger', pct: 0 };
    const ok = addConsumableToInventory(shopItem);
    if(!ok){
      // Put it back to storage if something went wrong
      arr.splice(idx, 0, it);
      addLog('<span class="red">Could not retrieve item</span>.');
      return;
    }
    pushLog(`Retrieved 1√ó ${escapeHtml(shopItem.name)} from HQ.`);
  }else{
    state.inventory = state.inventory || [];
    // Keep original id so it remains the same item
    state.inventory.push({ id: it.id, name: it.name, slot: it.slot, rarity: it.rarity, type: it.type, invCapAdd: it.invCapAdd, mods: it.mods });
    pushLog(`Retrieved ${spanItem(it)} from HQ.`);
  }

  scheduleSave();
  renderStorageManager();
  renderInventoryGrid();
  renderHeadquarters();
}

    function renderHeadquarters(){
      const setText=(id,v)=>{const el=document.getElementById(id); if(el) el.textContent=String(v);};
      setText('hqDbgId', state.hq?.propertyId ?? 'null');
      setText('hqDbgHoldN', (state.properties?.holdings||[]).length);
      setText('hqDbgOffN', (state.properties?.daily?.offers||[]).length);
      try{ setText('hqDbgPoolN', (typeof RENTAL_POOL!=='undefined' && RENTAL_POOL && RENTAL_POOL.length)||0); }catch(e){ setText('hqDbgPoolN','0'); }
      const none = document.getElementById('hqNone');
      const det  = document.getElementById('hqDetails');
      if(!none || !det) return;
      const h = getHQRecord();
      const actions = document.getElementById('hqActions');
      const garageBtn = document.getElementById('btnHQGarage');
      const storeBtn = document.getElementById('btnHQStorage');
      if(!h){ none.classList.remove('hidden'); det.classList.add('hidden'); if(actions) actions.classList.add('hidden'); return; }
      if(actions) actions.classList.remove('hidden'); if(garageBtn) garageBtn.disabled = !(Number(h.garage)>0); if(storeBtn) storeBtn.disabled = false;
      none.classList.add('hidden'); det.classList.remove('hidden');
      const set = (id, v) => { const el = document.getElementById(id); if(el) el.textContent = String(v); };
      set('hqName', h.name); set('hqLoc', h.loc);
      set('hqStorage', h.storage); set('hqGarage', h.garage); set('hqMonthly', '¬£'+h.monthly);
      try{ const used = storageUsed(); set('hqStorageUsed', used); set('hqStorageCap', h.storage); }catch(e){}
    }
    function advanceGameTime(dtMs){
      // advance by scaled time
      const advance = Math.max(0, Math.floor(dtMs * GAME_TIME_SCALE));
      state.time.gameMs = Math.max(0, (state.time.gameMs||0) + advance);
    }function formatDuration(ms){
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const h = Math.floor(m/60);
      const mm = m % 60, ss = s % 60;
      if(h > 0) return `${h}h ${mm}m`;
      if(m > 0) return `${m}m ${ss}s`;
      return `${s}s`;
    }




    function formatGameClock(ms){
      const epoch = (state.time && state.time.epochMs) ? state.time.epochMs : 0;
      const DAY = 24*60*60*1000;
      const dayCount = Math.floor(ms / DAY) + 1; // Day 1 starts at 0ms
      const date = new Date(epoch + ms);
      const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const dw = days[date.getDay()];
      const d  = String(date.getDate()).padStart(2,'0');
      const mon= months[date.getMonth()];
      const HH = String(date.getHours()).padStart(2,'0');
      const MM = String(date.getMinutes()).padStart(2,'0');
      return `Day ${dayCount} ¬∑ ${dw} ${d} ${mon} ‚Äî ${HH}:${MM}`;
    }



    
    // === RECRUITMENT SYSTEM ==================================================
    const RECRUIT_FIRST_NAMES = ["Tommy","Riley","Casey","Alex","Morgan","Jordan","Taylor","Sam","Evan","Jamie","Skye","Dee","Kai","Remy","Ash","Rowan","Reese","Charlie","Avery"];
    const RECRUIT_LAST_NAMES  = ["Cole","Rivers","Marlow","Sloan","Carter","Fox","Knight","Hayes","Chen","Singh","Diaz","Patel","Owen","Stone","Hart","Blake","West","Quinn","Lane","King"];
    const RECRUIT_ALIASES     = ["Quickfingers","Shade","Ghost","Pockets","Whisper","Locks","Needle","Slick","Nix","Rook","Switch","Ace","Zero","Blink","Patch","Vex"];
    const RECRUIT_BIO_FRAG    = [
      "Rumoured to have worked the markets since they were twelve.",
      "Keeps a low profile; prefers busy streets and tight crowds.",
      "Swears by gloves and a steady rhythm.",
      "Claims they can spot a mark from twenty paces.",
      "Quiet, patient, and methodical ‚Äî not much of a talker.",
      "Was once caught, never the same mistake twice.",
      "Carries a lucky coin; refuses to work without it."
    ];
    function seededRand(seed){ let s = seed>>>0; return ()=>{ s = (1664525*s + 1013904223)>>>0; return s/4294967296; }; }
    function ensureRecruitmentDaily(){
      if(!state.recruitment) state.recruitment = { daily:{ dayKey:'', candidates:[] }, crew: [] };
      const key = dateKeyFromGameTime();
      if((state.recruitment.daily.dayKey||'') !== key){
        const seed = key.split('-').reduce((acc,s)=> (acc*131 + parseInt(s,10))|0, 17)>>>0;
        const rnd = seededRand(seed);
        const f = RECRUIT_FIRST_NAMES.slice(); const l = RECRUIT_LAST_NAMES.slice(); const a = RECRUIT_ALIASES.slice();
        const c = 4 + Math.floor(seed % 3); // 4..6
        const picks = [];
        for(let i=0;i<c;i++){
          const fn = f[Math.floor(rnd()*f.length)] || "Alex";
          const ln = l[Math.floor(rnd()*l.length)] || "Quinn";
          const al = a[Math.floor(rnd()*a.length)] || "Shade";
          const bio = RECRUIT_BIO_FRAG[Math.floor(rnd()*RECRUIT_BIO_FRAG.length)] || "";
          const id = `rec-${key}-${i}`;
          picks.push({ id, name: fn+" "+ln, alias: al, bio, cut: 0.5, hireCost: 500 });
        }
        state.recruitment.daily.dayKey = key;
        state.recruitment.daily.candidates = picks;
        pushLog({ html: `<span class="muted">Recruitment refreshed (${c} candidates).</span>` });
        scheduleSave();
      }
    }
    function hireCrew(id){
      ensureRecruitmentDaily();
      const d = state.recruitment.daily;
      const idx = (d.candidates||[]).findIndex(c=>c.id===id);
      if(idx === -1) return;
      const cand = d.candidates[idx];
  // Require an active HQ to hire
  try{
    const hq = getHQRecord && getHQRecord();
    if(!hq){
      pushLog('<span class="red">Hire requires an HQ</span>: set a property as HQ in Property ‚Üí Holdings.');
      return;
    }
  }catch(e){
    if(!state.hq || !state.hq.propertyId){
      pushLog('<span class="red">Hire requires an HQ</span>: set a property as HQ in Property ‚Üí Holdings.');
      return;
    }
  }

      if((state.recruitment.crew||[]).length >= 3){ pushLog('<span class="muted">Crew is at capacity.</span>'); return; }
      if(state.money < cand.hireCost){ pushLog('<span class="muted">Not enough cash to hire.</span>'); return; }
      changeMoney(-cand.hireCost, 'crew-hire');
      const member = { id: cand.id, name: cand.name, alias: cand.alias, bio: cand.bio, cut: 0.5, hiredAt: (state.time?.gameMs||0), nextReadyAt: 0, role: "pickpocket", auto: false };
      state.recruitment.crew = state.recruitment.crew || [];
      state.recruitment.crew.push(member);
      d.candidates.splice(idx,1);
      pushLog({ html: `Hired <strong>${escapeHtml(member.name)}</strong> <span class="muted">"${escapeHtml(member.alias)}"</span> for ¬£${cand.hireCost}.` });
      scheduleSave(); renderRecruitmentView(); renderCrewLists(); updateUI();
    }
    function crewSuccessChance(){ return 0.50; } // fixed base per spec
    function crewCooling(member){
      return member.nextReadyAt && (Date.now() < member.nextReadyAt);
    }
    function doCrewPickpocket(memberId, origin='recruitment'){
      const crew = state.recruitment?.crew || [];
      const m = crew.find(x=>x.id===memberId);
      if(!m) return;
      if(crewCooling(m)) return;
      m.nextReadyAt = Date.now() + COOLDOWN_MS;
      // Resolve
      const cutRate = (m.cut ?? 0.5);
      const roll = Math.random();
      if(roll < crewSuccessChance()){
        const cash = randInt(PICK_MIN_CASH, PICK_MAX_CASH);
        const cut = Math.floor(cash * cutRate);
        const you = Math.max(0, cash - cut);
        changeMoney(you, 'crew-pickpocket');
        pushLog({ html: `${origin==='auto' ? '<span class=\'muted\'>[Auto]</span> ' : ''}<span class=\"good\">Success</span>: ${escapeHtml(m.alias)} lifted ${spanMoney(cash)} ‚Üí cut ${spanMoney(cut)}, you received ${spanMoney(you)}.` });
      }else{
        pushLog({ html: `${origin==='auto' ? '<span class=\'muted\'>[Auto]</span> ' : ''}<span class=\"bad\">Failed</span>: ${escapeHtml(m.alias)} returned empty-handed.` });
      }
      // No heat impact for crew (per spec)
      scheduleSave(); updateUI();
    }
    function renderRecruitmentView(){
      ensureRecruitmentDaily();
      const dayEl = document.getElementById('recruitDayKey'); if(dayEl) dayEl.textContent = state.recruitment.daily.dayKey || '‚Äî';
      const nextEl = document.getElementById('recruitNextRefresh'); if(nextEl){
        const d = new Date((state.time?.epochMs||0) + (state.time?.gameMs||0));
        const n = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1, 0,0,0,0);
        nextEl.textContent = n.toDateString();
      }
      const wrap = document.getElementById('recruitCandidates');
      if(wrap){
        const arr = state.recruitment.daily.candidates||[];
        if(arr.length===0){ wrap.innerHTML = '<div class="card"><p class="muted">No candidates right now. Check back after midnight.</p></div>'; }
        else{
          wrap.innerHTML = arr.map(c => {
            const id = c.id;
            return `<div class="card">
              <div class="row" style="justify-content:space-between;align-items:flex-start;gap:12px">
                <div>
                  <div class="prop-name">${escapeHtml(c.name)} <span class="muted small">"${escapeHtml(c.alias)}"</span></div>
                  <div class="small muted" style="margin-top:4px">${escapeHtml(c.bio)}</div>
                  <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
                    <div class="pill">Hire: <strong>¬£${c.hireCost}</strong></div>
                    <div class="pill">Cut: <strong>${Math.round((c.cut||0.5)*100)}%</strong></div>
                  </div>
                </div>
                <div>
                  <button class="btn" data-hire="${id}">Hire</button>
                </div>
              </div>
              <div class="small codepath debug-block">ID: <strong>${escapeHtml(c.id)}</strong></div>
            </div>`;
          }).join('');
          // bind
          wrap.querySelectorAll('[data-hire]').forEach(btn => {
            if(!btn.dataset.bound){
              btn.addEventListener('click', ()=> hireCrew(btn.getAttribute('data-hire')));
              btn.dataset.bound = '1';
            }
          });
        }
      }
      // debug summary
      const dK = document.getElementById('recruitDbgKey'); if(dK) dK.textContent = state.recruitment.daily.dayKey||'‚Äî';
      const dN = document.getElementById('recruitDbgN'); if(dN) dN.textContent = String((state.recruitment.daily.candidates||[]).length);
      const cN = document.getElementById('recruitDbgCrewN'); if(cN) cN.textContent = String((state.recruitment.crew||[]).length);
      renderCrewLists(); // update both crew lists
    }
    function formatCooldown(ms){
      const s = Math.max(0, Math.ceil(ms/1000));
      if(s>=60){ const m = Math.floor(s/60); const ss = s%60; return m+'m '+ss+'s'; }
      return s+'s';
    }
    function renderCrewLists(){
  const targets = [
    { id: 'crewList', origin: 'recruitment' }, // Recruitment tab (read-only)
    { id: 'hqCrewList', origin: 'hq' }         // HQ panel (actions)
  ];
  const now = Date.now();
  const crew = state.recruitment?.crew || [];

  function cardHtml(m, origin){
    const cooling = crewCooling(m);
    const left = cooling ? Math.max(0, m.nextReadyAt - now) : 0;
    const status = cooling ? `Cooldown: ${formatCooldown(left)}` : 'Ready';
    const actionHtml = (origin === 'hq')
      ? `<div class="row" style="gap:8px;flex-wrap:wrap"><button class="btn" data-crew-pick="${escapeHtml(m.id)}" ${cooling ? 'disabled':''}>Send: Pickpocket</button><button class="btn secondary" data-crew-auto="${escapeHtml(m.id)}" aria-pressed="${m.auto?'true':'false'}">${m.auto? 'Auto: ON' : 'Auto: OFF'}</button></div>`
      : `<span class="small muted">Send jobs from <strong>Headquarters ‚Üí Crew Jobs</strong></span>`;
    return `<div class="card crew-card" data-crew-id="${escapeHtml(m.id)}">
      <div class="row" style="justify-content:space-between;align-items:flex-start;gap:12px">
        <div>
          <div class="prop-name">${escapeHtml(m.name)} <span class="muted small">"${escapeHtml(m.alias)}"</span></div>
          <div class="small muted" style="margin-top:4px">${escapeHtml(m.bio)}</div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <div class="pill">Cut: <strong>${Math.round(((m.cut??0.5)*100))}%</strong></div>
            <div class="pill">Status: <strong class="crew-status">${status}</strong></div><div class="pill">Auto: <strong class="crew-auto">${m.auto?'ON':'OFF'}</strong></div><div class="pill"><span class="muted">Offline progress</span>: <strong>Not supported</strong></div>
          </div>
        </div>
        <div>${actionHtml}</div>
      </div>
      <div class="small codepath debug-block">nextReadyAt: <strong class="crew-next">${m.nextReadyAt||0}</strong> ‚Ä¢ origin=<strong>${origin}</strong></div>
    </div>`;
  }

  for(const target of targets){
    const el = document.getElementById(target.id);
    if(!el) continue;
    if(crew.length===0){
      el.innerHTML = '<div class="card"><p class="muted">No crew hired yet.</p></div>';
    }else{
      el.innerHTML = crew.map(m => cardHtml(m, target.origin)).join('');
    }
    if(target.origin === 'hq'){
      el.querySelectorAll('[data-crew-pick]').forEach(btn => {
        if(!btn.dataset.bound){
          btn.addEventListener('click', ()=> doCrewPickpocket(btn.getAttribute('data-crew-pick'), target.origin));
          btn.dataset.bound='1';
        }
      });
      // auto toggle
      el.querySelectorAll('[data-crew-auto]').forEach(btn => {
        if(!btn.dataset.bound){
          btn.addEventListener('click', ()=> toggleCrewAuto(btn.getAttribute('data-crew-auto')));
          btn.dataset.bound='1';
        }
      });
    }
  }
  // update signature used by refreshCrewCooldowns
  try{ window.__prevCrewSigIds = (state.recruitment?.crew||[]).map(c=>c.id).join('|'); }catch(e){}
}


// Lightweight per-tick updater for crew UI to avoid flicker
function refreshCrewCooldowns(){
  const crew = state.recruitment?.crew || [];
  const sig = crew.map(c=>c.id).join('|');
  if(typeof window.__prevCrewSigIds === 'string' && window.__prevCrewSigIds !== sig){
    // Membership changed ‚Üí re-render fully
    renderCrewLists();
    return;
  }
  const now = Date.now();
  const updateContainer = (id, origin) => {
    const root = document.getElementById(id);
    if(!root) return;
    root.querySelectorAll('.crew-card').forEach(card => {
      const cid = card.getAttribute('data-crew-id');
      const m = crew.find(x => x.id === cid);
      if(!m) return; // skip
      const cooling = crewCooling(m);
      const left = cooling ? Math.max(0, m.nextReadyAt - now) : 0;
      const statusTxt = cooling ? `Cooldown: ${formatCooldown(left)}` : 'Ready';
      const statusEl = card.querySelector('.crew-status');
      if(statusEl && statusEl.textContent !== statusTxt){ statusEl.textContent = statusTxt; }
            const autoEl = card.querySelector('.crew-auto');
      if(autoEl){ autoEl.textContent = (m.auto?'ON':'OFF'); }
      const nextEl = card.querySelector('.crew-next');
      if(nextEl){ nextEl.textContent = String(m.nextReadyAt||0); }
      if(origin === 'hq'){
        const btn = card.querySelector('[data-crew-pick]');
        const autoBtn = card.querySelector('[data-crew-auto]');
        if(autoBtn){
          const label = (m.auto? 'Auto: ON' : 'Auto: OFF');
          if(autoBtn.textContent !== label){ autoBtn.textContent = label; }
          const pressed = (m.auto? 'true' : 'false');
          if(autoBtn.getAttribute('aria-pressed') !== pressed){ autoBtn.setAttribute('aria-pressed', pressed); }
        }
        const autoEl = card.querySelector('.crew-auto');
        if(autoEl){ const txt = m.auto? 'ON':'OFF'; if(autoEl.textContent!==txt){ autoEl.textContent = txt; } }
        if(btn){
          const should = cooling;
          if(!!btn.disabled !== !!should){ btn.disabled = should; }
        }
      }
    });
  };
  updateContainer('crewList', 'recruitment');
  updateContainer('hqCrewList', 'hq');
}


function renderCrewActionsPanel(){
      const panel = document.getElementById('hqCrewPanel');
      if(!panel) return;
      const hasCrew = (state.recruitment?.crew||[]).length > 0;
      panel.classList.toggle('hidden', !hasCrew);
      panel.setAttribute('aria-hidden', String(!hasCrew));
      renderCrewLists();
    }

// Toggle auto-run for a crew member
function toggleCrewAuto(memberId){
  const crew = state.recruitment?.crew || [];
  const m = crew.find(x=>x.id===memberId);
  if(!m) return;
  m.auto = !m.auto;
  if(!m.role){ m.role = 'pickpocket'; }
  pushLog({ html: `Crew <strong>${escapeHtml(m.alias)}</strong>: auto-run ${m.auto ? '<span class="good">enabled</span>' : '<span class="muted">disabled</span>'}.` });
  scheduleSave(); updateUI();
}

// Process auto jobs each tick
function processCrewAutoJobs(){
  try{
    const crew = state.recruitment?.crew || [];
    const hqOk = (function(){ try{ return !!(getHQRecord && getHQRecord()); }catch(e){ return !!(state.hq && state.hq.propertyId); } })();
    if(!hqOk) return;
    for(const m of crew){
      if(!m || !m.auto) continue;
      if(crewCooling(m)) continue;
      const role = (m.role || 'pickpocket');
      if(role === 'pick' || role === 'pickpocket'){
        doCrewPickpocket(m.id, 'auto');
      }
      // Future roles go here
    }
  }catch(e){}
}

function updateUI(){
      document.getElementById("balanceValue").textContent = String(state.money);

      const heatEl = document.getElementById("heatValue");
      heatEl.textContent = String(state.heat);
      heatEl.classList.toggle('heat-hi', state.heat >= 70);
      heatEl.classList.toggle('heat-mid', state.heat >= 35 && state.heat < 70);

      const ch = successChance();
      document.getElementById("chanceValue").textContent = Math.round(ch * 100);
      const base = BASE_SUCCESS;
      const bonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
      const penalty = state.heat * HEAT_PENALTY_PER_HEAT;
      const detEl = document.getElementById("chanceDetail");
      if(detEl){ detEl.textContent = `base ${Math.round(base*100)}% + sleight ${Math.round(bonus*100)}% ‚àí heat ${Math.round(penalty*100)}% (clamped 5‚Äì90%)`; }

      const logEmpty = document.getElementById("logEmpty");
      const logList  = document.getElementById("logList");
      if(state.log.length === 0){
        logEmpty.classList.remove("hidden");
        logList.classList.add("hidden");
        logList.innerHTML = "";

// --- Search Bags chance + details
(function(){
  const sch = successChanceSearch();
  const sVal = document.getElementById("searchChanceValue");
  if(sVal){ sVal.textContent = Math.round(sch * 100); }
  const sDet = document.getElementById("searchChanceDetail");
  if(sDet){
    const sBase = SEARCH_BASE_SUCCESS;
    const sBonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
    const sPenalty = state.heat * HEAT_PENALTY_PER_HEAT;
    sDet.textContent = `base ${Math.round(sBase*100)}% + sleight ${Math.round(sBonus*100)}% ‚àí heat ${Math.round(sPenalty*100)}% (clamped 5‚Äì90%)`;
  }
})();

// --- One-job-at-a-time gating & unlock note
(function(){
  const pickBtn = document.getElementById("pickBtn");
  const searchBtn = document.getElementById("searchBtn");
  const searchLockedNote = document.getElementById("searchLockedNote");
  const unlocked = canUseSearchBags();
  const cooling = isCooling();
  if(pickBtn){ pickBtn.disabled = cooling; }
  if(searchBtn){ searchBtn.disabled = cooling || !unlocked; }
  if(searchLockedNote){ searchLockedNote.style.display = unlocked ? 'none' : 'inline'; }
})();

// --- Separate progress bars (shared cooldown)
(function(){
  const bar = document.getElementById("progressBar");
  const sBar = document.getElementById("searchProgressBar");
  if(!bar || !sBar){ return; }
  if(!pickEndsAt){
    bar.style.width = "0%";
    sBar.style.width = "0%";
    return;
  }
  const remaining = timeLeft();
  const pct = Math.min(1, Math.max(0, (COOLDOWN_MS - remaining) / COOLDOWN_MS));
  if(currentJob === 'search'){
    sBar.style.width = (pct * 100).toFixed(2) + "%";
    bar.style.width = "0%";
  }else{
    bar.style.width = (pct * 100).toFixed(2) + "%";
    sBar.style.width = "0%";
  }
})();

      }else{
        logEmpty.classList.add("hidden");
        logList.classList.remove("hidden");
        logList.innerHTML = (state.log||[]).map(item => {
          if (typeof item === "string"){
            const ts = fmtTime(new Date().toISOString());
            return `<li class="li"><span class="ts">[${ts}]</span>${escapeHtml(item)}</li>`;
          } else if (item && typeof item === "object"){
            const ts = fmtTime(item.ts || new Date().toISOString());
            const body = item.html ? item.html : escapeHtml(String(item.text ?? ""));
            return `<li class="li"><span class="ts">[${ts}]</span>${body}</li>`;
          }
          return "";
        }).join("");
      }
      // keep chance debug displays fresh each frame
      try{ updateChanceDebug(); }catch(e){}

      const hasStats = Object.keys(state.stats).length > 0;
      const statsEmptyEl = document.getElementById("statsEmpty");
      if(statsEmptyEl){ statsEmptyEl.classList.toggle("hidden", hasStats); }
      const statsList = document.getElementById("statsList");
      renderEquipmentUI();
      renderBuffSummary();
      const aliasText = document.getElementById('aliasText'); if(aliasText){ aliasText.textContent = state.profile.alias ? state.profile.alias : '(unset)'; }
      const hb = document.getElementById('healthBar'); if(hb){ hb.style.width = state.vitals.health + '%'; }
      const ht = document.getElementById('healthText'); if(ht){ ht.textContent = Number(state.vitals.health).toFixed(0) + '%'; }
      const hp = document.getElementById('healthPct'); if(hp){ hp.textContent = Number(state.vitals.health).toFixed(0) + '%'; }
      const gb = document.getElementById('hungerBar'); if(gb){ gb.style.width = state.vitals.hunger + '%'; }
      const gt = document.getElementById('hungerText'); if(gt){ gt.textContent = Number(state.vitals.hunger).toFixed(0) + '%'; }
      const gp = document.getElementById('hungerPct'); if(gp){ gp.textContent = Number(state.vitals.hunger).toFixed(0) + '%'; }
      const ct = document.getElementById('clockText'); if(ct){ ct.textContent = formatGameClock(state.time.gameMs||0); }
      if(statsList){
        statsList.classList.toggle("hidden", !hasStats);
        if(hasStats){
          statsList.innerHTML = Object.entries(state.stats)
            .map(([name, s]) => renderStatRow(name, s))
            .join("");
        }else{
          statsList.innerHTML = "";
        }
      }

      renderInventoryGrid();

      const pickBtn = document.getElementById("pickBtn");
      if(isCooling()){
        pickBtn.disabled = true;
        pickBtn.textContent = `Cooling‚Ä¶ ${Math.ceil(timeLeft()/1000)}s`;
      }else{
        pickBtn.disabled = false;
        pickBtn.textContent = "Attempt Pickpocket";
      }

      updateAutoSaveUI();
      // Analytics render
      const m = state.metrics;
      const eEl = document.getElementById("metricEarned");
      if(eEl){
        const earned = m.money.earned|0, spent = m.money.spent|0, net = Math.max(0, earned - spent);
        eEl.textContent = "¬£" + earned;
        const sEl = document.getElementById("metricSpent"); if(sEl) sEl.textContent = "¬£" + spent;
        const nEl = document.getElementById("metricNet"); if(nEl){ nEl.textContent = "¬£" + net; nEl.style.color = (net >= 0 ? "var(--good)" : "var(--danger)"); }
        const eSrc = document.getElementById("metricEarnedSrc"); if(eSrc) eSrc.textContent = String(earned);
        const sSrc2 = document.getElementById("metricSpentSrc"); if(sSrc2) sSrc2.textContent = String(spent);
        // Heat
        const hc = document.getElementById("metricHeatCurrent"); if(hc) hc.textContent = String(state.heat);
        const hp = document.getElementById("metricHeatPeak"); if(hp) hp.textContent = String(m.heat.peak|0);
        const hg = document.getElementById("metricHeatGained"); if(hg) hg.textContent = String(m.heat.gained|0);
        const hco = document.getElementById("metricHeatCooled"); if(hco) hco.textContent = String(m.heat.cooled|0);
        const ha = document.getElementById("metricHeatAvg"); if(ha) ha.textContent = String(m.heat.avg||0);
        const hSrcP = document.getElementById("metricHeatPeakSrc"); if(hSrcP) hSrcP.textContent = String(m.heat.peak|0);
        const hSrcG = document.getElementById("metricHeatGainedSrc"); if(hSrcG) hSrcG.textContent = String(m.heat.gained|0);
        const hSrcC = document.getElementById("metricHeatCooledSrc"); if(hSrcC) hSrcC.textContent = String(m.heat.cooled|0);
        const hSrcA = document.getElementById("metricHeatAvgSrc"); if(hSrcA) hSrcA.textContent = String(m.heat.avg||0);
        const hb = document.getElementById("metricHeatBar"); if(hb){ hb.style.width = Math.min(100, (state.heat/HEAT_MAX)*100).toFixed(2) + "%"; }
      }

    }

    function tick(){
  // Clear active job when cooldown ends
  if (pickEndsAt && timeLeft() <= 0){
    pickEndsAt = null;
    currentJob = null;
  }

  
  // Daily refresh for recruitment at in-game midnight
  (function(){
    try{
      const prev = window.__prevRecruitDayKey || "";
      const cur = dateKeyFromGameTime();
      if(prev !== cur){
        window.__prevRecruitDayKey = cur;
        ensureRecruitmentDaily();
        const recVisible = !document.getElementById('view-recruitment').classList.contains('hidden');
        if(recVisible){ renderRecruitmentView(); }
      }
    }catch(e){}
  })();
// Update both progress bars, but only animate the one for the active job
  const bar = document.getElementById("progressBar");          // pickpocket
  const sBar = document.getElementById("searchProgressBar");   // search bags
  if (bar && sBar){
    if (!pickEndsAt){
      bar.style.width = "0%";
      sBar.style.width = "0%";
    } else {
      const remaining = timeLeft();
      const pct = Math.min(1, Math.max(0, (COOLDOWN_MS - remaining) / COOLDOWN_MS));
      if (currentJob === 'search'){
        sBar.style.width = (pct * 100).toFixed(2) + "%";
        bar.style.width = "0%";
      } else {
        bar.style.width = (pct * 100).toFixed(2) + "%";
        sBar.style.width = "0%";
      }
    }
  // Ensure buttons reflect current state
  try{ syncActionButtons(); }catch(e){}

  }

  decayHeat();
  // Hunger decay
  decayHunger(TICK_MS/1000);
  advanceGameTime(TICK_MS);
  ensureDailyOffers();
  processRandomEncounter(TICK_MS);
  maybeTriggerPoliceEvent();

  
  refreshCrewCooldowns(); // crew cooldown UI
  processCrewAutoJobs(); // auto-run crew tasks
// Metrics sampling
  if(!state.metrics.heat){ state.metrics.heat = { _samples:0, _sum:0, avg:0 }; }
  state.metrics.heat._samples += 1;
  state.metrics.heat._sum += state.heat;
  state.metrics.heat.avg = Math.round((state.metrics.heat._sum / Math.max(1, state.metrics.heat._samples)) * 10) / 10;

  // Sampling (1s)
  const now = Date.now();
  if(!lastSampleAt || now - lastSampleAt >= SAMPLE_EVERY_MS){
    pushSample();
    lastSampleAt = now;
    chartNeedsDraw = true;
  }

  updateUI();
  // draw live chart if analytics visible
  const analyticsVisible = !document.getElementById('view-analytics').classList.contains('hidden');
  if(analyticsVisible && chartNeedsDraw){ drawLiveChart(); chartNeedsDraw = false; }
}

    function resetAll(forceRefresh){
      state.money = 0;
      state.heat = 0;
      state.stats = {};
      ensureDefaultStats();
      state.inventory = [];
      state.log = [];
      state.inventory = [];
      state.equipment = { head:null, chest:null, hands:null, legs:null, feet:null, accessory:null };
      state.profile = { alias: "" };
      state.vitals = { health: 100, hunger: 100 };
      state.storage = { items: [] };
      state.properties = { holdings: [], daily:{ dayKey:'', offers: [] } };
      
      state.recruitment = { daily: { dayKey: "", candidates: [] }, crew: [] }; // wipe crew for new game
state.hq = { propertyId: null };
      state.lifetime = { all: [] };
      if(!state.inventory.length && getHQStore().length===0){ seedFakeItems(); state.lifetime.seededOnce = true; try{ scheduleSave(); }catch(e){} }
      reconcileEquipment();
      
    // Clear battle log history
    try{ if(state.territory){ state.territory.logHistory = []; } }catch(e){}
    try{ const el=document.getElementById('tbLog'); if(el) el.innerHTML=''; const empty=document.getElementById('logEmpty'); if(empty) empty.classList.remove('hidden'); }catch(e){}
// Reset mail inbox and re-seed tutorial/test messages
      try{
        const keepCRT = (state.mail && typeof state.mail.crt === 'boolean') ? state.mail.crt : false;
        state.mail = { inbox: [], unread: 0, nextId: 1, seededWelcome: false, crt: keepCRT };
        if(typeof window.addMail === 'function'){
          const body = [
            "Welcome to CrimIdle! (Fictional game prototype.)",
            "",
            "How it works:",
            "‚Ä¢ Activities: try Pickpocket (cooldowns & chances apply).",
            "‚Ä¢ XP & Levels: successes (and tries) raise skills for better odds.",
            "‚Ä¢ Heat: goes up on actions; decays over time; high heat hurts success.",
            "‚Ä¢ Inventory: equip items to boost stats; store extras at your HQ.",
            "‚Ä¢ Property/HQ: claim a base and manage storage.",
            "‚Ä¢ Shop: grab snacks to manage vitals (placeholders).",
            "‚Ä¢ Autosave: your progress saves as you play.",
            "",
            "Tip: Watch the Analytics tab for Balance/Heat trends.",
            "",
            "‚Äî Control, ‚ÄòCI‚Äô Systems"
          ].join("\n");
          window.addMail({ from: "CI Systems", subject: "Welcome to CrimIdle ‚Äî Quick Start", body });
          const body2 = [
            "Inbox Demo ‚Äî Multiple Messages",
            "",
            "This is a second test email so you can see how multiple emails look.",
            "‚Ä¢ Newest messages appear at the top",
            "‚Ä¢ Click any message on the left to read it on the right",
            "",
            "Have fun testing!",
            "",
            "‚Äî CI Systems"
          ].join("\n");
          window.addMail({ from: "CI Systems", subject: "Inbox Demo ‚Äî Multiple Messages", body: body2 });
          state.mail.seededWelcome = true;
        }
      }catch(e){}
    
      state.metrics = { money: { earned: 0, spent: 0 }, heat: { peak: 0, gained: 0, cooled: 0, avg: 0, _samples: 0, _sum: 0 } };
      state.history = { session: [] };
      state.lifetime = { all: [] };
      state.time = { gameMs: 0, startedAt: Date.now(), epochMs: (function(){ const n=Date.now(); const DAY=24*60*60*1000; return n - (n % DAY); })() };
      state.properties = { holdings: [], daily:{ dayKey:'', offers: [] } };
      pickEndsAt = null;
      lastHeatDecayAt = Date.now();
      window.clearSave();
      updateUI();
    
      // If this was a "fresh reset" triggered by the Reset button,
      // perform a best-effort hard refresh to mimic Ctrl+F5.
      if (forceRefresh) {
        try { hardReload(); } catch(e) {
          try { location.reload(); } catch(_) {}
        }
        return;
      }
}

// Best-effort hard refresh: clear SW caches, unregister service workers,
// then reload with a cache-busting query param to avoid cached assets.
function hardReload(){
  function doReload(){
    try{
      var url = new URL(window.location.href);
      url.searchParams.set('_fresh', String(Date.now()));
      // Use replace() to avoid back/forward cache keeping the old page
      window.location.replace(url.toString());
    }catch(e){
      try{ window.location.reload(); }catch(_) {}
    }
  }
  var tasks = [];
  try{
    if ('serviceWorker' in navigator && navigator.serviceWorker.getRegistrations){
      tasks.push(navigator.serviceWorker.getRegistrations().then(function(regs){
        return Promise.all(regs.map(function(r){ try{ return r.unregister(); }catch(e){ return false; } }));
      }));
    }
  }catch(e){}
  try{
    if (window.caches && caches.keys){
      tasks.push(caches.keys().then(function(keys){
        return Promise.all(keys.map(function(k){ try{ return caches.delete(k); }catch(e){ return false; } }));
      }));
    }
  }catch(e){}
  // Even if something fails, still proceed to reload.
  Promise.allSettled(tasks).then(doReload, doReload);
}



    
    // Category state
    let activeCategory = 'petty';
    function applyCategory(){
      const petty = document.getElementById("cat-petty");
      const small = document.getElementById("cat-small");
      petty.classList.toggle("hidden", activeCategory !== 'petty');
      small.classList.toggle("hidden", activeCategory !== 'small');
      // Toggle button states
      const bPetty = document.getElementById("btnCatPetty");
      const bSmall = document.getElementById("btnCatSmall");
      if(bPetty) bPetty.setAttribute("aria-pressed", String(activeCategory === 'petty'));
      if(bSmall) bSmall.setAttribute("aria-pressed", String(activeCategory === 'small'));
      // Ensure main tab is Activities when a category is switched
      (function(){ const viewAct=document.getElementById("view-activities"); if(viewAct && viewAct.classList.contains("hidden")) setActiveTab("activities"); })();
// Show/hide job cards by data-category (petty/small)
try {
  document.querySelectorAll('.card[data-category]').forEach(function(card){
    card.classList.toggle('hidden', card.dataset.category !== activeCategory);
  });
} catch(e) { /* no-op */ }
}
    // === Property Market: category toggles ==================================
    let activePropertyCategory = 'rent';
    function applyPropertyCategory(){
      const rent = document.getElementById("prop-rent");
      const buy  = document.getElementById("prop-buy");
      const hold = document.getElementById("prop-holdings");
      if(rent) rent.classList.toggle("hidden", activePropertyCategory !== 'rent');
      if(buy)  buy .classList.toggle("hidden", activePropertyCategory !== 'buy');
      if(hold) hold.classList.toggle("hidden", activePropertyCategory !== 'holdings');
      const bRent = document.getElementById("btnPropRent");
      const bBuy  = document.getElementById("btnPropBuy");
      const bHold = document.getElementById("btnPropHoldings");
      if(bRent) bRent.setAttribute("aria-pressed", String(activePropertyCategory === 'rent'));
      if(bBuy)  bBuy .setAttribute("aria-pressed", String(activePropertyCategory === 'buy'));
      if(bHold) bHold.setAttribute("aria-pressed", String(activePropertyCategory === 'holdings'));
      // Refresh only the active property panel (no tab re-entry)
      if(activePropertyCategory === 'rent'){ renderRentOffers(); }
      else if(activePropertyCategory === 'holdings'){ renderHoldings(); }

}
    function setPropertyCategory(cat){
      if(cat === 'buy') activePropertyCategory = 'buy';
      else if(cat === 'holdings') activePropertyCategory = 'holdings';
      else activePropertyCategory = 'rent';
      applyPropertyCategory();
    }

    function setCategory(cat){
      activeCategory = (cat === 'small') ? 'small' : 'petty';
      applyCategory();
    }

    
    // Micro-interaction: button ripple effect
    function attachRipples(){
      document.addEventListener('click', (e) => {
        const btn = e.target.closest && e.target.closest('.btn');
        if(!btn) return;
        const rect = btn.getBoundingClientRect();
        const d = Math.max(rect.width, rect.height);
        const ripple = document.createElement('span');
        ripple.className = 'ripple';
        ripple.style.width = ripple.style.height = d + 'px';
        ripple.style.left = (e.clientX - rect.left - d/2) + 'px';
        ripple.style.top  = (e.clientY - rect.top  - d/2) + 'px';
        btn.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
      }, { passive: true });
    }
document.addEventListener("DOMContentLoaded", () => {
      // Click handlers

      // Debug toggle button
      const dbgBtn = document.getElementById('debugBtn');
      if(dbgBtn && !dbgBtn.dataset.bound){ dbgBtn.addEventListener('click', toggleDebug); dbgBtn.dataset.bound='1'; }
      document.getElementById("pickBtn").addEventListener("click", doPickpocket);
            const sb=document.getElementById("searchBtn"); if(sb){ sb.addEventListener("click", doSearchBags); }
(function(){ const rbtn=document.getElementById("resetBtn"); if(rbtn && !rbtn.dataset.bound){ rbtn.addEventListener("click", ()=>resetAll(true)); rbtn.dataset.bound="1"; } })();
      const s10=document.getElementById('sim10mBtn'); if(s10){ s10.addEventListener('click', ()=>simulateOffline(10*60*1000)); }
      const s1h=document.getElementById('sim1hBtn'); if(s1h){ s1h.addEventListener('click', ()=>simulateOffline(60*60*1000)); }
      const aliasBtn = document.getElementById('aliasEditBtn'); if(aliasBtn){ aliasBtn.addEventListener('click', openAliasDialog); }
      const aliasDlg = document.getElementById('aliasDialog');
      const aliasSave = document.getElementById('aliasSaveBtn');
      const aliasInput = document.getElementById('aliasInput');
      const aliasErr = document.getElementById('aliasError');
      if(aliasSave && aliasDlg && aliasInput){
        aliasSave.addEventListener('click', (e)=>{
          e.preventDefault();
          const val = (aliasInput.value||'').trim();
          if(val.length < 1 || val.length > 24){ aliasErr.textContent = 'Name must be 1‚Äì24 characters.'; aliasErr.style.display='block'; return; }
          if(/[^a-zA-Z0-9 _-]/.test(val)){ aliasErr.textContent = 'Only letters, numbers, spaces, - and _.'; aliasErr.style.display='block'; return; }
          aliasErr.style.display='none';
          setAlias(val);
          try{ aliasDlg.close(); }catch(e){ aliasDlg.removeAttribute('open'); }
        });
      }
      // Equip slot handlers (figure + badges)
      document.querySelectorAll('.slot').forEach(el=>{ const s = el.getAttribute('data-slot'); if(s){ el.addEventListener('click', ()=>openEquipSlot(s)); }});
// Category buttons
      const bPetty = document.getElementById("btnCatPetty");
      const bSmall = document.getElementById("btnCatSmall");
      if(bPetty && !bPetty.dataset.bound){ bPetty.addEventListener("click", () => setCategory('petty')); bPetty.dataset.bound="1"; }
      if(bSmall && !bSmall.dataset.bound){ bSmall.addEventListener("click", () => setCategory('small')); bSmall.dataset.bound="1"; }
      document.querySelectorAll(".sidelink").forEach(link => {
        link.addEventListener("click", () => setActiveTab(link.dataset.tab));
      });
      renderShop();
      const rangeBar = document.getElementById('chartRanges');
      if(rangeBar){
        rangeBar.querySelectorAll('.rangebtn').forEach(btn => {
          btn.addEventListener('click', () => {
            rangeBar.querySelectorAll('.rangebtn').forEach(b => b.setAttribute('aria-pressed', 'false'));
            btn.setAttribute('aria-pressed','true');
            const r = btn.getAttribute('data-range');
            chartRange = (r === 'all' || r === 'session') ? r : parseInt(r,10);
            const label = document.getElementById('dbgRangeLabel'); if(label){ label.textContent = btn.textContent.trim(); }
            chartNeedsDraw = true; drawChart();
          });
        });
      }

      const copyBtn = document.getElementById("copyKeyBtn");
      if(copyBtn){
        copyBtn.addEventListener("click", async () => {
          try{
            await navigator.clipboard.writeText(SAVE_KEY);
            addLog(`Copied save key: '${SAVE_KEY}'`);
          }catch(e){
            addLog('Could not copy save key.');
          }
          updateUI();
        });
      }

      // Sidebar responsive toggles
      const sidebar = document.getElementById("sidebar");
      const openBtn = document.getElementById("openSidebarBtn");
      const closeBtn = document.getElementById("toggleSidebarBtn");
      if(openBtn){ openBtn.addEventListener("click", () => sidebar.classList.add("open")); }
      if(closeBtn){ closeBtn.addEventListener("click", () => sidebar.classList.remove("open")); }

      // Load + init
      loadGame();
      ensureDefaultStats();
      if(!hasSeededOnce() && !state.inventory.length && getHQStore().length===0){ seedFakeItems(); }
      reconcileEquipment();
      (function(){ const viewAct=document.getElementById("view-activities"); if(viewAct && viewAct.classList.contains("hidden")) setActiveTab("activities"); })();
      applyCategory();
      updateUI();
      applyDebugUI();
      attachRipples();
      setInterval(tick, TICK_MS);
	  
	  // === Debug helpers: cash/xp buttons (visible when Debug is On) ===
      (function(){
        const gCash = document.getElementById('giveCashBtn');
        if (gCash && !gCash.dataset.bound){
          gCash.dataset.bound = '1';
          gCash.addEventListener('click', () => {
            const amt = 100;
            try{ changeMoney(amt, 'debug'); pushLog(`Debug: granted ${spanMoney(amt)}.`); }catch(e){}
            updateUI();
          });
        }
        const gXP = document.getElementById('giveXPBtn');
        if (gXP && !gXP.dataset.bound){
          gXP.dataset.bound = '1';
          gXP.addEventListener('click', () => {
            try{ ensureDefaultStats(); }catch(e){}
            const stats = Object.keys(state.stats || {});
            const per = (XP_AWARD_SUCCESS && Number(XP_AWARD_SUCCESS["Sleight of Hand"])) || 10;
            for (const name of stats){ try{ awardXP(name, per); }catch(e){} }
            try { pushLog(`Debug: +${per} XP to all ${stats.length} stats.`); } catch(e){}
            updateUI();
          });
        }
      })();

    });
  </script>
<dialog id="equipDialog">
<form class="modal-card" method="dialog">
<h3 style="margin-top:0">Equip Slot: <span id="equipSlotName">?</span></h3>
<!-- Filled dynamically -->
<ul aria-busy="false" aria-live="polite" class="list" id="equipList"></ul>
<p class="small muted" id="equipNone" style="display:none"></p>
<div class="debug-block small codepath">
      Code: <strong>state.equipment['<span id="equipSlotKey">?</span>']</strong>
</div>
<div class="modal-actions">
<button class="btn secondary" id="equipUnequipBtn" type="button">Unequip</button>
<button class="btn secondary" value="cancel">Close</button>
</div>
</form>
</dialog>
<dialog id="aliasDialog">
<form class="modal-card" method="dialog">
<h3 style="margin-top:0">Edit Alias</h3>
<div class="field"><label class="small muted" for="aliasInput">Enter a display name (1‚Äì24 characters)</label>
<input id="aliasInput" maxlength="24" placeholder="Your alias" type="text"/></div>
<p class="small" id="aliasError" style="color:var(--danger);display:none;margin:6px 0 0 0">Invalid name.</p>
<div class="modal-actions">
<button class="btn secondary" value="cancel">Cancel</button>
<button class="btn" id="aliasSaveBtn">Save</button>
</div>
</form>
</dialog>
<style id="ui-soft-borders" media="all">
  /* Final-pass overrides to remove bright outlines */
  .card,
  .pill,
  .btn,
  .statrow,
  #logList > li,
  .list > li,
  .slot.badge,
  .collapse-btn,
  .progress,
  .equip-wrap .row,
  .equip-wrap .slot,
  .market .row,
  .market .pill,
  .market .card {
    border: none !important;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.035) !important;
  }
  /* Progress tracks specifically shouldn't have strokes */
  .progress{ border: none !important; }
  /* Any 1px outline expressed as box-shadow */
  .has-outline,
  .inv-item.equipped, /* keep green inner stroke but soften the base */
  .list .item{
    box-shadow: inset 0 1px 0 rgba(255,255,255,.035) !important;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<!-- Analytics+Tabs Fix Patch: handles duplicate IDs & ensures chart/metrics render reliably -->
<script>
(function(){
  function patch(){
    try{
      // Helper: get all elements that (illegally) share an id
      function allById(id){
        return Array.from(document.querySelectorAll('[id="'+id+'"]'));
      }
      // Helper: set text on all duplicates
      function setAllText(id, txt){
        allById(id).forEach(el => { if(el) el.textContent = txt; });
      }
      // Sync analytics numbers across any duplicate sections
      function syncAnalyticsMirrors(){
        try{
          if(!window.state || !state.metrics) return;
          const m = state.metrics;
          const earned = (m.money && m.money.earned|0) || 0;
          const spent  = (m.money && m.money.spent|0)  || 0;
          const net    = Math.max(0, earned - spent);
          setAllText('metricEarned', '¬£' + earned);
          setAllText('metricSpent',  '¬£' + spent);
          setAllText('metricNet',    '¬£' + net);
          setAllText('metricEarnedSrc', String(earned));
          setAllText('metricSpentSrc',  String(spent));
          // Heat
          const heat = (state.heat|0) || 0;
          setAllText('metricHeatCurrent', String(heat));
          setAllText('metricHeatPeak',    String((m.heat && m.heat.peak|0) || 0));
          setAllText('metricHeatGained',  String((m.heat && m.heat.gained|0) || 0));
          setAllText('metricHeatCooled',  String((m.heat && m.heat.cooled|0) || 0));
          setAllText('metricHeatAvg',     String((m.heat && m.heat.avg) || 0));
          setAllText('metricHeatPeakSrc',   String((m.heat && m.heat.peak|0) || 0));
          setAllText('metricHeatGainedSrc', String((m.heat && m.heat.gained|0) || 0));
          setAllText('metricHeatCooledSrc', String((m.heat && m.heat.cooled|0) || 0));
          setAllText('metricHeatAvgSrc',    String((m.heat && m.heat.avg) || 0));
          // Bars
          allById('metricHeatBar').forEach(hb => {
            try{
              const HEAT_MAX = (window.HEAT_MAX||100);
              hb.style.width = Math.min(100, (heat/HEAT_MAX)*100).toFixed(2) + '%';
            }catch(e){}
          });
        }catch(e){}
      }

      // Bind range buttons for ALL duplicate toolbars
      (function bindAllRangebars(){
        const bars = allById('chartRanges');
        bars.forEach(rangeBar => {
          if(rangeBar && !rangeBar.dataset.bound){
            rangeBar.dataset.bound = '1';
            rangeBar.querySelectorAll('.rangebtn').forEach(btn => {
              btn.addEventListener('click', () => {
                try{
                  rangeBar.querySelectorAll('.rangebtn').forEach(b => b.setAttribute('aria-pressed', 'false'));
                }catch(e){}
                btn.setAttribute('aria-pressed','true');
                const r = btn.getAttribute('data-range');
                window.chartRange = (r === 'all' || r === 'session') ? r : parseInt(r,10);
                allById('dbgRangeLabel').forEach(label => { label.textContent = btn.textContent.trim(); });
                window.chartNeedsDraw = true;
                try{ window.drawChart(); }catch(e){}
              });
            });
          }
        });
      })();

      // Wrap setActiveTab so it toggles ALL duplicate views
      if(typeof window.setActiveTab === 'function' && !window.setActiveTab.__patched){
        const __origSetActiveTab = window.setActiveTab;
        window.setActiveTab = function(id){
          try{ __origSetActiveTab.call(this, id); }catch(e){}
          try{
            const views = ["headquarters","property","activities","stats","inventory","upgrades","shop","analytics","mail","gambling"];
            const catsRowAll = allById('activityCats');
            views.forEach(v => {
              const active = (v === id);
              allById('view-'+v).forEach(el => {
                el.classList.toggle('hidden', !active);
                el.setAttribute('aria-hidden', (!active).toString());
              });
            });
            catsRowAll.forEach(catsRow => catsRow.classList.toggle('hidden', id !== 'activities'));
            if(id === 'analytics'){
              // ensure label matches current selection
              const labelText = (window.chartRange === 'all' ? 'all'
                               : window.chartRange === 'session' ? 'session'
                               : (Math.round(((Number(window.chartRange)||300000)/60000)) + 'm'));
              allById('dbgRangeLabel').forEach(label => { label.textContent = labelText; });
              if((state.lifetime?.all?.length||0)===0 && (state.history?.session?.length||0)===0){
                try{ if(typeof window.pushSample==='function') window.pushSample(); }catch(e){}
              }
              window.chartNeedsDraw = true;
              try{ window.drawChart(); }catch(e){}
            }
          }catch(e){}
        };
        window.setActiveTab.__patched = true;
      }

      // Override drawChart to target the visible canvas (in case of duplicates)
      (function patchDrawChart(){
        function cssVar(name, fallback){
          try{
            const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
            return v || fallback;
          }catch(e){ return fallback; }
        }
        function safeGetSeries(){
          try{ return (typeof window.getSamplesForRange==='function') ? window.getSamplesForRange() : []; }
          catch(e){ return []; }
        }
        function mapY(value, minY, maxY, h, pad){ // mirror of existing helper
          pad = (typeof pad==='number') ? pad : 8;
          if(maxY === minY) return h/2;
          const pct = (value - minY) / (maxY - minY);
          return Math.round((1 - pct) * (h - pad*2) + pad);
        }
        function drawPatched(){
          const list = Array.from(document.querySelectorAll('[id="analyticsChart"]'));
          if(list.length === 0) return;
          const target = list.find(c => c.offsetWidth > 0 && c.offsetHeight > 0 && !c.closest('.hidden')) || list[0];
          const c = target;
          const ctx = c.getContext('2d');
          const w = c.width = c.clientWidth || c.width || 600;
          const h = c.height = 220;

          const series = safeGetSeries();
          const count = series.length;

          // Determine Y bounds with padding
          let minY = Infinity, maxY = -Infinity;
          for(const s of series){
            if(s.money < minY) minY = s.money;
            if(s.money > maxY) maxY = s.money;
            if(s.heat  < minY) minY = Math.min(minY, s.heat);
            if(s.heat  > maxY) maxY = Math.max(maxY, s.heat);
            if(Number.isFinite(s.spent)){ // allow 0
              if(s.spent < minY) minY = Math.min(minY, s.spent);
              if(s.spent > maxY) maxY = Math.max(maxY, s.spent);
            }
          }
          if(!isFinite(minY) || !isFinite(maxY)){
            minY = 0; maxY = Math.max(10, (state?.money|0) + 10);
          }
          if(minY === maxY){ maxY = minY + 1; }

          // Clear
          ctx.clearRect(0,0,w,h);
          ctx.fillStyle = '#0b0f14';
          ctx.fillRect(0,0,w,h);

          // Grid
          ctx.strokeStyle = 'rgba(255,255,255,0.08)';
          ctx.lineWidth = 1;
          const stripes = 5;
          for(let i=1;i<stripes;i++){
            const y = Math.round((h/stripes)*i);
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(w,y);
            ctx.stroke();
          }

          // Draw helper
          function lineFor(key, stroke, dash){
            if(count < 1) return;
            ctx.beginPath();
            ctx.setLineDash(dash||[]);
            ctx.lineWidth = 2;
            ctx.strokeStyle = stroke;
            for(let i=0;i<count;i++){
              const s = series[i];
              const x = Math.round((i/(Math.max(1,count-1))) * (w-2)) + 1;
              const yv = key==='money' ? s.money : (key==='heat' ? s.heat : (s.spent||0));
              const y = mapY(yv, minY, maxY, h, 8);
              if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
          }

          const colMoney = cssVar('--good', '#22c55e');
          const colHeat  = cssVar('--accent-warm', '#f59e0b');
          const colSpent = cssVar('--danger', '#ef4444');

          // Money & Heat always; Spent if present
          lineFor('money', colMoney);
          lineFor('heat',  colHeat);
          if(series.some(s => Number.isFinite(s.spent))) lineFor('spent', colSpent, [5,4]);

          // Legend (top-right-ish)
          ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
          ctx.textBaseline = 'top';
          const items = [
            ['Money', colMoney],
            ['Heat',  colHeat],
            ['Outgoings', colSpent]
          ];
          let lx = w - 120, ly = 6;
          items.forEach(([label,color]) => {
            ctx.fillStyle = color;
            ctx.fillRect(lx, ly+3, 10, 10);
            ctx.fillStyle = '#e5e7eb';
            ctx.fillText(label, lx+14, ly);
            ly += 16;
          });
        }

        // Replace global drawChart/drawLiveChart with patched versions
        window.drawChart = drawPatched;
        window.drawLiveChart = function(){ try{ drawPatched(); }catch(e){} };
      })();

      // Replace analyticsVisible check to consider ALL duplicates
      if(typeof window.tick === 'function' && !window.tick.__analyticsPatched){
        const __origTick = window.tick;
        window.tick = function(){
          try{ __origTick.call(this); }catch(e){}
          try{
            // After original tick, ensure mirrors are synced
            syncAnalyticsMirrors();
          }catch(e){}
        };
        window.tick.__analyticsPatched = true;
      }else{
        // Fallback: periodically sync mirrors
        try{ setInterval(syncAnalyticsMirrors, 1000); }catch(e){}
      }

      // Initial sync once
      syncAnalyticsMirrors();

    }catch(e){ /* swallow */ }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', patch);
  }else{
    patch();
  }
})();
</script>
<!-- Compatibility stubs: prevent errors if optional systems are omitted -->
<script>
// Define no-op fallbacks if these hooks aren't present in this build.
if (typeof window.processRandomEncounter !== 'function') {
  window.processRandomEncounter = function(/*dt*/){ /* no-op (compat) */ };
}
if (typeof window.maybeTriggerPoliceEvent !== 'function') {
  window.maybeTriggerPoliceEvent = function(){ /* no-op (compat) */ };
}
</script>
<script>
(function(){
  // Guard: ensure global state object exists
  window.state = window.state || {};

  function escapeHtml(str){
    try {
      return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
    } catch(e){ return String(str); }
  }

  function ensureMailState(){
    if(!window.state) window.state = {};
    if(!state.mail) state.mail = { inbox: [], unread: 0, nextId: 1, seededWelcome: false, crt: false, selectedId: null, lastReadId: null };
    if(!Array.isArray(state.mail.inbox)) state.mail.inbox = [];
    if(typeof state.mail.unread!=='number') state.mail.unread = 0;
    if(typeof state.mail.nextId!=='number') state.mail.nextId = Math.max(1, state.mail.inbox.length+1);
    if(typeof state.mail.seededWelcome!=='boolean') state.mail.seededWelcome = false;
    if(typeof state.mail.crt!=='boolean') state.mail.crt = false;
    if(state.mail.selectedId && typeof state.mail.selectedId!=='string') state.mail.selectedId = null;
    if(state.mail.lastReadId && typeof state.mail.lastReadId!=='string') state.mail.lastReadId = null;
  }

  function sanitizeMail(data){
    const out = { inbox: [], unread: 0, nextId: 1, seededWelcome: false, crt: false, selectedId: null, lastReadId: null };
    if(!data || typeof data!=='object') return out;
    out.inbox = Array.isArray(data.inbox) ? data.inbox.slice(0,200).map(m=>{
      if(!m || typeof m!=='object') return null;
      return {
        id: String(m.id||'').slice(0,40) || ('m'+Math.random().toString(36).slice(2,8)),
        from: String(m.from||'System').slice(0,80),
        subject: String(m.subject||'(no subject)').slice(0,160),
        body: String(m.body||''),
        ts: Math.max(0, Math.floor(Number(m.ts)||Date.now())),
        read: !!m.read
      };
    }).filter(Boolean) : [];
    out.unread = out.inbox.reduce((n,m)=> n + (!m.read ? 1 : 0), 0);
    out.nextId = Math.max(1, Number.isFinite(data.nextId) ? Math.floor(data.nextId) : (out.inbox.length+1));
    out.crt = !!data.crt;
    out.selectedId = (typeof data.selectedId==='string') ? data.selectedId : null;
    out.lastReadId = (typeof data.lastReadId==='string') ? data.lastReadId : null;
    out.seededWelcome = !!data.seededWelcome;
    out.crt = !!data.crt;
    return out;
  }

  function updateMailBadge(){
    const badge = document.getElementById('mailBadge');
    if(!badge) return;
    const n = Math.max(0, Array.isArray(state.mail?.inbox) ? state.mail.inbox.reduce((k,m)=>k+(!m.read?1:0),0) : (state.mail?.unread|0));
    badge.textContent = String(n);
    badge.classList.toggle('hidden', n===0);
  }

  function renderMailList(selectedId){
    ensureMailState();
    const ul = document.getElementById('mailList');
    if(!ul) return;
    const rows = state.mail.inbox.map(m=>{
      const selected = (m.id === selectedId);
      const classes = ['mail-item']; if(!m.read) classes.push('unread'); if(selected) classes.push('selected');
      const ago = (typeof window.formatTimeAgo==='function') ? window.formatTimeAgo(m.ts) : '';
      return `<li class="${classes.join(' ')}" data-id="${escapeHtml(m.id)}" tabindex="0" role="button" aria-pressed="${selected}">
        <div class="sender">${escapeHtml(m.from)}</div>
        <div class="subj">${escapeHtml(m.subject)}</div>
        <div class="meta"><span>${ago}</span></div>
      </li>`;
    }).join('');
    ul.innerHTML = rows || '';
    const empty = document.getElementById('mailEmpty');
    const reader = document.getElementById('mailRead');
    if(empty) empty.classList.toggle('hidden', !!state.mail.inbox.length);
    if(reader) reader.classList.toggle('hidden', !selectedId);
    ul.querySelectorAll('.mail-item').forEach(li=>{
      li.addEventListener('click', ()=>openMail(li.getAttribute('data-id')));
      li.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); openMail(li.getAttribute('data-id')); }});
    });
  }

  function openMail(id){
    ensureMailState();
    const m = state.mail.inbox.find(x=>x && x.id===id);
    const box = document.getElementById('mailRead');
    const empty = document.getElementById('mailEmpty');
    if(!m || !box) return;
    document.getElementById('mailSubj').textContent = m.subject;
    document.getElementById('mailFrom').textContent = m.from;
    document.getElementById('mailAgo').textContent = (typeof window.formatTimeAgo==='function') ? window.formatTimeAgo(m.ts) : '';
    document.getElementById('mailBody').textContent = m.body;
    box.classList.remove('hidden'); box.setAttribute('aria-hidden','false');
    // Remember selection
    try{ state.mail.selectedId = id; if (typeof window.scheduleSave==='function') window.scheduleSave(); }catch(e){}
    if(empty) empty.classList.add('hidden');
    markMailRead(id);
    renderMailList(id);
  }

  function renderMailView(){
    ensureMailState();
    let sel = (state.mail && state.mail.selectedId) || (state.mail && state.mail.lastReadId) || ((state.mail && state.mail.inbox[0] && state.mail.inbox[0].id) || '');
    renderMailList(sel);
    updateMailBadge();
    if(sel) openMail(sel);
  }

  function addMail({from, subject, body, ts}){
    ensureMailState();
    const id = 'm'+(state.mail.nextId++);
    const msg = { id, from: String(from||'System'), subject: String(subject||'(no subject)'), body: String(body||''), ts: ts||Date.now(), read: false };
    state.mail.inbox.unshift(msg);
    state.mail.unread++;
    updateMailBadge();
    if (typeof window.pushLog === 'function'){
      try{ window.pushLog(`New mail: <strong>${escapeHtml(msg.subject)}</strong>`); }catch(e){}
    }
    if (typeof window.scheduleSave === 'function'){ window.scheduleSave(); }
      try{ if(typeof window.saveGame==='function') window.saveGame({silent:true}); }catch(e){}
    const mailView = document.getElementById('view-mail');
    if(mailView && !mailView.classList.contains('hidden')) renderMailView();
    const badge = document.getElementById('mailBadge');
    if(badge){ badge.classList.add('bump'); setTimeout(()=>badge.classList.remove('bump'), 300); }
    return msg;
  }

  function markMailRead(id){
    ensureMailState();
    const m = state.mail.inbox.find(x=>x && x.id===id);
    if(m && !m.read){
      m.read = true;
      m.readAt = Date.now();
      state.mail.unread = Math.max(0, state.mail.unread - 1);
      state.mail.lastReadId = id;
      state.mail.selectedId = id;
      updateMailBadge();
      if (typeof window.scheduleSave === 'function'){ window.scheduleSave(); }
      try{ if(typeof window.saveGame==='function') window.saveGame({silent:true}); }catch(e){}
    }
  }

  // Expose a convenience API
  window.pushMail = (from, subject, body) => addMail({from, subject, body});

  // Inject hooks into save/load if present; otherwise leave state.mail as-is to avoid breakage.
  try {
    // Hook saveGame by shallowly adding mail to payload stringification (non-invasive wrapper)
    if (typeof window.saveGame === 'function' && !window.saveGame.__mailWrapped){
      const _saveGame = window.saveGame;
      window.saveGame = function(){
        ensureMailState();
        try{ return _saveGame.apply(this, arguments); }
        finally {
          // No-op: existing saveGame likely serializes state wholesale; mail lives on state so it's persisted anyway.
        }
      };
      window.saveGame.__mailWrapped = true;
    }
  } catch(e){}

  // After DOM is ready, ensure state, seed welcome once, wire tab behavior
  const onReady = () => {
    ensureMailState();
    // If the app has its own loadGame that hydrates state async, wait a tick.
    setTimeout(()=>{
      try {
        // Attempt to sanitize any loaded mail
        if (state.mail) state.mail = sanitizeMail(state.mail);
      } catch(e){}
      // Seed initial welcome mail once per profile
      if(!state.mail.seededWelcome){
        const body = [
          "Welcome to CrimIdle! (Fictional game prototype.)",
          "",
          "How it works:",
          "‚Ä¢ Activities: try Pickpocket (cooldowns & chances apply).",
          "‚Ä¢ XP & Levels: successes (and tries) raise skills for better odds.",
          "‚Ä¢ Heat: goes up on actions; decays over time; high heat hurts success.",
          "‚Ä¢ Inventory: equip items to boost stats; store extras at your HQ.",
          "‚Ä¢ Property/HQ: claim a base and manage storage.",
          "‚Ä¢ Shop: grab snacks to manage vitals (placeholders).",
          "‚Ä¢ Autosave: your progress saves as you play.",
          "",
          "Tip: Watch the Analytics tab for Balance/Heat trends.",
          "",
          "‚Äî Control, ‚ÄòCI‚Äô Systems"
        ].join("\n");
        addMail({ from: "CI Systems", subject: "Welcome to CrimIdle ‚Äî Quick Start", body });
        const body2 = [
          "Inbox Demo ‚Äî Multiple Messages",
          "",
          "This is a second test email so you can see how multiple emails look.",
          "‚Ä¢ Newest messages appear at the top",
          "‚Ä¢ Click any message on the left to read it on the right",
          "",
          "Have fun testing!",
          "",
          "‚Äî CI Systems"
        ].join("\n");
        addMail({ from: "CI Systems", subject: "Inbox Demo ‚Äî Multiple Messages", body: body2 });
    
        state.mail.seededWelcome = true;
        if (typeof window.scheduleSave === 'function'){ window.scheduleSave(); }
      try{ if(typeof window.saveGame==='function') window.saveGame({silent:true}); }catch(e){}
      }
      updateMailBadge();
      // If your tab system uses setActiveTab and a known views list, try to auto-render when visiting "mail"
      // We add a small observer on sidebar clicks for safety.
      const mailLink = document.getElementById('mailLink');
      if(mailLink){
        mailLink.addEventListener('click', ()=>{ renderMailView(); });
      }
    }, 0);
  };

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", onReady, { once: true });
  } else {
    onReady();
  }
})();
</script>
<script>
(function(){
  try{
    if(typeof window.setActiveTab === 'function' && !window.setActiveTab.__mailHooked){
      const _setActiveTab = window.setActiveTab;
      window.setActiveTab = function(id){
        const ret = _setActiveTab.apply(this, arguments);
        if(id === 'mail' && typeof window.renderMailView === 'function'){ try{ window.renderMailView(); }catch(e){} }
        return ret;
      };
      window.setActiveTab.__mailHooked = true;
    }
  }catch(e){}
})();
</script>
<script>
(function(){
  try{
    if(typeof window.loadGame === 'function' && !window.loadGame.__mailHooked){
      const _loadGame = window.loadGame;
      window.loadGame = function(){
        const ret = _loadGame.apply(this, arguments);
        try{
          if(typeof window.sanitizeMail === 'function'){
            if(!window.state) window.state = {};
            window.state.mail = window.sanitizeMail(window.state.mail);
          }
          if(typeof window.ensureMailState === 'function'){ window.ensureMailState(); }
        }catch(e){}
        return ret;
      };
      window.loadGame.__mailHooked = true;
    }
  }catch(e){}
})();
</script>
<script id="mail-crt-toggle">
(function(){
  function applyCRT(){
    var root = document.getElementById('view-mail');
    if(!root) return;
    if(!window.state) window.state = {};
    if(!state.mail) state.mail = {};
    if(typeof state.mail.crt !== 'boolean') state.mail.crt = false; // default OFF by default
    root.classList.toggle('crt-on', !!state.mail.crt);
    var btn = document.getElementById('mailThemeToggle');
    if(btn){ btn.textContent = state.mail.crt ? 'CRT: ON' : 'CRT: OFF'; }
  }
  function initCRT(){
    applyCRT();
    var btn = document.getElementById('mailThemeToggle');
    if(btn){
      btn.addEventListener('click', function(){
        if(!window.state) window.state = {};
        if(!state.mail) state.mail = {};
        state.mail.crt = !state.mail.crt;
        applyCRT();
        if(typeof window.scheduleSave === 'function') try{ window.scheduleSave(); }catch(e){}
      });
    }
  }
  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', initCRT, { once: true });
  }else{
    initCRT();
  }
})();

// === Gambling (Tiered) =======================================================
(function(){
  let gamblingBound = false;
  const REEL_STRIPS = [["üçã", "‚≠ê", "‚≠ê", "üçí", "üçí", "üîî", "üçí", "üçã", "üçí", "üçã", "üçí", "üîî", "7Ô∏è‚É£", "üçã", "üçí", "üîî", "üîî", "üçã", "üçí", "üîî", "üîî", "‚≠ê", "üçí", "üîî", "üçí", "üçí", "üçí", "üçã", "‚≠ê", "üçã", "üîî", "üçã", "üîî", "üçí", "üçí", "üçí", "üçã", "üîî", "üçí", "‚≠ê", "üîî", "üîî", "‚≠ê", "üçã", "üîî", "üîî", "üçã", "‚≠ê", "7Ô∏è‚É£", "üçí", "‚≠ê", "üçã", "üîî", "‚≠ê", "üçã", "7Ô∏è‚É£", "üçã", "üîî", "üçí", "‚≠ê", "üçí", "7Ô∏è‚É£", "‚≠ê", "üçã", "üîî", "üçã", "üçã", "‚≠ê", "üçí", "üçã", "‚≠ê", "7Ô∏è‚É£", "üîî", "‚≠ê", "7Ô∏è‚É£", "7Ô∏è‚É£", "üçí", "üçã", "üîî", "7Ô∏è‚É£", "üçí", "7Ô∏è‚É£", "7Ô∏è‚É£", "‚≠ê", "üçã", "‚≠ê", "üçí", "‚≠ê", "üçí", "üçã", "‚≠ê", "üçã", "üîî", "üçí", "üîî", "üçí", "üçí", "üçã", "üçí", "üçí", "üîî", "7Ô∏è‚É£", "üîî", "üçã", "üîî", "üçí", "7Ô∏è‚É£", "üçã", "üçã", "7Ô∏è‚É£", "üîî", "‚≠ê", "üçí", "üçí", "üçí", "üîî", "7Ô∏è‚É£", "üçí", "‚≠ê", "üîî", "üçã", "‚≠ê", "üîî", "üçã", "‚≠ê", "üçã", "üçí", "üçã"], ["üçí", "üçã", "üîî", "üîî", "üçí", "üîî", "üçã", "üîî", "üîî", "üîî", "üçã", "üîî", "üîî", "üçã", "üçã", "7Ô∏è‚É£", "üçã", "‚≠ê", "üçí", "üçí", "7Ô∏è‚É£", "üçí", "üîî", "üçí", "‚≠ê", "üçí", "üîî", "7Ô∏è‚É£", "üçí", "‚≠ê", "üîî", "üçí", "7Ô∏è‚É£", "üçí", "‚≠ê", "‚≠ê", "7Ô∏è‚É£", "üîî", "‚≠ê", "üçí", "üîî", "üçí", "üçã", "üçí", "üçí", "üçã", "7Ô∏è‚É£", "‚≠ê", "üçí", "üçí", "üçí", "‚≠ê", "7Ô∏è‚É£", "üîî", "üçã", "üîî", "üçã", "üîî", "üçã", "üçã", "üçí", "üçã", "7Ô∏è‚É£", "‚≠ê", "‚≠ê", "üçí", "üçã", "üçí", "üçí", "üîî", "üçí", "‚≠ê", "üîî", "7Ô∏è‚É£", "‚≠ê", "üîî", "‚≠ê", "üîî", "üîî", "üçã", "üîî", "‚≠ê", "üçí", "üçã", "7Ô∏è‚É£", "‚≠ê", "üîî", "üçã", "‚≠ê", "‚≠ê", "‚≠ê", "üîî", "7Ô∏è‚É£", "‚≠ê", "üçã", "‚≠ê", "üçã", "üîî", "üçã", "üçã", "üçí", "7Ô∏è‚É£", "üçí", "üçí", "üçã", "üçí", "üîî", "üîî", "7Ô∏è‚É£", "üîî", "‚≠ê", "üçí", "üçã", "üçã", "üçí", "‚≠ê", "üçã", "7Ô∏è‚É£", "üçã", "üçã", "üçã", "üçí", "üçí", "üçí", "üîî", "üçã", "üçã", "üîî"], ["üçí", "‚≠ê", "üçí", "üîî", "üçí", "üîî", "üçã", "7Ô∏è‚É£", "üîî", "‚≠ê", "üçí", "üîî", "‚≠ê", "üçí", "7Ô∏è‚É£", "üîî", "üîî", "üîî", "üçã", "üîî", "üçã", "7Ô∏è‚É£", "üîî", "üçã", "üîî", "‚≠ê", "7Ô∏è‚É£", "üçí", "‚≠ê", "üçã", "üîî", "üçã", "7Ô∏è‚É£", "üçí", "üîî", "üçã", "‚≠ê", "‚≠ê", "üçã", "üîî", "üçí", "üçí", "üîî", "‚≠ê", "üçã", "üîî", "‚≠ê", "7Ô∏è‚É£", "üîî", "7Ô∏è‚É£", "üçí", "‚≠ê", "üîî", "‚≠ê", "üçã", "‚≠ê", "üîî", "üîî", "üçí", "üçí", "üîî", "‚≠ê", "‚≠ê", "üçã", "üîî", "7Ô∏è‚É£", "‚≠ê", "üçã", "‚≠ê", "üçí", "üçí", "üçã", "üîî", "‚≠ê", "üçí", "üçí", "üçã", "üçã", "üîî", "üçí", "üçã", "üçí", "üçã", "üçã", "üîî", "üçã", "üçí", "üîî", "üçí", "‚≠ê", "üçã", "üçí", "üîî", "7Ô∏è‚É£", "üîî", "7Ô∏è‚É£", "üçí", "7Ô∏è‚É£", "üîî", "üçí", "üçã", "üçí", "üçã", "üçã", "üîî", "‚≠ê", "üçã", "üçí", "üîî", "7Ô∏è‚É£", "üîî", "üîî", "üçí", "‚≠ê", "üçã", "üçã", "üçã", "üçã", "üçí", "‚≠ê", "‚≠ê", "üçí", "üçí", "7Ô∏è‚É£", "üçã", "üçã", "üçí", "7Ô∏è‚É£"]];

function spinReels(){
  return REEL_STRIPS.map(strip => strip[Math.floor(Math.random()*strip.length)]);
}

  
  function renderTierHint(){
    const el = document.getElementById('tbTierHint'); if(!el) return;
    const cap = getCapturedCount();
    const maxTier = Math.min(6, cap+1);
    if(maxTier >= 6){
      el.textContent = `Captured ${cap}/6 ‚Ä¢ All tiers unlocked`;
    }else{
      el.textContent = `Captured ${cap}/6 ‚Ä¢ Unlocked: T1‚ÄìT${maxTier} ‚Ä¢ Next unlock at ${cap+1}/6`;
    }
  }
function setTier(n){
    const btn1 = document.getElementById('btnTier1');
    const btn2 = document.getElementById('btnTier2');
    const btn3 = document.getElementById('btnTier3');
    const t1 = document.getElementById('tier-1');
    const t2 = document.getElementById('tier-2');
    const t3 = document.getElementById('tier-3');
    if(!btn1||!btn2||!btn3||!t1||!t2||!t3) return;
    btn1.setAttribute('aria-pressed', String(n===1));
    btn2.setAttribute('aria-pressed', String(n===2));
    btn3.setAttribute('aria-pressed', String(n===3));
    t1.classList.toggle('hidden', n!==1);
    t2.classList.toggle('hidden', n!==2);
    t3.classList.toggle('hidden', n!==3);
  
    if(n===2){ try{ bindRouletteUI(); }catch(e){} }

    if(n===1){ try{ setTimeout(()=> window.dispatchEvent(new Event('resize')), 0); }catch(e){} }
}

  function getBet(){ 
    const inp = document.getElementById('betInput'); 
    let v = parseInt(inp && inp.value || '1',10); 
    if(isNaN(v) || v < 1) v = 1; 
    return v; 
  }
  function setSpinCostLabel(){
    const cost = document.getElementById('spinCost'); 
    if(cost){ cost.textContent = String(getBet()); }
  }
  function applySlotPayout(a,b,c){
    // Cost upfront
    const bet = getBet();
    if((state.money|0) < bet){
      pushLog('' + `<span class="logpiece tbad">Insufficient funds for spin (¬£${bet})</span>`);
      return { paid:false, win:0 };
    }
    changeMoney(-bet, 'slot-cost');

    // Determine win
    
    let winMult = 0;
    const triple = (a===b && b===c);
    if(triple){
      if(a==='7Ô∏è‚É£') winMult = 20;
      else if(a==='‚≠ê') winMult = 10;
      else if(a==='üîî') winMult = 6;
      else if(a==='üçí') winMult = 4;
    }else{
      // Pairs (more realistic)
      if(a===b || a===c || b===c){
        const pairSym = (a===b||a===c)? a : b;
        if(pairSym==='7Ô∏è‚É£') winMult = 3;
        else if(pairSym==='‚≠ê') winMult = 2;
        else if(pairSym==='üîî') winMult = 1;
        else if(pairSym==='üçí') winMult = 1;
      }
      // Cherry on first reel: refund if still no win
      if(winMult===0 && a==='üçí') winMult = 1;
    }
    const win = winMult * bet;

    if(win>0){
      changeMoney(win, 'slot-win');
    }
    // Log
    const reelsHTML = `<span class="logpiece">${a} ${b} ${c}</span>`;
    if(win>0){
      const detail = winMult ? ` (${winMult}√ó on ¬£${bet})` : '';
      pushLog({ html: `Fruit machine ${reelsHTML} ‚Üí <span class="logpiece tmoney">+¬£${win}</span>${detail}` });
    }else{
      pushLog({ html: `Fruit machine ${reelsHTML} ‚Üí ${'<span class="logpiece tbad">No win</span>'}` });
    }
    scheduleSave();
    return { paid:true, win };
  }

  function doSlotSpin(){
    const [r1,r2,r3] = spinReels();
    const reels = document.getElementById('reels');
    if(reels) reels.textContent = `${r1} ${r2} ${r3}`;
    
    try{ if(window.slot && typeof window.slot.visualSpin === 'function'){ window.slot.visualSpin([r1,r2,r3]); } }catch(e){}
const res = applySlotPayout(r1,r2,r3);
    const msg = document.getElementById('slotMsg');
    if(msg){
      if(res.paid){
        msg.textContent = res.win>0 ? `You won ¬£${res.win}!` : `No win this time.`;
      }else{
        msg.textContent = `You need at least ¬£${getBet()} to spin.`;
      }
    }
    updateUI();
  }

  function doAutoSpins(n=10){
    let i = 0;
    function step(){
      if(i>=n) return;
      if((state.money|0) < 1) return;
      doSlotSpin();
      i++;
      setTimeout(step, 180); // quick cadence
    }
    step();
  }

  function bindGamblingUI(){
    if(gamblingBound) return;
    const b1 = document.getElementById('btnTier1');
    const b2 = document.getElementById('btnTier2');
    const b3 = document.getElementById('btnTier3');
    if(b1 && !b1.dataset.bound){ b1.addEventListener('click', ()=> setTier(1)); b1.dataset.bound='1'; 
    // Bind roulette controls when Tier 2 is active
    try{ if(document.getElementById('tier-2') && !document.getElementById('tier-2').classList.contains('hidden')) bindRouletteUI(); }catch(e){}
}
    
function doDemoSpin(){
  // Free, silent spin for UI/demo purposes
  const [r1,r2,r3] = spinReels();
  const reels = document.getElementById('reels');
  if(reels) reels.textContent = `${r1} ${r2} ${r3}`;
  try{ if(window.slot && typeof window.slot.visualSpin === 'function'){ window.slot.visualSpin([r1,r2,r3]); } }catch(e){}
  const msg = document.getElementById('slotMsg');
  if(msg){ msg.textContent = 'Demo spin (free) ‚Äî try your luck!'; }
  // No payout / money change / log
}
if(b2 && !b2.dataset.bound){ b2.addEventListener('click', ()=> setTier(2)); b2.dataset.bound='1'; }
    if(b3 && !b3.dataset.bound){ b3.addEventListener('click', ()=> setTier(3)); b3.dataset.bound='1'; }

    const spinBtn = document.getElementById('spinBtn');
    const autoBtn = document.getElementById('spinAutoBtn');
    if(spinBtn && !spinBtn.dataset.bound){
  spinBtn.addEventListener('click', ()=>{ try{ window.__lastUserGestureAt = (performance&&performance.now?performance.now():Date.now()); }catch(e){}; doSlotSpin(); });
  spinBtn.dataset.bound='1';
}
    if(autoBtn && !autoBtn.dataset.bound){ autoBtn.addEventListener('click', ()=> doAutoSpins(10)); autoBtn.dataset.bound='1'; }
    const betInput = document.getElementById('betInput');
    if(betInput && !betInput.dataset.bound){ betInput.addEventListener('input', setSpinCostLabel); betInput.dataset.bound='1'; }

    gamblingBound = true;
  
    // Bind roulette controls when Tier 2 is active
    try{ if(document.getElementById('tier-2') && !document.getElementById('tier-2').classList.contains('hidden')) bindRouletteUI(); }catch(e){}
}

  // Render hook when switching tabs
  const _origSetActiveTab = window.setActiveTab;
  window.setActiveTab = function(id){
    if(typeof _origSetActiveTab === 'function'){ _origSetActiveTab(id); }
    if(id === 'gambling'){
      // sync visible balance
      const balEl = document.getElementById('gambleBalance');
      if(balEl) balEl.textContent = String(state.money|0);
      setSpinCostLabel();
      bindGamblingUI();
      setTimeout(()=>{ try{ doDemoSpin(); }catch(e){} }, 0);
    }
  };

  // Keep gambling balance in sync on updateUI
  const _origUpdateUI = window.updateUI;
  window.updateUI = function(){
    if(typeof _origUpdateUI === 'function'){ _origUpdateUI(); }
    try{
      const balEl = document.getElementById('gambleBalance');
      if(balEl) balEl.textContent = String(state.money|0);
      const rbal = document.getElementById('rouletteBalance'); if(rbal) rbal.textContent = String(state.money|0);
      setSpinCostLabel();
    }catch(e){}
  };

  // === ROULETTE (Tier 2) =====================================================
  let rouletteBound = false;
  let rouletteLastBets = [];
  let rouletteHistory = [];

  const EU_SEQUENCE = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
  const REDS = new Set([32,19,21,25,34,27,36,30,23,5,16,1,14,9,18,7,12,3]);
  function isRed(n){ return REDS.has(n); }
  function isBlack(n){ return n!==0 && !REDS.has(n); }

  function buildRouletteTable(){
    const table = document.getElementById('rouletteTable');
    if(!table || table.dataset.built) return;
    table.dataset.built = '1';
    // Build 3 rows x 12 columns grid for numbers + zero + outside bets
    // First column reserved for 0 spanning rows
    // Numbers rows: 3..36 descending each column mod 3
    const frag = document.createDocumentFragment();
    // Zero
    const zero = document.createElement('div');
    zero.className = 'rt-cell rt-zero';
    zero.textContent = '0';
    zero.dataset.type = 'straight'; zero.dataset.value = '0';
    frag.appendChild(zero);

    // Number grid 1..36 laid out like standard table (rows 3-36)
    const nums = [];
    for(let r=0;r<3;r++){
      for(let c=0;c<12;c++){
        const n = (3*(c+1)) - r; // 3,6,9... top row; 2nd row 2,5,8; bottom 1,4,7
        nums.push(n);
        const d = document.createElement('div');
        d.className = 'rt-cell rt-num ' + (isRed(n)?'rt-red':'rt-black');
        d.textContent = String(n);
        d.dataset.type = 'straight';
        d.dataset.value = String(n);
        frag.appendChild(d);
      }
    }
    // Outside bets row(s)
    const outLabels = [
      { key:'1-12', label:'1st 12', type:'dozen', covers: Array.from({length:12},(_,i)=>i+1) },
      { key:'13-24', label:'2nd 12', type:'dozen', covers: Array.from({length:12},(_,i)=>i+13) },
      { key:'25-36', label:'3rd 12', type:'dozen', covers: Array.from({length:12},(_,i)=>i+25) },
      { key:'col1', label:'Column 1', type:'column', covers: Array.from({length:12},(_,i)=>1+3*i) },
      { key:'col2', label:'Column 2', type:'column', covers: Array.from({length:12},(_,i)=>2+3*i) },
      { key:'col3', label:'Column 3', type:'column', covers: Array.from({length:12},(_,i)=>3+3*i) },
      { key:'red', label:'Red', type:'even', covers: Array.from({length:36},(_,i)=>i+1).filter(isRed) },
      { key:'black', label:'Black', type:'even', covers: Array.from({length:36},(_,i)=>i+1).filter(isBlack) },
      { key:'odd', label:'Odd', type:'even', covers: Array.from({length:36},(_,i)=>i+1).filter(n=>n%2===1) },
      { key:'even', label:'Even', type:'even', covers: Array.from({length:36},(_,i)=>i+1).filter(n=>n%2===0) },
      { key:'low', label:'Low 1-18', type:'even', covers: Array.from({length:18},(_,i)=>i+1) },
      { key:'high', label:'High 19-36', type:'even', covers: Array.from({length:18},(_,i)=>i+19) }
    ];
    outLabels.forEach(cfg=>{
      const d = document.createElement('div');
      d.className = 'rt-cell rt-out';
      d.textContent = cfg.label;
      d.dataset.type = cfg.type;
      d.dataset.value = cfg.key;
      frag.appendChild(d);
    });
    table.appendChild(frag);
  }

  function getChip(){
    const el = document.getElementById('rouletteChip');
    let v = parseInt(el?.value||'1',10);
    if(!Number.isFinite(v) || v<1) v = 1;
    return v|0;
  }
  function updateRouletteTotals(){
    const tot = rouletteBets.reduce((s,b)=>s+b.amount,0);
    const el = document.getElementById('rouletteTotal');
    if(el) el.textContent = String(tot);
  }
  function renderPlacedBets(){
    const ul = document.getElementById('rouletteBets');
    if(!ul) return;
    ul.innerHTML='';
    rouletteBets.forEach((b,idx)=>{
      const li = document.createElement('li');
      li.innerHTML = `<span>${b.label}</span> <span>¬£${b.amount}</span>`;
      li.className = 'row';
      li.style.justifyContent='space-between';
      li.style.cursor='pointer';
      li.title = 'Click to remove this bet';
      li.addEventListener('click', ()=>{ rouletteBets.splice(idx,1); updateRouletteTotals(); renderPlacedBets(); });
      ul.appendChild(li);
    });
  }

  const PAYOUTS = {
    'straight': 35,
    'dozen': 2,
    'column': 2,
    'even': 1
  };

  let rouletteBets = [];

  function addBet(type, value, label, covers){
    const chip = getChip();
    rouletteBets.push({ type, value, label, covers, amount: chip });
    updateRouletteTotals();
    renderPlacedBets();
  }

  function bindRouletteTable(){
    const table = document.getElementById('rouletteTable');
    if(!table || table.dataset.bound) return;
    table.dataset.bound='1';
    table.addEventListener('click', (e)=>{
      const cell = e.target.closest('.rt-cell');
      if(!cell) return;
      const type = cell.dataset.type;
      const value = cell.dataset.value;
      if(type==='straight'){
        const n = parseInt(value,10);
        addBet('straight', n, `Straight ${n}`, [n]);
      }else if(type==='dozen'){
        const start = (value==='1-12')?1:(value==='13-24')?13:25;
        const covers = Array.from({length:12},(_,i)=>start+i);
        addBet('dozen', value, cell.textContent, covers);
      }else if(type==='column'){
        const colIndex = (value==='col1')?1:(value==='col2')?2:3;
        const covers = Array.from({length:12},(_,i)=>colIndex+3*i);
        addBet('column', value, cell.textContent, covers);
      }else if(type==='even'){
        let covers=[];
        if(value==='red') covers = Array.from({length:36},(_,i)=>i+1).filter(isRed);
        else if(value==='black') covers = Array.from({length:36},(_,i)=>i+1).filter(isBlack);
        else if(value==='odd') covers = Array.from({length:36},(_,i)=>i+1).filter(n=>n%2===1);
        else if(value==='even') covers = Array.from({length:36},(_,i)=>i+1).filter(n=>n%2===0);
        else if(value==='low') covers = Array.from({length:18},(_,i)=>i+1);
        else if(value==='high') covers = Array.from({length:18},(_,i)=>i+19);
        addBet('even', value, cell.textContent, covers);
      }
    });
  }

  // Canvas wheel + spin
  let wheelAngle = 0;
  let ballAngle = 0;
  let spinning = false;

  function drawWheel(ctx, cx, cy, radius){
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    const sectors = EU_SEQUENCE.length;
    const step = (Math.PI*2)/sectors;
    // Wheel
    for(let i=0;i<sectors;i++){
      const ang = wheelAngle + i*step;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,radius, ang, ang+step);
      ctx.closePath();
      const n = EU_SEQUENCE[i];
      if(n===0) ctx.fillStyle = '#073b4c';
      else ctx.fillStyle = isRed(n)?'#a11a1a':'#1f2937';
      ctx.fill();
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(ang+step/2);
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='#e5e7eb';
      ctx.font='bold 12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillText(String(n), radius*0.78, 0);
      ctx.restore();
    }
    // Rim
    ctx.beginPath();
    ctx.arc(cx,cy,radius,0,Math.PI*2);
    ctx.lineWidth=6; ctx.strokeStyle='#0f172a'; ctx.stroke();

    // Ball
    const ballR = radius*0.9;
    const bx = cx + Math.cos(ballAngle)*ballR;
    const by = cy + Math.sin(ballAngle)*ballR;
    ctx.beginPath();
    ctx.arc(bx,by,6,0,Math.PI*2);
    ctx.fillStyle='#fbbf24'; ctx.fill();
    ctx.strokeStyle='#111827'; ctx.lineWidth=2; ctx.stroke();
  }

  
  function spinRoulette(callback){
    if(spinning) return;
    const canvas = document.getElementById('rouletteCanvas');
    const msg = document.getElementById('rouletteMsg');
    const ctx = canvas?.getContext('2d');
    if(!canvas || !ctx) return;
    spinning = true;

    const sectors = EU_SEQUENCE.length;
    const step = (Math.PI*2)/sectors;

    // Random fair winning pocket
    const winIndex = Math.floor(Math.random()*sectors);
    const winNumber = EU_SEQUENCE[winIndex];

    // Physics-inspired params
    const totalDuration = 5500 + Math.floor(Math.random()*1800); // ~5.5s‚Äì7.3s
    const start = performance.now();

    // Independent angular velocities (rad/s). Ball opposite spin.
    let wheelVel = 6 + Math.random()*2;      // ~6‚Äì8 rad/s (CCW)
    let ballVel  = -(16 + Math.random()*6);  // ~-16 to -22 rad/s (CW, opposite)

    // Friction coefficients per second (we'll apply exponentially by dt)
    const wheelFriction = 0.85 + Math.random()*0.04; // effective multiplier per second
    const ballFriction  = 0.78 + Math.random()*0.05; // ball slows faster

    let captured = false;
    let lastT = start;

    function frame(now){
      const elapsed = now - start;
      const dt = Math.max(0.001, (now - lastT) / 1000); // seconds
      lastT = now;

      // Exponential friction (v *= f^(dt))
      wheelVel *= Math.pow(wheelFriction, dt);
      ballVel  *= Math.pow(ballFriction,  dt);

      // Integrate angles
      wheelAngle += wheelVel * dt;
      ballAngle  += ballVel  * dt;

      // Normalize
      if(wheelAngle > Math.PI*2 || wheelAngle < -Math.PI*2) wheelAngle %= (Math.PI*2);
      if(ballAngle  > Math.PI*2 || ballAngle  < -Math.PI*2)  ballAngle  %= (Math.PI*2);

      // Capture phase: once ball slow enough OR near the end
      const nearEnd = elapsed > totalDuration * 0.7;
      if(!captured && (Math.abs(ballVel) < 1.0 || nearEnd)){
        captured = true;
        // From here, steer ball to the target pocket center over the remainder time
        const remain = Math.max(400, totalDuration - elapsed); // at least 0.4s to settle
        const startBallAngle = ballAngle;
        const startWheelAngle = wheelAngle;
        const targetAngle = () => (wheelAngle + winIndex*step + step/2);

        const settleStart = now;
        const settleEnd = now + remain;

        function settleFrame(ts){
          // Update wheel with a gentle tail decel
          const dt2 = Math.max(0.001, (ts - lastT) / 1000);
          lastT = ts;
          wheelVel *= Math.pow(wheelFriction, dt2);
          wheelAngle += wheelVel * dt2;

          const t = Math.min(1, (ts - settleStart) / (settleEnd - settleStart));
          const ease = 1 - Math.pow(1 - t, 3); // easeOutCubic
          const target = targetAngle();

          // Interpolate ball toward target with slight overshoot + damping rattle
          const base = startBallAngle + (target - startBallAngle) * ease;
          const rattle = (1 - t) * 0.06 * Math.sin(18 * t * Math.PI); // decaying small oscillation
          ballAngle = base + rattle;

          drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);
          if(t < 1){
            requestAnimationFrame(settleFrame);
          }else{
            // Snap exactly to pocket center
            ballAngle = target;
            drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);
            spinning = false;
            callback && callback(winNumber);
          }
        }
        requestAnimationFrame(settleFrame);
        return;
      }

      drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);

      if(elapsed < totalDuration){
        requestAnimationFrame(frame);
      }else{
        // Failsafe: ensure we enter capture if somehow skipped
        if(!captured){
          captured = true;
          const target = wheelAngle + winIndex*step + step/2;
          ballAngle = target;
          drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);
        }
        spinning = false;
        callback && callback(winNumber);
      }
    }
    requestAnimationFrame(frame);
  }

  function settleRoulette(win){
    let totalStake = rouletteBets.reduce((s,b)=>s+b.amount,0);
    if((state.money|0) < totalStake){
      pushLog('' + `<span class="logpiece tbad">Insufficient funds (¬£${totalStake})</span>`);
      const m = document.getElementById('rouletteMsg'); if(m) m.textContent = `You need ¬£${totalStake} to spin.`;
      return false;
    }
    // Pay cost
    changeMoney(-totalStake, 'roulette-stake');
    let totalWin = 0;
    rouletteBets.forEach(b=>{
      if(win!==0 && b.type==='straight' && b.covers.includes(win)) totalWin += b.amount*(PAYOUTS.straight+1);
      else if(win!==0 && b.type==='dozen' && b.covers.includes(win)) totalWin += b.amount*(PAYOUTS.dozen+1);
      else if(win!==0 && b.type==='column' && b.covers.includes(win)) totalWin += b.amount*(PAYOUTS.column+1);
      else if(b.type==='even'){
        // Even-money bets lose on 0
        if(win!==0 && b.covers.includes(win)) totalWin += b.amount*(PAYOUTS.even+1);
      }
    });
    if(totalWin>0) changeMoney(totalWin, 'roulette-payout');
    const net = totalWin - totalStake;
    const resultMsg = net>=0 ? `<span class="tgood">WIN ¬£${totalWin} (net +¬£${net})</span>` : `<span class="tbad">LOSE (net -¬£${-net})</span>`;
    pushLog('' + `Roulette ‚Äî result: <strong>${win}</strong> ‚Ä¢ ${resultMsg}`);
    const m = document.getElementById('rouletteMsg');
    if(m) m.innerHTML = `Result: <strong>${win}</strong>. ${net>=0?'You won':'You lost'} ¬£${Math.abs(net)}.`;
    // History
    rouletteHistory.unshift(win);
    rouletteHistory = rouletteHistory.slice(0,10);
    const h = document.getElementById('rouletteHistory');
    if(h) h.textContent = rouletteHistory.join(', ');
    // Rebet memory
    rouletteLastBets = rouletteBets.map(x=>Object.assign({},x));
    // Clear current bets
    rouletteBets = [];
    updateRouletteTotals();
    renderPlacedBets();
    updateUI();
    return true;
  }

  function bindRouletteUI(){
    if(rouletteBound) return;
    rouletteBound = true;
    buildRouletteTable();
    bindRouletteTable();
    const spin = document.getElementById('rouletteSpin');
    const clearBtn = document.getElementById('rouletteClear');
    const rebetBtn = document.getElementById('rouletteRebet');
    const canvas = document.getElementById('rouletteCanvas');
    const ctx = canvas?.getContext('2d');
    if(ctx) drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);
    if(spin && !spin.dataset.bound){
      spin.addEventListener('click', ()=>{
        if(rouletteBets.length===0){
          const m = document.getElementById('rouletteMsg'); if(m) m.textContent = 'Place at least one bet.';
          return;
        }
        spinRoulette((win)=> settleRoulette(win));
      });
      spin.dataset.bound='1';
    }
    if(clearBtn && !clearBtn.dataset.bound){
      clearBtn.addEventListener('click', ()=>{ rouletteBets = []; updateRouletteTotals(); renderPlacedBets(); const m=document.getElementById('rouletteMsg'); if(m) m.textContent=''; });
      clearBtn.dataset.bound='1';
    }
    if(rebetBtn && !rebetBtn.dataset.bound){
      rebetBtn.addEventListener('click', ()=>{
        rouletteBets = rouletteLastBets.map(x=>Object.assign({},x));
        updateRouletteTotals(); renderPlacedBets();
      });
      rebetBtn.dataset.bound='1';
    }
  }
})();
// ============================================================================
</script>
<script>
// === Canvas Slot Machine (Reel Strip + Timeline Stops, v5) ===================
document.addEventListener('DOMContentLoaded', function(){
  if (window.__slotCanvasInit) return; window.__slotCanvasInit = true;
  const canvas = document.getElementById('slotCanvas');
  const frame = document.getElementById('slotCanvasFrame');
  if(!canvas || !frame) return;
  const ctx = canvas.getContext('2d');
  const wrap = frame.closest('.slotCanvas-wrap');
  let __suppressDemoMsg = false;


  // Geometry (responsive)
  let W = 0, H = 0;
  const reelsCount = 3;
  let reelGap = 18;
  let reelW = 0;
  let reelH = 0;
  let symbolH = 64;
  let spacing = 14;
  let cellH = 64+14;
  let centerY = 0;
  let CENTER_BASE = 0; // align symbol center to payline
  let PAD = 10;
  let offsetX = 0; // horizontal centering offset        // inner vertical padding for the window
  const ASPECT = 140/360; // keep look similar to original

  function recalcGeometry(){
    // Fit canvas width to frame; height from aspect
    const bw = Math.max(0, (frame.getBoundingClientRect?.().width || frame.clientWidth || canvas.clientWidth || 360));
    const targetW = Math.max(340, Math.round(bw));
    const targetH = Math.max(140, Math.round(targetW * ASPECT));
    canvas.width = targetW;
    canvas.height = targetH;
    frame.style.height = targetH + 'px';
    __lastMeasuredW = targetW; __lastMeasuredH = targetH;

    W = targetW; H = targetH;
    reelGap = Math.max(10, Math.round(W * 0.02)); // ~2% of width
    reelW = Math.round((W - reelGap*(reelsCount-1)) / reelsCount);
    reelH = H;
    HPAD = 0; // flush to edges
    const innerW = Math.max(0, W - HPAD*2);
    // Compute reel width from inner window, not full canvas
    reelW = Math.floor((innerW - reelGap*(reelsCount-1)) / reelsCount);
    let used = reelW*reelsCount + reelGap*(reelsCount-1);
    const remainder = Math.max(0, innerW - used);
    // Align to left inner padding; we'll distribute remainder across reels
    offsetX = HPAD;
    window.__slotRemainder = remainder;
    PAD = Math.max(6, Math.round(H * 0.06));      // subtle top/bottom padding
    // Make the fruits fill most of the window height
    symbolH = Math.max(44, Math.round((H - PAD*2) * 0.72));
    spacing = Math.max(6, Math.round((H - PAD*2) * 0.08));
    cellH = symbolH + spacing;
    centerY = Math.floor(H/2);
    CENTER_BASE = PAD + (symbolH/2) - centerY;
  }

  // Simple debounce
  function _debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }


  // Track last measured size to avoid unnecessary work
  let __lastMeasuredW = 0, __lastMeasuredH = 0;

  recalcGeometry();
  window.addEventListener('resize', _debounce(()=>{ recalcGeometry(); }, 80));
  window.addEventListener('orientationchange', ()=>{ setTimeout(recalcGeometry, 50); setTimeout(recalcGeometry, 250); });

  // Use ResizeObserver to react to container resizes (more reliable than window resize)
  try{
    const ro = new ResizeObserver(()=>{ recalcGeometry(); });
    ro.observe(frame);
  }catch(e){ /* older browsers */ }

  // Stage a couple of recalcs after the first paint ‚Äî helps when layout CSS applies late
  requestAnimationFrame(()=> recalcGeometry());
  setTimeout(()=> recalcGeometry(), 120);
  setTimeout(()=> recalcGeometry(), 400);

// align symbol center to payline

  // Vector fruit drawing
  function drawFruit(kind, x, y, scale=1, blur=0){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    if(blur>0){ ctx.filter = `blur(${blur}px)`; }
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    if(kind===0){ // cherry
      ctx.fillStyle = '#e11d48'; ctx.beginPath(); ctx.arc(-10,8,10,0,Math.PI*2); ctx.arc(10,8,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#16a34a'; ctx.beginPath(); ctx.moveTo(0,-12); ctx.quadraticCurveTo(-10,-24,-20,-8); ctx.quadraticCurveTo(-2,-10,0,-12); ctx.quadraticCurveTo(10,-24,20,-8); ctx.quadraticCurveTo(2,-10,0,-12); ctx.fill(); ctx.stroke();
    }else if(kind===1){ // lemon
      ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.ellipse(0,0,22,16,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }else if(kind===2){ // bell
      ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(-18,0); ctx.quadraticCurveTo(-20,-18,0,-22); ctx.quadraticCurveTo(20,-18,18,0); ctx.lineTo(18,8); ctx.quadraticCurveTo(0,16,-18,8); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#7c3aed'; ctx.beginPath(); ctx.arc(0,10,5,0,Math.PI*2); ctx.fill();
    }else if(kind===3){ // star
      ctx.fillStyle = '#eab308'; ctx.beginPath();
      for(let i=0;i<5;i++){ const a=(i*72-90)*Math.PI/180; const ax=Math.cos(a)*18, ay=Math.sin(a)*18; const b=a+36*Math.PI/180; const bx=Math.cos(b)*8, by=Math.sin(b)*8; if(i===0) ctx.moveTo(ax,ay); else ctx.lineTo(ax,ay); ctx.lineTo(bx,by); }
      ctx.closePath(); ctx.fill(); ctx.stroke();
     }else if(kind===4){ // seven
      // Option A (default): crisp vector '7' drawn as a filled polygon (no strokes -> no AA glitches)
      if(!window.slotUseEmojiSeven){
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        // shadow for depth
        ctx.shadowColor = 'rgba(0,0,0,0.25)';
        ctx.shadowBlur = 6;
        // red fill
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        // Top bar
        ctx.moveTo(-18,-18);
        ctx.lineTo(18,-18);
        // Knee to diagonal
        ctx.lineTo(8,-6);
        // Diagonal leg
        ctx.lineTo(-4,18);
        ctx.lineTo(-14,18);
        // Inner notch to give a classic 7 shape
        ctx.lineTo(-2,-2);
        ctx.lineTo(-18,-2);
        ctx.closePath();
        ctx.fill();

        // subtle highlight
        const g = ctx.createLinearGradient(-18,-20,18,-4);
        g.addColorStop(0,'rgba(255,255,255,0.18)');
        g.addColorStop(1,'rgba(255,255,255,0.0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(-18,-18);
        ctx.lineTo(18,-18);
        ctx.lineTo(8,-6);
        ctx.lineTo(-2,-6);
        ctx.closePath();
        ctx.fill();
      } else {
        // Option B: system emoji '7Ô∏è‚É£' (may vary by OS, but some users prefer it)
        ctx.shadowColor = 'rgba(0,0,0,0.30)';
        ctx.shadowBlur = 8;
        ctx.font = '46px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('7Ô∏è‚É£', 0, 0);
      }
    } else{ // clover
      ctx.fillStyle = '#16a34a'; for(let i=0;i<4;i++){ const a=(i*90)*Math.PI/180; ctx.beginPath(); ctx.arc(Math.cos(a)*10, Math.sin(a)*10, 8, 0, Math.PI*2); ctx.fill(); }
      ctx.fillRect(-4,-2,8,16);
    }
    ctx.restore();
  }

  // Build per-reel strips
  const WEIGHTED = [0,0,0,1,1,2,2,3,4,5,6,7];
  function buildStrip(len=64){
    const strip = [];
    while(strip.length < len){ strip.push(WEIGHTED[Math.floor(Math.random()*WEIGHTED.length)]); }
    for(let s=0;s<8;s++){ if(!strip.includes(s)){ strip[Math.floor(Math.random()*strip.length)] = s; } }
    return strip;
  }
  const STRIPS = Array.from({length:3}, ()=> buildStrip(64));
  const STRIP_LEN = STRIPS[0].length;

  // Mapping between indices and emojis for external sync
  const IDX_TO_EMOJI = ["üçí","üçã","üîî","‚≠ê","7Ô∏è‚É£","üçá","üçâ","üçÄ"];
  const EMOJI_TO_IDX = Object.fromEntries(IDX_TO_EMOJI.map((e,i)=>[e,i]));

  function normalizeOutcomeArray(arr){
    if(!Array.isArray(arr)) return null;
    if(arr.length < 3) return null;
    // If it's numbers:
    if(typeof arr[0] === 'number') return arr.slice(0,3).map(x=> (x|0)%8);
    // If it's strings/emojis:
    return arr.slice(0,3).map(v=> (v in EMOJI_TO_IDX) ? EMOJI_TO_IDX[v] : 0);
  }
  function toEmoji(arr){ return arr.map(i=> IDX_TO_EMOJI[i%8]); }


  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  class Reel {
    constructor(index){
      this.index = index;
      this.basePos = 0;      // px at spin start
      this.pos = 0;          // px (live)
      this.state = 'idle';
      this.t0 = 0;           // spin start time
      this.tAccel = 0;       // end of accel
      this.tCruise = 0;      // end of cruise
      this.tEnd = 0;         // end of decel (final)
      this.maxVel = 2800 + 200*index; // small variance per reel
      this.blur = 0;
      this.targetSymbol = 0;
      this.targetAbsCell = 0;
      this.posAtDecel = 0;
    }
    currentCell(){
      const cell = Math.floor(((this.pos - CENTER_BASE) / cellH)) % STRIP_LEN;
      return (cell + STRIP_LEN) % STRIP_LEN;
    }
    schedule(now, {delay=0, accelMs=500, cruiseMs=1200, decelMs=900}, targetSymbol, extraTurns){
      this.t0 = now + delay;
      this.tAccel = this.t0 + accelMs;
      this.tCruise = this.tAccel + cruiseMs;
      this.tEnd = this.tCruise + decelMs;
      this.state = 'accel';
      this.blur = 0;
      this.basePos = this.pos;
      this.targetSymbol = targetSymbol;

      // compute landing
      const baseCell = this.currentCell();
      const strip = STRIPS[this.index];
      const startIdx = (baseCell + extraTurns * STRIP_LEN) % STRIP_LEN;
      let found = -1;
      for(let i=0;i<STRIP_LEN;i++){
        const idx = (startIdx + i) % STRIP_LEN;
        if(strip[idx] === targetSymbol){ found = (baseCell + extraTurns*STRIP_LEN + i); break; }
      }
      if(found < 0){ found = baseCell + extraTurns*STRIP_LEN; }
      this.targetAbsCell = found;
      const stopAt = this.pos + (this.targetAbsCell - baseCell) * cellH + CENTER_BASE;
      this.stopAt = stopAt;
      this.posAtDecel = 0; // will capture when decel starts
    }
    isSpinning(){ return this.state !== 'idle'; }
    symbolAtCenter(){
      const cell = Math.round(((this.pos - CENTER_BASE)/cellH)) % STRIP_LEN;
      const idx = (cell + STRIP_LEN) % STRIP_LEN;
      return STRIPS[this.index][idx];
    }
    update(now, dt){
      if(this.state === 'idle') return;
      if(now < this.t0) return; // delay window

      // phase switching
      if(now >= this.tEnd){
        // hard stop
        const cells = Math.round((this.stopAt - CENTER_BASE)/cellH);
        this.pos = cells * cellH + CENTER_BASE;
        this.state = 'idle';
        this.blur = 0;
        return;
      } else if(now >= this.tCruise){
        if(this.state !== 'decel'){
          this.state = 'decel';
          this.posAtDecel = this.pos;
        }
      } else if(now >= this.tAccel){
        this.state = 'cruise';
      }

      // integrate per phase
      if(this.state === 'accel'){
        // accelerate up to maxVel
        const k = Math.min(1, (now - this.t0) / (this.tAccel - this.t0));
        const v = this.maxVel * k;
        this.pos += v * dt;
        this.blur = Math.min(1.4, this.blur + 2.0*dt);
      } else if(this.state === 'cruise'){
        const v = this.maxVel;
        this.pos += v * dt;
        this.blur = 1.2;
      } else if(this.state === 'decel'){
        const p = Math.min(1, (now - this.tCruise) / (this.tEnd - this.tCruise));
        const eased = easeOutCubic(p);
        const target = this.stopAt;
        const start = this.posAtDecel;
        this.pos = start + (target - start) * eased;
        this.blur = Math.max(0, 1.2 * (1 - eased));
      }

      const loop = cellH * STRIP_LEN;
      if(this.pos > 1e9) this.pos = this.pos % loop; // keep number sane
    }
    draw(x, w = reelW){
      const reelHLocal = reelH;
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(x, 10, reelW, reelHLocal-20, 10);
      ctx.clip();

      // bg per reel
      const grad = ctx.createLinearGradient(0,PAD,0,reelHLocal-PAD);
      grad.addColorStop(0,'#101a36'); grad.addColorStop(1,'#0a1128');
      ctx.fillStyle = grad; ctx.fillRect(x,PAD,w,reelHLocal-(PAD*2));

      const base = ((this.pos % (cellH*STRIP_LEN)) + (cellH*STRIP_LEN)) % (cellH*STRIP_LEN);
      const firstCell = Math.floor((base - 10)/cellH) - 2;
      const lastCell  = firstCell + Math.ceil((reelHLocal+40)/cellH) + 2;
      for(let k=firstCell; k<=lastCell; k++){
        const y = Math.floor(-base + k*cellH + PAD);
        const idx = (k % STRIP_LEN + STRIP_LEN) % STRIP_LEN;
        const blur = this.blur>0.05 ? this.blur : 0;
        drawFruit(STRIPS[this.index][idx], x + w/2, y + symbolH/2, 1, blur);
      }
      ctx.restore();
      // rim shadow
      const g = ctx.createLinearGradient(x,0,x+w,reelHLocal);
      g.addColorStop(0, 'rgba(0,0,0,0.35)');
      g.addColorStop(0.08, 'rgba(0,0,0,0)');
      g.addColorStop(0.92, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle = g; ctx.fillRect(x,0,w,reelHLocal);
    }
  }

  const reels = [...Array(reelsCount)].map((_,i)=> new Reel(i));

  // Money + UI helpers (with safe fallbacks)
  function getBet(){
    const el = document.getElementById("betInput");
    const n = Math.max(1, Math.floor(Number(el?.value||1)));
    if(el) el.value = n;
    const spinCost = document.getElementById("spinCost");
    if(spinCost) spinCost.textContent = String(n);
    return n;
  }
  function getMoney(){ try{ return (window?.state?.money|0) || 0; }catch(e){ return 0; } }
  function changeMoneySafe(delta, reason){
    try{ if(typeof window.changeMoney === "function"){ window.changeMoney(delta, reason); return; } }catch(e){}
    window.state = window.state || {}; window.state.money = (getMoney() + delta);
  }
  function updateGambleUI(){
    const b = document.getElementById("gambleBalance"); if(b) b.textContent = String(getMoney());
  }
  function setMsg(txt){
    const m = document.getElementById("slotMsg"); if(m) m.textContent = txt;
  }

  // Continuous RAF
  let last = performance.now();
  function rafLoop(now){
    // auto-correct geometry if frame size drifted
    const cw = Math.round(frame.getBoundingClientRect?.().width || frame.clientWidth || canvas.clientWidth || 0);
    const ch = Math.round(cw * ASPECT);
    if(cw && (cw !== __lastMeasuredW || ch !== __lastMeasuredH)){
      __lastMeasuredW = cw; __lastMeasuredH = ch;
      recalcGeometry();
    }
    const dt = Math.min(0.033, (now - last)/1000); last = now;
    for(const r of reels) r.update(now, dt);
    // backdrop
    const bg = ctx.createLinearGradient(0,0,0,H);
    bg.addColorStop(0,'#0b132a'); bg.addColorStop(1,'#0a0f22');
    ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);
    // reels
    
    let accX = offsetX;
    let rem = window.__slotRemainder|0;
    const baseExtra = Math.floor(rem / reelsCount);
    let mod = rem % reelsCount;
    for(let i=0;i<reelsCount;i++){
      const extra = baseExtra + (mod>0 ? 1 : 0);
      if(mod>0) mod--;
      const w = reelW + extra;
      reels[i].draw(accX, w);
      accX += w + reelGap;
    }

    // payline
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(0, centerY-1, W, 2);
    requestAnimationFrame(rafLoop);
  }
  requestAnimationFrame(rafLoop);

  function startSpin(demo=false){
    if(reels.some(r=> r.isSpinning())) return;
    const bet = getBet(), money = getMoney();
    let charge = false;
    if(!demo){
      if(money >= bet){ charge = true; }
      else demo = true;
    }
    if(charge){ changeMoneySafe(-bet, 'slot-reel-bet'); updateGambleUI(); }
    if(!(demo && __suppressDemoMsg)) setMsg(demo ? 'Demo spin‚Ä¶' : 'Spinning‚Ä¶');
    try{ wrap && wrap.classList.add('slot-pending'); }catch(e){}

    // Targets per reel (prefer external outcome if provided)
    let targets;
    const takePending = pendingOutcome; pendingOutcome = null;
    if(takePending){ targets = takePending; }
    else if(Array.isArray(window.slotOutcome)){ targets = normalizeOutcomeArray(window.slotOutcome); window.slotOutcome = null; }
    else if(typeof window.getFruitMachineOutcome === 'function'){ try{ targets = normalizeOutcomeArray(window.getFruitMachineOutcome()); }catch(e){} }
    if(!targets){
      const pool = [0,0,0,1,1,2,2,3,4,5,6,7];
      targets = [0,1,2].map(()=> pool[Math.floor(Math.random()*pool.length)]);
    }
const now = performance.now();
    const delays = [0, 150, 300];
    const cfgs = [
      { delay:delays[0], accelMs:520, cruiseMs:1200, decelMs:900 },
      { delay:delays[1], accelMs:520, cruiseMs:1400, decelMs:960 },
      { delay:delays[2], accelMs:520, cruiseMs:1600, decelMs:1020 },
    ];
    const turns = [6,7,8];
    for(let i=0;i<reelsCount;i++){
      reels[i].schedule(now, cfgs[i], targets[i], turns[i]);
    }

    // Finalize on stop (poll with absolute timeout)
    const tHardEnd = now + 10000; // 10s hard cap
    const poll = setInterval(()=>{
      const allIdle = reels.every(r=> !r.isSpinning());
      const over = performance.now() >= tHardEnd;
      if(allIdle || over){
        clearInterval(poll);
        // Force idle if timeout
        if(over){
          for(const r of reels){ r.state='idle'; r.blur=0; }
          setMsg('Recovered from long spin.');
        }
        if(!demo){
          const a = reels[0].symbolAtCenter(), b = reels[1].symbolAtCenter(), c = reels[2].symbolAtCenter();
          const bet2 = getBet();
          if(a===b && b===c){
            const mult = (a===4) ? 20 : (a===3 ? 10 : (a===2 ? 6 : 4));
            const win = mult * bet2; changeMoneySafe(win, "slot-win"); setMsg(`WIN! pays ${mult}√ó (¬£${win}).`); flashWin();
          } else if(a===b || b===c || a===c){
            const pair = a===b ? a : (b===c ? b : a);
            const mult = (pair===4) ? 3 : (pair===3 ? 2 : 1);
            const win = mult * bet2; changeMoneySafe(win, "slot-pair"); setMsg(`Pair! pays ${mult}√ó (¬£${win}).`); flashWin();
          } else if(a===0){
            changeMoneySafe(bet2, "slot-refund"); setMsg("Cherry up front! Bet refunded.");
          } else {
            setMsg("No win this time.");
          }
          updateGambleUI();
          try{ wrap && wrap.classList.remove('slot-pending'); }catch(e){} __suppressDemoMsg = false;
          __suppressDemoMsg = false;
          if(typeof window.onSlotResult === 'function'){
            try{ window.onSlotResult([a,b,c].map(x=> IDX_TO_EMOJI[x] ?? x)); }catch(e){}
          }
        } else {
          if(!__suppressDemoMsg) setMsg('Add credits to play for real.');
        try{ wrap && wrap.classList.remove('slot-pending'); }catch(e){} __suppressDemoMsg = false;
          __suppressDemoMsg = false;
        }
      }
    }, 80);
  }

  function flashWin(){
    frame.classList.remove('win'); void frame.offsetWidth; frame.classList.add('win');
    setTimeout(()=> frame.classList.remove('win'), 900);
  }

  // Buttons
  const spinBtn = document.getElementById('spinBtn');
  const autoBtn = document.getElementById('spinAutoBtn');
  /* unified: Spin button bound in main UI (doSlotSpin). Canvas won't bind it here. */
autoBtn?.addEventListener('click', async ()=>{
    for(let i=0;i<10;i++){
      startSpin(false);
      while(reels.some(r=> r.isSpinning())){ await new Promise(r=> setTimeout(r, 60)); }
      if(getMoney() < getBet()) break;
      await new Promise(r=> setTimeout(r, 140));
    }
  });

  // Credits fallback + auto demo
  if(typeof window.state === 'undefined'){ window.state = { money: 20 }; }
  if(getMoney() < 1){ window.state.money = 20; }
  updateGambleUI(); getBet();
  setTimeout(()=> startSpin(true), 500);

  // Expose API for external sync
  let pendingOutcome = null;
  function spinWithOutcome(outcome, opts={}){
    __suppressDemoMsg = !!opts.visualOnly;
    pendingOutcome = normalizeOutcomeArray(outcome);
    const visualOnly = !!opts.visualOnly;
    startSpin(visualOnly);
  }
  function visualSpin(outcome){ spinWithOutcome(outcome, {visualOnly:true}); }
  window.slot = { startSpin, spin: spinWithOutcome, visualSpin, reels, STRIPS, cellH, toEmoji, normalizeOutcomeArray };
  // === Activity Log Sync (passive) ======================================
  // Drive the canvas to match the Activity Log. We watch for new entries
  // that contain "Fruit machine" and parse the three symbols, then run a
  // visual-only spin to those outcomes (no balance or payouts changed).
  (function(){
    const EMOJI_SET = ["üçí","üçã","üîî","‚≠ê","7Ô∏è‚É£","üçá","üçâ","üçÄ"];
    const NUM_TO_SEVEN = {'7': '7Ô∏è‚É£'};
    let lastKey = null;
    let lastAt = 0;

    function extractTripleFromText(text){
      const m = text.match(/Fruit machine[\s\S]*?([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])[\s,]+([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])[\s,]+([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])/i);
      if(!m) return null;
      const arr = [m[1], m[2], m[3]].map(ch => NUM_TO_SEVEN[ch] || ch);
      if(!arr.every(x => EMOJI_SET.includes(x))) return null;
      return arr;
    }

    function scanAndSpin(){
      try{ if(reels && reels.some(r=> r.isSpinning())) return; }catch(e){}
// find the latest node containing "Fruit machine"
      const nodes = Array.from(document.querySelectorAll('body *')).filter(el => el.childElementCount === 0 && /Fruit machine/i.test(el.textContent||""));
      if(nodes.length === 0) return;
      const lastNode = nodes[nodes.length - 1];
      const text = lastNode.closest('*')?.textContent || lastNode.textContent || "";
      const trip = extractTripleFromText(text);
      if(!trip) return;
      const key = trip.join('|');
      const now = performance.now();
      if(key === lastKey && now - lastAt < 1500) return; // ignore duplicates
      lastKey = key; lastAt = now;
      // Spin visuals only to match the log outcome
      try{ visualSpin(trip); }catch(e){ /* no-op */ }
    }

    const mo = new MutationObserver((mutations) => {
      for(const m of mutations){
        if(m.type === 'childList' && (m.addedNodes?.length || m.removedNodes?.length)){
          scanAndSpin();
        } else if(m.type === 'characterData'){
          scanAndSpin();
        }
      }
    });
    mo.observe(document.body, { childList: true, characterData: true, subtree: true });

    // Initial attempt (in case the log is already present)
    setTimeout(scanAndSpin, 500);
  })();
  // ======================================================================


});
// ============================================================================
</script>
<script>
// === Delay 'Fruit machine' Activity Log until reels settle =====================
(function(){
  if(window.__slotLogDelay) return; window.__slotLogDelay = true;
  const FRUIT_RE = /Fruit machine\b/i;
  const EM_TRIPLE_RE = /([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])\s+([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])\s+([üçíüçãüîî‚≠ê7Ô∏è‚É£üçáüçâüçÄ7])/;
  const toSeven = {'7':'7Ô∏è‚É£'};
  const queue = [];
  let waiting = false;

  function enqueue(entry){
    queue.push(entry);
    if(!waiting){
      waiting = true;
      const once = (ev)=>{ try{ flush(); }finally{ window.removeEventListener('slot-settled', once); waiting=false; } };
      window.addEventListener('slot-settled', once, { once:true });
      // Hard fallback after 6s to avoid losing logs
      setTimeout(()=>{ if(waiting){ flush(); waiting=false; } }, 6000);
    }
  }
  function flush(){
    const _orig = window.__origPushLog;
    while(queue.length){ try{ _orig(queue.shift()); }catch(e){ break; } }
  }

  // Hook pushLog
  if(typeof window.pushLog === 'function' && !window.__origPushLog){
    window.__origPushLog = window.pushLog;
    window.pushLog = function(entry){
      const raw = (typeof entry==='string') ? entry : (entry && (entry.html||entry.text)||'');
      if(FRUIT_RE.test(String(raw))){
        enqueue(entry);
        // in case canvas didn't get a visual outcome yet, try to extract and drive
        try{
          const t = String(raw).replace(/<[^>]+>/g,'');
          const m = t.match(EM_TRIPLE_RE);
          if(m && window.slot && typeof window.slot.visualSpin === 'function'){
            const trip = [m[1],m[2],m[3]].map(ch=> toSeven[ch] || ch);
            window.slot.visualSpin(trip);
          }
        }catch(e){}
        return;
      }
      return window.__origPushLog.apply(this, arguments);
    };
  }
})();
// ==============================================================================
</script>
<script id="slot-debug-addon">
(function(){
  // Build a readable description of the current slot state
  function makeSlotDebugDesc(){
    try{
      const s = window.slot || {};
      const ctx = window.__slotCtx || {};
      // Safely find internals if available in closure scope via known globals we set
      const reels = window.slotReels || (typeof getReels === 'function' ? getReels() : null);
      const IDX = (window.IDX_TO_EMOJI || ["üçí","üçã","üîî","‚≠ê","7Ô∏è‚É£","üçá","üçâ","üçÄ"]);
      const parts = [];

      if (reels && reels.length) {
        const symbols = reels.map(r => IDX[r.symbolAtCenter?.() ?? 0]).join(' ');
        parts.push(`payline: ${symbols}`);
        parts.push(reels.map((r,i)=>{
          const cell = (typeof r.currentCell==='function') ? r.currentCell() : '?';
          const tgt  = (r.targetAbsCell!=null) ? (r.targetAbsCell % (window.STRIP_LEN||64)) : '?';
          const st   = r.state || 'idle';
          return `R${i+1}{st:${st},cell:${cell},tgt:${tgt}}`;
        }).join(' ¬∑ '));
      } else if (s.getLastResult) {
        parts.push(`payline: ${(s.getLastResult()||[]).join(' ')}`);
      } else {
        parts.push('payline: (unavailable)');
      }

      // Include basic geometry if exposed
      if (typeof window.slotGeom === 'function') {
        const g = window.slotGeom();
        parts.push(`W√óH:${g.W}√ó${g.H} reelW:${g.reelW} gap:${g.reelGap}`);
      }

      return `Fruit machine debug ‚Üí ${parts.join(' | ')}`;
    }catch(e){
      return `Fruit machine debug ‚Üí (error generating description: ${e&&e.message})`;
    }
  }

  // Expose on the slot API
  window.slot = window.slot || {};
  window.slot.debugDescription = makeSlotDebugDesc;

  // Optional helper to fetch geometry if the slot code exported it
  if (!window.slot.slotGeom && typeof window.slotGeom === 'function') {
    window.slot.slotGeom = window.slotGeom;
  }

  // Hook a Debug button if present
  function bindDebugButton(){
    var btn = document.getElementById('debugBtn') || document.querySelector('[data-debug-button]');
    if(!btn) return;
    if(btn.__slotDebugBound) return;
    btn.__slotDebugBound = true;
    btn.addEventListener('click', function(){
      var text = makeSlotDebugDesc();
      try{
        if (typeof window.pushLog === 'function') {
          pushLog({ html: `üîß ${text}` });
        } else {
          console.log(text);
          try { alert(text); } catch(e){}
        }
      }catch(e){
        console.log(text);
      }
    }, false);
  }

  // Try now and also after load
  bindDebugButton();
  document.addEventListener('DOMContentLoaded', bindDebugButton);
  setTimeout(bindDebugButton, 500);
})();
</script>
<!-- affordability-guard v1 -->
<style>
/* Visual + interaction lock when unaffordable */
#spinBtn[disabled], #spinAutoBtn[disabled],
#spinBtn[aria-disabled="true"], #spinAutoBtn[aria-disabled="true"]{
  opacity: .6; cursor: not-allowed; pointer-events: none;
}

/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<script>
/* Fruit Machine Affordability Guard (v1.5)
   - Drives disabled state from the UI balance (#gambleBalance) and bet input (#betInput)
   - Very light: a single MutationObserver on #gambleBalance text and an input listener on #betInput
   - Still blocks programmatic spin paths (doSlotSpin/startSpin/visualSpin) if unaffordable
*/
(function(){
  function getBetAmount(){
    const el = document.getElementById('betInput');
    let v = Number(el && el.value);
    if(!Number.isFinite(v)) v = 1;
    return Math.max(1, Math.floor(v));
  }
  function getUiMoney(){
    const el = document.getElementById('gambleBalance');
    const n = Number(el && el.textContent);
    return Number.isFinite(n) ? n : 0;
  }
  function canAfford(){ return getUiMoney() >= getBetAmount(); }
  function setDisabled(el, v){
    if(!el) return;
    // only change if needed (avoid loops)
    if(!!el.disabled !== !!v){ el.disabled = !!v; }
    const want = v ? 'true' : 'false';
    if(el.getAttribute('aria-disabled') !== want){ el.setAttribute('aria-disabled', want); }
    if(v){ el.tabIndex = -1; } else { el.tabIndex = 0; }
  }
  function updateButtons(){
  const spinBtn = document.getElementById('spinBtn');
  const autoBtn = document.getElementById('spinAutoBtn');
  const afford = canAfford();
  // Keep Spin clickable for demo spins; only disable Auto.
  setDisabled(autoBtn, !afford);
  if(spinBtn){
    // subtle styling/title to hint it's a demo when broke
    try{ spinBtn.classList.toggle('secondary', !afford); }catch(e){}
    try{ spinBtn.title = afford ? '' : 'Demo spin (free)'; }catch(e){}
  }
}

  // Keep buttons in sync with UI balance & bet changes
  function bindObservers(){
    const bal = document.getElementById('gambleBalance');
    if(bal && !bal.__obs){
      const obs = new MutationObserver(updateButtons);
      obs.observe(bal, { characterData: true, subtree: true, childList: true });
      bal.__obs = obs;
    }
    const bet = document.getElementById('betInput');
    if(bet && !bet.__bound){
      bet.addEventListener('input', updateButtons);
      bet.__bound = true;
    }
  }

  // Belt-and-braces: block programmatic spins
  function wrapEntryPoints(){
  try{
    if(typeof window.doSlotSpin === 'function' && !window.doSlotSpin.__wrapped){
      const _f = window.doSlotSpin;
      window.doSlotSpin = function(){
        // Allow user-initiated clicks to demo-spin when broke,
        // but still block programmatic spins without funds.
        const now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
        const recentGesture = (window.__lastUserGestureAt && (now - window.__lastUserGestureAt) < 1200);
        if(!canAfford() && !recentGesture){ return; }
        return _f.apply(this, arguments);
      };
      window.doSlotSpin.__wrapped = true;
    }
if(typeof window.doAutoSpins === 'function' && !window.doAutoSpins.__wrapped){
        const _a = window.doAutoSpins;
        window.doAutoSpins = function(n){
          if(!canAfford()){ return; }
          return _a.apply(this, arguments);
        };
        window.doAutoSpins.__wrapped = true;
      }
      if(typeof window.startSpin === 'function' && !window.startSpin.__wrapped){
        const _s = window.startSpin;
        window.startSpin = function(demo){
          if(!canAfford()){ return; }
          return _s.apply(this, arguments);
        };
        window.startSpin.__wrapped = true;
      }
      if(window.slot && typeof window.slot.visualSpin === 'function' && !window.slot.visualSpin.__wrapped){
        const _v = window.slot.visualSpin;
        window.slot.visualSpin = function(){
          if(!canAfford()){ return; }
          return _v.apply(this, arguments);
        };
        window.slot.visualSpin.__wrapped = true;
      }
    }catch(e){}
  }

  
function restoreTBLog(){
  try{
    if(window.__tbLogRestored) return;
    const el = document.getElementById('tbLog'); if(!el) return;
    let hist = (state.territory && state.territory.logHistory) || [];
    
    // Fallback: if no dedicated history, reconstruct recent battle lines from global Activity Log
    let list = hist;
    try{
      if((!hist || hist.length===0) && Array.isArray(state.log)){
        const cand = [];
        for(const it of state.log){
          const raw = (it && (it.html || it.text || '')).toString();
          if(/Wave\s+\d+\s*:/.test(raw) || /Tier\s+\d+\s+cleared/.test(raw) || /Region captured!/.test(raw)){
            cand.push({ ts: (it.ts||''), html: it.html || it.text });
            if(cand.length>=50) break;
          }
        }
        list = cand.reverse();
      }
    }catch(_){}

    if(list && list.length){
      const empty = document.getElementById('logEmpty'); if(empty){ empty.classList.add('hidden'); }
      // render oldest -> newest so that future tbLog() prepend keeps order
      for(const item of list){
        const li = document.createElement('li'); li.className='li';
        const ts = item.ts ? `<span class="ts">[${item.ts}]</span>` : '';
        li.innerHTML = ts + (item.html || '');
        el.appendChild(li);
      }
    }
    window.__tbLogRestored = true;
  }catch(e){}
}

function init(){
    bindObservers();
    updateButtons();
    wrapEntryPoints(); restoreTBLog(); }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  }else{
    init();
  }

  // Also re-run when the game's updateUI ticks
  try{
    const prev = window.updateUI;
    if(typeof prev === 'function' && !window.__affordHook){
      window.__affordHook = true;
      window.updateUI = function(){
        const r = prev.apply(this, arguments);
        try{ updateButtons(); wrapEntryPoints(); }catch(e){}
        return r;
      };
    }
  }catch(e){}
})();

// === Territory Battle & Combat Stats =======================================
(function(){
  // Extend default stats to include Strength and Toughness
  try{
    if(Array.isArray(DEFAULT_STATS)){
      if(!DEFAULT_STATS.includes('Strength')) DEFAULT_STATS.unshift('Strength');
      if(!DEFAULT_STATS.includes('Toughness')) DEFAULT_STATS.splice(1,0,'Toughness');
    }
  }catch(e){}

  // Extend equipped buff totals with strength/toughness adds
  const _origGetBuffs = typeof getEquippedBuffTotals === 'function' ? getEquippedBuffTotals : null;
  window.getEquippedBuffTotals = function(){
    const t = _origGetBuffs ? _origGetBuffs() : { moneyMult:0, heatGainMult:0, heatDecayMult:0, successAdd:{}, statXpMult:{} };
    t.strAdd = 0; t.toughAdd = 0;
    try{
      const items = getEquippedItems();
      for(const it of items){
        const mods = Array.isArray(it?.mods) ? it.mods : [];
        for(const m of mods){
          if(!m || typeof m!=='object') continue;
          if(m.kind==='strAdd') t.strAdd += Number(m.value)||0;
          if(m.kind==='toughAdd') t.toughAdd += Number(m.value)||0;
        }
      }
    }catch(e){}
    return t;
  };

  function getDerivedCombat(){
    const baseStr = (state.stats['Strength']?.level||0);
    const baseTgh = (state.stats['Toughness']?.level||0);
    const buffs = getEquippedBuffTotals();
    const strength = Math.max(0, Math.floor(baseStr + (buffs.strAdd||0)));
    const toughness = Math.max(0, Math.floor(baseTgh + (buffs.toughAdd||0)));
    const power = strength; // simple NGU-like: power == strength
    const hpMax = Math.max(30, power * 3);
    const regen = Math.max(0, toughness * 0.03); // HP per sec
    return { strength, toughness, power, hpMax, regen };
  }
  window.getDerivedCombat = getDerivedCombat;

  // Passive health regen (very slow, boosted by toughness)
  const PASSIVE_BASE = 0.01; // % per sec
  function passiveHealthRegen(dtSec){
    try{
      const { toughness } = getDerivedCombat();
      const bonusPctPerSec = Math.min(0.04, toughness * 0.001); // +0.1% per 100 toughness, cap +4%
      const pct = (PASSIVE_BASE + bonusPctPerSec) * dtSec * (state.vitals.health<100?1:0);
      if(pct>0){ addHealth(pct); }
    }catch(e){}
  }

  // Territory state (non-persistent)
  state.territory = state.territory || { tier:1, wave:1, active:false, enemy:null, lootQueue: [] };

  const ENEMY_NAMES = ['Street Thug','Rowdy Hooligan','Rival Grunt','Shifty Mugger','Pushy Enforcer','Crooked Brawler'];

  
  // Scale enemy by tier 1..6 and wave 1..10
  function scaleEnemy(tier, wave){
    const w = Math.max(1, Math.min(10, wave|0));
    const t = Math.max(1, Math.min(6, tier|0));
    const basePow = 1 + (t-1)*5;
    const baseTgh = Math.max(0, (t-1)*4);
    const Mmax = 1.6 + (t-1)*0.2;
    const k = 0.34;
    const M_e = 1 + (Mmax-1) * (1 - Math.exp(-k * (w-1)));
    const pow = Math.max(1, Math.round(basePow * M_e + 0.5*(w-1)));
    const tgh = Math.max(0, Math.round(baseTgh + 0.6*(w-1)));
    const L = (t-1)*10 + w;
    const name = ENEMY_NAMES[(L + pow + tgh) % ENEMY_NAMES.length];
    return { name, power: pow, strength: pow, toughness: tgh };
  }


  function simulateDuel(you, foe){
    // NGU-like: per-second hits; damage is (power - toughness) floored at 1
    const yourHPmax = Math.max(30, you.power * 3);
    const foeHPmax = Math.max(3, foe.power * 3);
    const yourRegen = you.toughness * 0.03;
    const foeRegen = foe.toughness * 0.03;

    const yourRaw = Math.max(1, you.power - foe.toughness);
    const foeRaw  = Math.max(1, foe.power - you.toughness);

    const yourDPS = Math.max(0, yourRaw - foeRegen);
    const foeDPS  = Math.max(0,   foeRaw - yourRegen);

    const tKillFoe = (yourDPS>0) ? (foeHPmax / yourDPS) : Infinity;
    const tKillYou = (foeDPS>0)  ? (yourHPmax / foeDPS) : Infinity;

    const youWin = tKillFoe <= tKillYou;
    const time = Math.min(tKillFoe, tKillYou);
    const youDamage = Math.min(yourHPmax, foeDPS * time);
    const foeDamage = Math.min(foeHPmax, yourDPS * time);
    return { youWin, time, youDamage, foeDamage, yourHPmax, foeHPmax, yourDPS, foeDPS, yourRaw, foeRaw };
  }

  function tbLog(line){ 
    const ts = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    try{
    const el = document.getElementById('tbLog'); if(!el) return;
    const ts = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    const li = document.createElement('li'); li.className='li';
    li.innerHTML = `<span class="ts">[${ts}]</span>${line}`;
    el.prepend(li);
    const empty = document.getElementById('logEmpty'); if(empty){ empty.classList.add('hidden'); }
  }catch(e){} 

// Persist to history so logs survive refresh
try{
  state.territory = state.territory || {};
  const hist = state.territory.logHistory = state.territory.logHistory || [];
  hist.unshift({ ts, html: line });
  if(hist.length > 200) hist.length = 200;
  if(typeof scheduleSave === 'function'){ scheduleSave(); }
  try{ if(typeof saveGame==='function') saveGame({ silent: true }); }catch(e){}

  try{ if(typeof pushLog==='function'){ pushLog({ html: line }); } }catch(e){}
}catch(_){}
}

  function renderTB(){ renderMap(); renderTBDebug();
    try{
      const msg = document.getElementById('tbMsg');
      const waveEl = document.getElementById('tbWave');
      const hb = document.getElementById('tbHealthBar');
      const hpct = document.getElementById('tbHealthPct');

      const you = getDerivedCombat();
      const foe = state.territory.enemy || scaleEnemy(state.territory.tier, state.territory.wave);

      document.getElementById('tbYouStr').textContent = you.strength;
      document.getElementById('tbYouTgh').textContent = you.toughness;
      document.getElementById('tbYouPow').textContent = you.power;
      document.getElementById('tbEnemyName').textContent = foe.name;
      document.getElementById('tbEnemyStr').textContent = foe.strength;
      document.getElementById('tbEnemyTgh').textContent = foe.toughness;
      document.getElementById('tbEnemyPow').textContent = foe.power;

      if(waveEl) waveEl.textContent = String(state.territory.wave);
      // Show simulated player HP during an active battle; otherwise show real vitals
let playerPct = (state.vitals.health||0);
if(state.territory && state.territory.battle && state.territory.battle.youHPMax>0){
  playerPct = Math.max(0, Math.min(100, Math.round((state.territory.battle.youHP / state.territory.battle.youHPMax) * 100)));
// Update battle progress bar
try{
  const pbar = document.getElementById('tbBattleProgBar');
  const ptxt = document.getElementById('tbBattleProgText');
  if(pbar && ptxt){
    let pct = 0;
    let txt = 'Ready';
    const b = state.territory && state.territory.battle;
    if(b && b.active && b.durationMs && b.startMs){
      const elapsed = Math.max(0, performance.now() - b.startMs);
      const t = Math.max(0, Math.min(1, elapsed / b.durationMs));
      pct = Math.round(t * 100);
      const left = Math.max(0, b.durationMs - elapsed) / 1000;
      txt = left.toFixed(1) + 's left';
    
try{ setTierButtons(state.territory && state.territory.tier || 1); }catch(e){}
}
    pbar.style.width = pct + '%';
    ptxt.textContent = txt;
  }
}catch(e){}

}
if(hb) hb.style.width = playerPct + '%';
if(hpct) hpct.textContent = (Number(playerPct).toFixed(0) + '%');

      
// Update enemy health bar (progress view)
try{
  const ehb = document.getElementById('tbEnemyHealthBar');
  const ehpct = document.getElementById('tbEnemyHealthPct');
  if(ehb && ehpct){
    let pct = 100;
    if(state.territory && state.territory.battle && state.territory.battle.enemyHPMax>0){
      pct = Math.max(0, Math.min(100, Math.round((state.territory.battle.enemyHP / state.territory.battle.enemyHPMax) * 100)));
    }
    ehb.style.width = pct + '%';
    ehpct.textContent = (Number(pct).toFixed(0) + '%');
  }
}catch(e){}
if(msg){
        const outf = simulateDuel(you, foe);
        const pwin = isFinite(outf.yourDPS) && isFinite(outf.foeDPS) && outf.yourDPS>0 ? (1) : (outf.youWin?1:0);
        msg.textContent = outf.youWin
          ? `Odds look good: est. TTK ${outf.time.toFixed(1)}s; you take ~${Math.round(100*outf.youDamage/outf.yourHPmax)}% damage if you win.`
          : `Careful: est. loss in ${outf.time.toFixed(1)}s; enemy would deal ~${Math.round(100*outf.youDamage/outf.yourHPmax)}% of your max HP.`;
      }
    }catch(e){}
  }
  window.renderTerritoryBattle = renderTB;

  function startOrNextWave(){
    if(state.vitals.health <= 0){
      tbLog('You are too injured. Heal up first.');
      return;
    }
    if(state.territory.active){ 
      // already active; treat as skip to result
    }
    const foe = scaleEnemy(state.territory.tier, state.territory.wave);
    state.territory.enemy = foe;
    const you = getDerivedCombat();
    const result = simulateDuel(you, foe);
    if(result.youWin){
      const dmgPct = Math.round((result.youDamage / result.yourHPmax) * 100);
      if(dmgPct >= (state.vitals.health||0)){
      // Too injured to survive the fight; count as a loss
      addHealth(-100);
      tbLog(`Wave ${state.territory.wave}: You tried to fight the <strong>${foe.name}</strong> but passed out from injuries.`);
    }else{
      addHealth(-dmgPct);
      }
      tbLog(`Wave ${state.territory.wave}: You beat the <strong>${foe.name}</strong>. Took <strong class="tbad">-${dmgPct}%</strong> health.`);
      maybeDropLoot(state.territory.tier, state.territory.wave);
      if(state.territory.wave < 10){
        state.territory.wave += 1;
      }else{
        tbLog(`<strong>Tier ${state.territory.tier} cleared!</strong> Tougher foes await.`);
        state.territory.wave = 1;
        state.territory.tier = Math.min(2, state.territory.tier + 1);
        // Update tier buttons
        setTierButtons(state.territory.tier);
      }
    }else{
      addHealth(-100);
      tbLog(`Wave ${state.territory.wave}: You were defeated by the <strong>${foe.name}</strong>.`);
    }
    renderTB(); scheduleSave(); renderLootList(); updateUI(); scheduleSave();
  }

  
  function renderLootList(){
    const list = document.getElementById('tbLootList');
    const empty = document.getElementById('tbLootEmpty');
    if(!list) return;
    const q = state.territory.lootQueue || [];
    if(empty) empty.classList.toggle('hidden', q.length>0);
    list.innerHTML = q.map((it, idx) => {
      const isStr = (it.mods && it.mods[0] && it.mods[0].kind === 'strAdd');
      const val = it.mods && it.mods[0] ? it.mods[0].value : 0;
      const stat = isStr ? ('+'+val+' Strength') : ('+'+val+' Toughness');
      return `
        <li class="li" data-idx="${idx}">
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <span class="pill ${it.rarity||'common'}">${it.rarity||'common'}</span>
            <strong>${escapeHtml(it.name)}</strong>
            <span class="muted small">Slot: ${escapeHtml(it.slot||'‚Äî')}</span>
            <span class="pill">${stat}</span>
            <span class="grow"></span>
            <button class="btn" data-claim="${idx}">Transfer</button>
            <button class="btn secondary" data-discard="${idx}">Discard</button>
          </div>
        </li>`;
    }).join('');

    // Bind buttons
    list.querySelectorAll('[data-claim]').forEach(btn=>{
      if(btn.dataset.bound) return;
      btn.addEventListener('click', ()=>{
        const idx = Number(btn.getAttribute('data-claim'));
        const item = (state.territory.lootQueue||[])[idx];
        if(!item) return;
        if(!hasInventorySpace(1)){ tbLog('Inventory full. Free up a slot.'); return; }
        state.inventory.push(item);
        state.territory.lootQueue.splice(idx,1);
        tbLog(`Transferred <strong>${escapeHtml(item.name)}</strong> to inventory.`);
        renderLootList(); scheduleSave(); updateUI();
      });
      btn.dataset.bound='1';
    });
    list.querySelectorAll('[data-discard]').forEach(btn=>{
      if(btn.dataset.bound) return;
      btn.addEventListener('click', ()=>{
        const idx = Number(btn.getAttribute('data-discard'));
        const item = (state.territory.lootQueue||[])[idx];
        if(!item) return;
        state.territory.lootQueue.splice(idx,1);
        tbLog(`Discarded <strong>${escapeHtml(item.name)}</strong>.`);
        renderLootList(); scheduleSave(); updateUI();
      });
      btn.dataset.bound='1';
    });
  }

  function maybeDropLoot(tier, wave){
    const chance = 0.25; // 25% per win
    if(Math.random() > chance) return;
    const pool = [
      { id:`loot-knuckles-${Date.now()}-${Math.random()}`, name:'Weighted Knuckles', slot:'hands', rarity:'common', mods:[{kind:'strAdd',  value: 3}] },
      { id:`loot-vest-${Date.now()}-${Math.random()}`,     name:'Padded Vest',       slot:'chest', rarity:'common', mods:[{kind:'toughAdd', value: 3}] },
      { id:`loot-wraps-${Date.now()}-${Math.random()}`,    name:'Wrist Wraps',       slot:'hands', rarity:'common', mods:[{kind:'strAdd',  value: 2}] },
      { id:`loot-cap-${Date.now()}-${Math.random()}`,      name:'Padded Cap',        slot:'head',  rarity:'common', mods:[{kind:'toughAdd', value: 2}] }
    ];
    const it = pool[Math.floor(Math.random()*pool.length)];
    state.territory.lootQueue = state.territory.lootQueue || [];
    state.territory.lootQueue.push(it);
    renderLootList();
  }

  function setTier(tier){
    state.territory.tier = tier;
    state.territory.wave = 1;
    state.territory.enemy = null;
    setTierButtons(tier);
    tbLog(`Switched to Tier ${tier}.`);
    renderTB();
  }

  // Wire up
  function wireTB(){
    const start = document.getElementById('tbStartBtn');
    const sim = document.getElementById('tbSimBtn');
    const t1 = document.getElementById('tbTier1');
    const t2 = document.getElementById('tbTier2');
    const take = document.getElementById('tbLootTake');
    if(start && !start.dataset.bound){ start.addEventListener('click', startOrNextWave); start.dataset.bound='1'; }
    if(sim && !sim.dataset.bound){ 
      sim.addEventListener('click', ()=>{
        for(let i=0;i<10;i++){ if(state.vitals.health<=0) break; startOrNextWave(); }
      }); sim.dataset.bound='1';
    }
    if(t1 && !t1.dataset.bound){ t1.addEventListener('click', ()=> setTier(1)); t1.dataset.bound='1'; }
    if(t2 && !t2.dataset.bound){ t2.addEventListener('click', ()=> setTier(2)); t2.dataset.bound='1'; }
    if(take && !take.dataset.bound){ take.addEventListener('click', takeLoot); take.dataset.bound='1'; }
  }

  // Show derived Strength/Toughness in Player Info
  // Hook into updateUI and tick
  const _origUpdateUI = window.updateUI;
  window.updateUI = function(){ try{ _origUpdateUI && _origUpdateUI(); }catch(e){} renderTB(); };

  const _origTick = window.tick;
  window.tick = function(){
    try{ _origTick && _origTick(); }catch(e){}
    try{ passiveHealthRegen(TICK_MS/1000); }catch(e){}
  };

  // Minimal view switcher for Territory link (non-invasive)
  (function(){
    const link = document.getElementById('territoryLink');
    if(link && !link.dataset.bound){
      link.addEventListener('click', function(){
        // Hide all views
        document.querySelectorAll('main .container section[role="tabpanel"]').forEach(sec=>{
          sec.classList.add('hidden'); sec.setAttribute('aria-hidden','true');
        });
        // Unselect all links
        document.querySelectorAll('aside .sidelink').forEach(a=> a.removeAttribute('aria-current'));
        // Show our view
        const sec = document.getElementById('view-territory');
        if(sec){ sec.classList.remove('hidden'); sec.setAttribute('aria-hidden','false'); }
        this.setAttribute('aria-current','page');
        wireTB(); setTierButtons((state.territory&&state.territory.tier)||1); renderTB();
      });
      link.dataset.bound='1';
    }
  })();

  // Also ensure TB UI wired on load, in case user lands there via saved state
  window.addEventListener('load', ()=> { try{ wireTB(); setTierButtons((state.territory&&state.territory.tier)||1); renderTB(); renderLootList(); renderMap(); renderTBDebug(); if (typeof renderTierHint === 'function') renderTierHint(); }catch(e){} });

  // Global sidebar navigation: show only the selected view
  function selectTab(tab){
    // Hide all tabpanels
    document.querySelectorAll('main .container section[role="tabpanel"]').forEach(sec=>{
      sec.classList.add('hidden'); sec.setAttribute('aria-hidden','true');
    });
    // Unselect
    document.querySelectorAll('aside .sidelink').forEach(a=> a.removeAttribute('aria-current'));
    // Show
    const id = `view-${tab}`;
    const sec = document.getElementById(id);
    if(sec){ sec.classList.remove('hidden'); sec.setAttribute('aria-hidden','false'); }
    const link = document.querySelector(`.sidelink[data-tab="${tab}"]`);
    if(link){ link.setAttribute('aria-current','page'); }
    if(tab==='territory'){ wireTB(); setTierButtons((state.territory&&state.territory.tier)||1); renderTB(); renderLootList(); }
  }
  window.selectTab = selectTab;

  (function wireGlobalNav(){
    document.querySelectorAll('.sidelink[data-tab]').forEach(a=>{
      if(a.dataset.bound) return;
      a.addEventListener('click', ()=> selectTab(a.getAttribute('data-tab')));
      a.dataset.bound='1';
    });
    // Initial: pick Stats if present, otherwise first tab
    const defaultTab = document.querySelector('.sidelink[data-tab="stats"]') ? 'stats'
                        : (document.querySelector('.sidelink[data-tab]')?.getAttribute('data-tab')||'stats');
    // On first run, hide everything then show default
    selectTab(defaultTab);
  })();

  // --- Regions & Map and Capture Flow ---
  const REGION_NAMES = ['Downtown','Harbor','Old Town','Heights','Industrial','Suburbs'];
  const REGION_COLORS = { captured:'#2ecc71', target:'#f1c40f', locked:'#2c3e50' };

  function initTerritoryRegions(){
    if(!state.territory) state.territory = {};
    if(!Array.isArray(state.territory.regions) || state.territory.regions.length!==6){
      state.territory.regions = REGION_NAMES.map((name,i)=>({ id:i, name, status: i===0?'target':'locked' }));
    }
    if(typeof state.territory.currentTarget !== 'number'){
      state.territory.currentTarget = state.territory.regions.findIndex(r=>r.status==='target');
      if(state.territory.currentTarget<0) state.territory.currentTarget = Math.min(5, (state.territory.regions.filter(r=>r.status==='captured').length)||0);
    }
    const captured = state.territory.regions.filter(r=>r.status==='captured').length;
    state.territory.tier = Math.max(1, Math.min(6, captured + 1, state.territory.tier||1));
  }

  function renderMap(){
    try{
      initTerritoryRegions();
      const svg = document.getElementById('tbMap');
      if(!svg) return;
      const rects = svg.querySelectorAll('[data-r]');
      const labels = svg.querySelectorAll('#tbMapLabels text');
      state.territory.regions.forEach((r,i)=>{
        const rect = rects[i];
        const lab = labels[i];
        if(rect){
          const col = (r.status==='captured')?REGION_COLORS.captured : (r.status==='target'?REGION_COLORS.target : REGION_COLORS.locked);
          rect.setAttribute('fill', col);
          rect.setAttribute('stroke', '#121821');
          rect.setAttribute('stroke-width','2');
        }
        if(lab){ lab.textContent = r.name; }
      });
    }catch(e){}
  }

  function markRegionCaptured(idx){
    try{
      const r = state.territory.regions[idx];
      if(!r) return;
      r.status = 'captured';
      const next = state.territory.regions.findIndex(rr=>rr.status==='locked');
      if(next>=0){
        state.territory.regions[next].status = 'target';
        state.territory.currentTarget = next;
      }else{
        state.territory.currentTarget = idx;
      }
    }catch(e){}
  }

  function getCapturedCount(){ return (state.territory.regions||[]).filter(r=>r.status==='captured').length; }

  // Override setTierButtons to support 1..6
  
  function setTierButtons(tier){
    const cap = getCapturedCount();
    const maxTier = Math.min(6, cap+1);
    for(let i=1;i<=6;i++){
      const b = document.getElementById('tbTier'+i);
      if(!b) continue;
      b.setAttribute('aria-pressed', String(i===tier));
      const locked = i > maxTier;
      b.disabled = locked;
      b.setAttribute('aria-disabled', String(locked)); b.classList.toggle('disabled', locked);
      b.title = locked ? `Locked ‚Äî capture ${i-1} region(s) first` : `Go to Tier ${i}`;
      if(!b.dataset.bound){
        b.addEventListener('click', ()=>{
          if(b.disabled){
            tbLog(`Tier ${i} is locked ‚Äî capture ${i-1} region(s) first. (You have ${cap}.)`);
            return;
          }
          setTier(i);
        });
        b.dataset.bound='1';
      }
    }
    if (typeof renderTierHint === 'function') renderTierHint(); }

  // Override setTier to lock to captured+1 and retarget region
  const _origSetTier = setTier;
  setTier = function(tier){
    const cap = getCapturedCount();
    const maxTier = Math.min(6, cap+1);
    const req = (tier|0) - 1;
    const t = Math.max(1, Math.min(maxTier, tier|0));
    if(t !== (tier|0)){
      tbLog(`Tier ${tier} is locked ‚Äî capture ${req} region(s) first. Staying at Tier ${t}.`);
    }
    state.territory.tier = t;
    state.territory.wave = 1;
    state.territory.enemy = null;
    const next = (state.territory.regions||[]).findIndex(r=>r.status!=='captured');
    if(next>=0){
      state.territory.regions.forEach((r)=>{ if(r.status==='target') r.status='locked'; });
      state.territory.regions[next].status='target';
      state.territory.currentTarget = next;
    }
    setTierButtons(t);
    tbLog(`Switched to Tier ${t}.`);
    renderMap(); renderTBDebug(); renderTB(); scheduleSave();
  };

  // Override startOrNextWave to capture region at wave 10 clear
  const _oldStartOrNextWave = startOrNextWave;
startOrNextWave = function(){
  // If a battle is currently active, skip/finish it immediately
  if(state.territory && state.territory.battle && state.territory.battle.active){
    try{ finishBattle(state.territory.battle.resultSnapshot, { skipped:true }); }catch(e){}
    return;
  }
  if(state.vitals.health <= 0){
    tbLog('You are too injured. Heal up first.');
    return;
  }
  const foe = scaleEnemy(state.territory.tier, state.territory.wave);
  state.territory.enemy = foe;
  const you = getDerivedCombat();
  const result = simulateDuel(you, foe);
  // Begin a 5s presentation of the battle where the enemy health decreases relative to your DPS
  beginBattle(you, foe, result, 5000);
};

// === Progressive 5s Battle Presentation =====================================
function beginBattle(you, foe, result, durationMs){
  try{
    state.territory = state.territory || {};
    const dur = Math.max(500, Number(durationMs)||5000);

    // Extract duel numbers from the already-computed result
    const foeHPmax  = Math.max(1, Math.round(result.foeHPmax||0));
    const yourDPS   = Math.max(0, Number(result.yourDPS||0));
    const yourHPmax = Math.max(1, Math.round(result.yourHPmax||0));
    const foeDPS    = Math.max(0, Number(result.foeDPS||0));

    // Player starts each wave at their current health %, not full
    const startPct      = Math.max(0, Math.min(100, Number(state.vitals?.health||0)));
    const initialYouHP  = Math.round(yourHPmax * (startPct/100));

    // Work out how long the *fight* would actually last (using current HP as the cap)
    const tKillFoe   = (yourDPS>0) ? (foeHPmax     / yourDPS) : Infinity;
    const tKillYou   = (foeDPS>0)  ? (initialYouHP / foeDPS)   : Infinity;
    const simTimeCap = Math.min(tKillFoe, tKillYou); // seconds to end if left to run

    // If the fight wouldn't progress (e.g. zero DPS on both sides), resolve instantly
    if(!Number.isFinite(simTimeCap) || simTimeCap <= 0){
      try{ instantResolveBattle(you, foe, result); }catch(_){}
      return;
    }

    // Final HPs if the fight runs to completion under current conditions
    const wouldYouWin  = (tKillFoe <= tKillYou);
    const endEnemyHP   = wouldYouWin ? 0 : Math.max(0, Math.round(foeHPmax - yourDPS * tKillYou));
    const endYouHP     = wouldYouWin ? Math.max(0, Math.round(initialYouHP - foeDPS * tKillFoe))
                                     : 0;

    const battle = {
      active: true,
      startMs: performance.now(),
      durationMs: dur,
      // Enemy
      enemyHPMax: foeHPmax,
      enemyHP: foeHPmax,
      // Player (simulated within this duel only)
      youHPMax: yourHPmax,
      youHP: initialYouHP,
      // End targets for interpolation/simulation
      endEnemyHP,
      endYouHP,
      foe,
      you,
      // Keep the original duel result so finishBattle can compute % loss consistently
      resultSnapshot: {
        foe, you,
        foeHPmax, yourHPmax,
        yourDPS, foeDPS,
        youDamage: Math.max(0, Math.round(result.youDamage||0)),
        foeDamage: Math.max(0, Math.round(result.foeDamage||0)),
        youWin: Boolean(result.youWin)
      },
      timerId: null
    };
    state.territory.battle = battle;

    // Disable the start button while animating
    const startBtn = document.getElementById('tbStartBtn');
    if(startBtn){ startBtn.disabled = true; startBtn.textContent = 'Battling‚Ä¶'; }

    // Each RAF tick advances *simulated* time linearly to the fight's end within dur
    let last = performance.now();
    let simTime = 0;                      // seconds mapped into the duel
    const simRate = simTimeCap / dur;     // seconds of duel per ms of real time

    function step(now){
      if(!state.territory?.battle?.active) return; // aborted elsewhere
      const dtMs = Math.max(0, now - last);
      last = now;

      // Advance simulated time
      simTime = Math.min(simTimeCap, simTime + dtMs * simRate);

      // Update HP based on DPS * simulated time
      const curEnemyHP = Math.max(0, Math.round(foeHPmax - yourDPS * simTime));
      const curYouHP   = Math.max(0, Math.round(initialYouHP - foeDPS * simTime));
      battle.enemyHP = curEnemyHP;
      battle.youHP   = curYouHP;

      // Update UI
      try{ renderTB(); }catch(_){}

      // Check end conditions
      if(simTime >= simTimeCap - 1e-6 || curEnemyHP <= 0 || curYouHP <= 0){
        // Auto-finish and commit results
        try{ finishBattle(battle.resultSnapshot); }catch(_){}
        return;
      }

      // Continue animation
      battle.timerId = requestAnimationFrame(step);
    }

    // Kick off
    battle.timerId = requestAnimationFrame(step);
  }catch(e){
    console.error('beginBattle error', e);
    // Fallback: if something goes wrong, resolve instantly (commits health)
    try{ instantResolveBattle(you, foe, result); }catch(_){}
  }
}

function finishBattle(snap, { skipped } = { skipped:false }){
  try{
    const battle = state.territory?.battle;
    if(battle && battle.timerId){ cancelAnimationFrame(battle.timerId); }
  }catch(e){}
  // Clear active state
  try{
    if(state.territory){ delete state.territory.battle; }
  }catch(e){}
  // Re-enable button
  const startBtn = document.getElementById('tbStartBtn'); 
  if(startBtn){ startBtn.disabled = false; startBtn.textContent = 'Start / Next Wave'; }

  const foe = state.territory.enemy || snap?.foe;
  const tier = snap?.tier || state.territory.tier;
  const wave = snap?.wave || state.territory.wave;
  const youDamage = snap?.youDamage || 0;
  const yourHPmax = snap?.yourHPmax || 1;
  const youWin = !!snap?.youWin;

  if(youWin){
    const dmgPct = Math.round((youDamage / yourHPmax) * 100);
    if(dmgPct >= (state.vitals.health||0)){
      // Too injured to survive the fight; count as a loss
      addHealth(-100);
      tbLog(`Wave ${wave}: You tried to fight the <strong>${foe.name}</strong> but passed out from injuries.`);
    }else{
      addHealth(-dmgPct);
      tbLog(`Wave ${wave}: You beat the <strong>${foe.name}</strong>. Took <strong class="tbad">-${dmgPct}%</strong> health.`);
      maybeDropLoot(tier, wave);
      if(state.territory.wave < 10){
        state.territory.wave += 1;
      }else{
        const idx = state.territory.currentTarget||0;
        markRegionCaptured(idx);
        const cap = getCapturedCount();
        tbLog(`<strong>Region captured!</strong> ${cap}/6 controlled.`);
        state.territory.wave = 1;
        state.territory.tier = Math.min(6, cap + 1);
        setTierButtons(state.territory.tier);
      }
    }
  }else{
    addHealth(-100);
    tbLog(`Wave ${wave}: You were defeated by the <strong>${foe.name}</strong>.`);
  }

  
// Preview next enemy for the new wave so players can decide before starting
try{
  state.territory.enemy = scaleEnemy(state.territory.tier, state.territory.wave);
}catch(e){}

renderMap(); try{ renderTBDebug(); }catch(e){}
  renderTB(); (typeof renderTierHint==='function') && renderTierHint(); updateUI && updateUI(); scheduleSave && scheduleSave();
}

function instantResolveBattle(you, foe, result){
  // Original fall-back resolution (instant) in case progressive flow fails
  if(result.youWin){
    const dmgPct = Math.round((result.youDamage / result.yourHPmax) * 100);
    if(dmgPct >= (state.vitals.health||0)){
      addHealth(-100);
      tbLog(`Wave ${state.territory.wave}: You tried to fight the <strong>${foe.name}</strong> but passed out from injuries.`);
    }else{
      addHealth(-dmgPct);
      tbLog(`Wave ${state.territory.wave}: You beat the <strong>${foe.name}</strong>. Took <strong class="tbad">-${dmgPct}%</strong> health.`);
      maybeDropLoot(state.territory.tier, state.territory.wave);
      if(state.territory.wave < 10){
        state.territory.wave += 1;
      }else{
        const idx = state.territory.currentTarget||0;
        markRegionCaptured(idx);
        const cap = getCapturedCount();
        tbLog(`<strong>Region captured!</strong> ${cap}/6 controlled.`);
        state.territory.wave = 1;
        state.territory.tier = Math.min(6, cap + 1);
        setTierButtons(state.territory.tier);
      }
    }
  }else{
    addHealth(-100);
    tbLog(`Wave ${state.territory.wave}: You were defeated by the <strong>${foe.name}</strong>.`);
  }
  renderMap(); try{ renderTBDebug(); }catch(e){}
  renderTB(); (typeof renderTierHint==='function') && renderTierHint(); updateUI && updateUI(); scheduleSave && scheduleSave();
}

  // Debug panel content
  function renderTBDebug(){
    try{
      const el = document.getElementById('tbDebug'); if(!el) return;
      const you = getDerivedCombat();
      const foe = state.territory.enemy || scaleEnemy(state.territory.tier, state.territory.wave);
      const out = simulateDuel(you, foe);
      const cap = getCapturedCount();
      const target = state.territory.currentTarget;
      const r = (state.territory.regions||[])[target];
      el.innerHTML = `
        <div><strong>Debug</strong></div>
        <div>Tier ${state.territory.tier} ‚Ä¢ Wave ${state.territory.wave} ‚Ä¢ Captured ${cap}/6 ‚Ä¢ Target: ${target} (${r?escapeHtml(r.name):'n/a'})</div>
        <div>You: STR ${you.strength} TGH ${you.toughness} POW ${you.power} HPmax ${(you.power*3).toFixed(0)} Regen ${(you.toughness*0.03).toFixed(2)}/s</div>
        <div>Foe: STR ${foe.strength} TGH ${foe.toughness} POW ${foe.power} HPmax ${(foe.power*3).toFixed(0)} Regen ${(foe.toughness*0.03).toFixed(2)}/s</div>
      `;
    }catch(e){}
  }

})();
</script>
<!-- end affordability-guard -->



<!-- Basement 3D: lightweight first-person scene for Damp Basement HQ (Global build for local file:// use) -->
<script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
<script>
(function(){
  let __basement = null;
  let __resizeObserver = null;

  function isDampBasement(h){
    try{
      const nm = String(h && h.name || '').toLowerCase().trim();
      return nm === 'damp basement';
    }catch(e){ return false; }
  }

  function ensureCanvasSize(renderer){
    try{
      const wrap = document.getElementById('basement3DWrap');
      if(!wrap || !renderer) return;
      const canvas = renderer.domElement;
      const w = wrap.clientWidth || 600;
      const h = wrap.clientHeight || 260;
      if(canvas.width !== w || canvas.height !== h){
        renderer.setSize(w, h, false);
        if(renderer.camera){
          const c = renderer.domElement;
          renderer.camera.aspect = c.clientWidth / Math.max(1, c.clientHeight);
          renderer.camera.updateProjectionMatrix();
        }
      }
    }catch(e){}
  }

  function mountBasement3D(){
    if(__basement) return __basement;
    const wrap = document.getElementById('basement3DWrap');
    const canvas = document.getElementById('basement3DCanvas');
    if(!wrap || !canvas || !window.THREE) return null;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 100);
    camera.position.set(0, 1.6, 4);

    
    camera.rotation.order = 'YXZ';
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.camera = camera; // allow ensureCanvasSize to update projection

    // Make sure we size immediately (even if shown just now)
    ensureCanvasSize(renderer);

    // Lights
    const hemi = new THREE.HemisphereLight(0xddeeff, 0x0a0a0a, 0.9);
    scene.add(hemi);
    const amb  = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(amb);
    const spotA = new THREE.SpotLight(0xffffff, 2.8, 16, Math.PI/5, 0.35, 1.2);
    spotA.position.set(-1.5, 2.4, 1.2);
    scene.add(spotA);
    const spotB = new THREE.SpotLight(0xb0c8ff, 2.0, 16, Math.PI/5, 0.4, 1.0);
    spotB.position.set(2.2, 2.6, -1.2);
    scene.add(spotB);
// Floor & walls (simple room ~6x6m)
    const room = new THREE.Group();
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x22272e, roughness: 0.9, metalness: 0.0 });
    const wallMat  = new THREE.MeshStandardMaterial({ color: 0x1a1f27, roughness: 0.95, metalness: 0.0 });

    const plane = (w,h,rx,ry,rz,px,py,pz,mat)=>{
      const g = new THREE.PlaneGeometry(w,h);
      const m = new THREE.Mesh(g, mat);
      m.rotation.set(rx, ry, rz);
      m.position.set(px, py, pz);
      room.add(m);
    };
    // floor
    plane(6,6, -Math.PI/2, 0, 0, 0, 0, 0, floorMat);
    // ceiling (darker)
    const ceilMat = new THREE.MeshStandardMaterial({ color: 0x12161d, roughness: 0.95 });
    plane(6,6,  Math.PI/2, 0, 0, 0, 3, 0, ceilMat);
    // walls
    plane(6,3, 0,  Math.PI, 0,   0, 1.5, -3, wallMat);   // back
    plane(6,3, 0, 0, 0,      0, 1.5,  3, wallMat);       // front
    plane(6,3, 0,  Math.PI/2, 0, -3, 1.5, 0, wallMat);   // left
    plane(6,3, 0, -Math.PI/2, 0,  3, 1.5, 0, wallMat);   // right

    // Props: boxes / pipes
    const boxMat = new THREE.MeshStandardMaterial({ color: 0x2b323c, roughness: 0.85 });
    for(let i=0;i<5;i++){
      const g = new THREE.BoxGeometry(0.6+Math.random()*0.4, 0.3+Math.random()*0.6, 0.6+Math.random()*0.4);
      const m = new THREE.Mesh(g, boxMat);
      m.position.set(-2.4 + Math.random()*4.8, 0.2, -2.2 + Math.random()*2.0);
      m.castShadow = false; m.receiveShadow = true;
      room.add(m);
    }
    scene.add(room);


// --- First Aid Cabinet (procedural) -------------------------------------
(function buildProceduralFirstAid(scene){
  const g = new THREE.Group();
  // Dimensions (meters)
  const W = 0.48, H = 0.62, D = 0.18;
  // Position on back wall (z ~ -3), at eye height
  g.position.set(-0.85, 1.45, -2.98);
  // Make sure it faces into the room
  g.rotation.y = Math.PI;

  // Materials
  const cabMat  = new THREE.MeshStandardMaterial({ color: 0xe6e8ea, roughness: 0.7, metalness: 0.05 });
  const rimMat  = new THREE.MeshStandardMaterial({ color: 0xbfc5cc, roughness: 0.5, metalness: 0.3 });
  const glassMat= new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.0, transmission: 0.8, transparent: true, thickness: 0.01 });
  const redMat  = new THREE.MeshStandardMaterial({ color: 0xc81e1e, roughness: 0.6, metalness: 0.0 });

  // Main box (shallow depth)
  const body = new THREE.Mesh(new THREE.BoxGeometry(W, H, D), cabMat);
  body.castShadow = false; body.receiveShadow = true;
  g.add(body);

  // Slightly inset door panel
  const door = new THREE.Mesh(new THREE.BoxGeometry(W*0.96, H*0.96, D*0.02), rimMat);
  door.position.set(0, 0, D*0.51);
  g.add(door);

  // Glass window on door
  const glass = new THREE.Mesh(new THREE.PlaneGeometry(W*0.6, H*0.48), glassMat);
  glass.position.set(0, 0, D*0.52 + 0.001);
  g.add(glass);

  // Red cross emblem (two thin boxes)
  const crossH = new THREE.Mesh(new THREE.BoxGeometry(W*0.4, H*0.08, D*0.005), redMat);
  crossH.position.set(0, 0, D*0.525);
  const crossV = new THREE.Mesh(new THREE.BoxGeometry(W*0.08, H*0.4, D*0.005), redMat);
  crossV.position.set(0, 0, D*0.525);
  g.add(crossH, crossV);

  // Small handle
  const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.007, 0.007, 0.06, 16), rimMat);
  handle.rotation.z = Math.PI/2;
  handle.position.set(W*0.43, 0, D*0.52);
  g.add(handle);

  // Mount flush to wall: nudge forward a bit to avoid z-fighting
  g.position.z += 0.005;

  // Expose for later tweaks
  scene.__firstAidCabinet = g;
  scene.add(g);
})(scene);




// --- Ceiling Lights ------------------------------------------------------
(function addCeilingLights(scene){
  const positions = [ -1.8, 0, 1.8 ];
  positions.forEach((x) => {
    const light = new THREE.PointLight(0xffffff, 1.2, 8, 2.0);
    light.position.set(x, 2.4, 0);
    light.castShadow = true;
    scene.add(light);

    const stripMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffffff,
      emissiveIntensity: 2.2,
      roughness: 0.3,
      metalness: 0.0
    });
    const strip = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.04, 0.08), stripMat);
    strip.position.set(x, 2.45, 0);
    scene.add(strip);
  });
})(scene);



    // Basic first-person controls (pointer lock + WASD)
    let yaw=0, pitch=0;
    const vel = { x:0, z:0 };
    const keys = { w:false, a:false, s:false, d:false };
    const speed = 1.8; // m/s
    const damping = 0.86;

    function onResize(){
      if(!renderer) return;
      ensureCanvasSize(renderer);
      const c = renderer.domElement;
      camera.aspect = c.clientWidth / Math.max(1, c.clientHeight);
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    wrap.addEventListener('click', () => {
      try{ canvas.requestPointerLock(); }catch(e){}
    });

    function onMouseMove(e){
      if(document.pointerLockElement === canvas){
        const sens = 0.0025;
        yaw -= e.movementX * sens;
        pitch -= e.movementY * sens;
        const clamp = Math.PI/2 - 0.05;
        if(pitch > clamp) pitch = clamp;
        if(pitch < -clamp) pitch = -clamp;
      }
    }
    document.addEventListener('mousemove', onMouseMove);

    function onKey(e, down){
      const k = e.key.toLowerCase();
      if(k==='w') keys.w = down;
      if(k==='a') keys.a = down;
      if(k==='s') keys.s = down;
      if(k==='d') keys.d = down;
    }
    document.addEventListener('keydown', e=>onKey(e,true));
    document.addEventListener('keyup',   e=>onKey(e,false));

    function tick(ts){
      const dt = Math.min(0.033, (renderer.__lastTs ? (ts-renderer.__lastTs)/1000 : 0.016));
      renderer.__lastTs = ts;

      // Integrate velocity from keys (local space)
      const fwdX = Math.sin(yaw), fwdZ = Math.cos(yaw);
      const rightX = Math.cos(yaw), rightZ = -Math.sin(yaw);

      if(keys.w) { vel.x += fwdX * speed * dt; vel.z += fwdZ * speed * dt; }
      if(keys.s) { vel.x -= fwdX * speed * dt; vel.z -= fwdZ * speed * dt; }
      if(keys.a) { vel.x -= rightX * speed * dt; vel.z -= rightZ * speed * dt; }
      if(keys.d) { vel.x += rightX * speed * dt; vel.z += rightZ * speed * dt; }

      // Damping
      vel.x *= damping; vel.z *= damping;

      // Move camera; clamp within room bounds (a bit inset from walls)
      camera.position.x += vel.x;
      camera.position.z += vel.z;
      camera.position.x = Math.max(-2.7, Math.min(2.7, camera.position.x));
      camera.position.z = Math.max(-2.7, Math.min(2.7, camera.position.z));

      // Apply look
      camera.rotation.x = pitch;
      camera.rotation.y = yaw;

      renderer.render(scene, camera);
      renderer.__raf = requestAnimationFrame(tick);
    }
    renderer.__raf = requestAnimationFrame(tick);

    // Public cleanup
    function cleanup(){
      try{ cancelAnimationFrame(renderer.__raf); }catch(e){}
      window.removeEventListener('resize', onResize);
      document.removeEventListener('mousemove', onMouseMove);
      // release pointer lock if ours
      try{ if(document.pointerLockElement===canvas) document.exitPointerLock(); }catch(e){}
      // dispose
      try{
        scene.traverse(obj => {
          if(obj.geometry) obj.geometry.dispose?.();
          if(obj.material){
            if(Array.isArray(obj.material)){ obj.material.forEach(m=>m.dispose?.()); }
            else obj.material.dispose?.();
          }
        });
        renderer.dispose();
      }catch(e){}
      __basement = null;
    }

    __basement = { renderer, scene, camera, cleanup };
    onResize();
    return __basement;
  }

  function destroyBasement3D(){
    if(__basement && __basement.cleanup){ __basement.cleanup(); }
    __basement = null;
  }

  // Hook into renderHeadquarters to mount/unmount based on HQ name
  const __origRenderHQ = window.renderHeadquarters;
  window.renderHeadquarters = function(){
    try{ __origRenderHQ && __origRenderHQ.apply(this, arguments); }catch(e){}
    try{
      const container = document.getElementById('hqBasement3D');
      if(!container) return;
      // Attempt to resolve current HQ record via helper if present
      let h = null;
      try{ h = (typeof window.getHQRecord==='function') ? window.getHQRecord() : null; }catch(e){}
      const shouldShow = !!(h && isDampBasement(h));
      container.classList.toggle('hidden', !shouldShow);
      container.setAttribute('aria-hidden', String(!shouldShow));
      if(shouldShow){
        // (re)mount if needed
        if(!__basement){ mountBasement3D(); }
        else{
          // ensure renderer resizes if coming back from hidden
          try{ __basement.renderer.__lastTs = null; }catch(e){}
        }
      }else{
        // Not damp basement -> destroy
        destroyBasement3D();
      }
    }catch(e){}
  };

  // Also clean up when switching away from HQ
  const __origSetActiveTab2 = window.setActiveTab;
  window.setActiveTab = function(id){
    try{
      if(id !== 'headquarters'){ destroyBasement3D(); }
    }catch(e){}
    try{ __origSetActiveTab2 && __origSetActiveTab2.apply(this, arguments); }catch(e){}
  };

})();</script>


<script>
  // Register Service Worker for offline + updates
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
      try {
        const reg = await navigator.serviceWorker.register('/service-worker.js', { scope: '/' });
        // Listen for new SW waiting to activate
        navigator.serviceWorker.addEventListener('message', (event) => {
          if (event.data && event.data.type === 'SW_UPDATE_AVAILABLE') {
            // Use a small helper to prompt user to refresh
            import('/sw-update.js').then(mod => mod.default(reg));
          }
        });
      } catch (err) {
        console.error('SW registration failed:', err);
      }
    });
  }
</script>
</body>
</html>

/* Ensure pending logs are saved before the page unloads */
try{
  window.addEventListener('beforeunload', function(){
    try{ if(typeof saveGame==='function') saveGame({ silent: true }); }catch(e){}
  });
}catch(e){}    
