<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini 3D FPS — Gun Kill Tracker</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#000; overflow:hidden; }
    #startOverlay {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,0.85); color:#fff; font: 18px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      text-align:center; z-index:10;
    }
    #startBox {
      max-width:560px; padding:22px 26px; border:1px solid #333; border-radius:10px; background:#0b0b0b;
      box-shadow:0 10px 30px rgba(0,0,0,0.45);
    }
    #startOverlay button {
      margin-top:14px; font-size:16px; padding:10px 16px; border-radius:8px; border:0;
      background:#1e90ff; color:#fff; cursor:pointer;
    }
    #hud {
      position:fixed; top:10px; left:10px; color:#fff; font: 14px/1 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      z-index:5; user-select:none; text-shadow:0 0 4px #000;
    }
    #hud .badge { display:inline-block; background:rgba(0,0,0,0.55); padding:6px 10px; border-radius:8px; margin-right:6px; }
    #crosshair {
      position:fixed; top:50%; left:50%; transform:translate(-50%, -50%);
      font: 24px/1 monospace; color:#fff; z-index:4; user-select:none; opacity:.85;
    }
    #help {
      position:fixed; bottom:10px; left:10px; color:#bbb; font:12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:rgba(0,0,0,0.4); padding:6px 8px; border-radius:6px; z-index:5;
    }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="startOverlay">
    <div id="startBox">
      <h2 style="margin:0 0 8px 0;">Mini 3D FPS — Kill Counter Attachment</h2>
      <p>Click <b>Start</b> to lock the mouse. Then use <b>WASD</b> to move, <b>Space</b> to jump, <b>Shift</b> to sprint, and <b>Left Click</b> to shoot.
      Hit the red orbs to increase your kill count. The gun-mounted display updates live.</p>
      <ul style="text-align:left; margin:10px auto; max-width:500px;">
        <li>If the mouse doesn't lock, try opening this file via a simple local server (instructions in the README).</li>
        <li>Works best in the latest Chrome/Edge/Firefox.</li>
      </ul>
      <button id="startBtn">Start</button>
    </div>
  </div>

  <div id="hud">
    <span class="badge">Kills: <b id="kills">0</b></span>
    <span class="badge">Ammo: <b id="ammo">∞</b></span>
    <span class="badge">FPS: <b id="fps">0</b></span>
  </div>
  <div id="crosshair">+</div>
  <div id="help">WASD move • Space jump • Shift sprint • Click to shoot • Esc unlocks cursor</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";

    // === basics ===
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x101015);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // === lights ===
    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.85);
    dir.position.set(5, 10, 4);
    scene.add(dir);

    // === ground ===
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x222228, metalness:0.1, roughness:0.9 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // === simple walls/props ===
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x303040, metalness:0.1, roughness:0.8 });
    for (let i=0;i<6;i++){
      const geo = new THREE.BoxGeometry(2 + Math.random()*3, 2 + Math.random()*3, 2 + Math.random()*3);
      const mesh = new THREE.Mesh(geo, wallMat);
      mesh.position.set((Math.random()-0.5)*40, geo.parameters.height/2, (Math.random()-0.5)*40);
      scene.add(mesh);
    }

    // === controls ===
    const controls = new PointerLockControls(camera, document.body);
    camera.position.set(0, 1.7, 5);
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');
    startBtn.addEventListener('click', () => controls.lock());

    controls.addEventListener('lock', () => startOverlay.style.display = 'none');
    controls.addEventListener('unlock', () => startOverlay.style.display = 'flex');

    // === movement ===
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);

    let velocityY = 0;
    const speed = 8;        // walk speed (m/s)
    const sprint = 1.65;    // sprint multiplier
    const gravity = 25;     // m/s^2
    let canJump = true;

    function handleMovement(delta){
      if (!controls.isLocked) return;
      const moveSpeed = (keys['ShiftLeft'] || keys['ShiftRight']) ? speed*sprint : speed;
      if (keys['KeyW']) controls.moveForward(moveSpeed * delta);
      if (keys['KeyS']) controls.moveForward(-moveSpeed * delta);
      if (keys['KeyA']) controls.moveRight(-moveSpeed * delta);
      if (keys['KeyD']) controls.moveRight(moveSpeed * delta);

      // jump + gravity, stick to ground plane y=1.7 baseline
      if (keys['Space'] && canJump) {
        velocityY = 8.5;
        canJump = false;
      }
      velocityY -= gravity*delta;
      camera.position.y += velocityY * delta;
      if (camera.position.y < 1.7){
        camera.position.y = 1.7;
        velocityY = 0;
        canJump = true;
      }
    }

    // === gun with on-weapon kill tracker ===
    const gun = new THREE.Group();
    camera.add(gun);
    scene.add(camera);
    // position gun in camera space (right-hand side, slightly down)
    gun.position.set(0.45, -0.3, -0.9);

    const body = new THREE.Mesh(
      new THREE.BoxGeometry(0.28, 0.18, 0.6),
      new THREE.MeshStandardMaterial({ color: 0x111111, metalness:0.6, roughness:0.4 })
    );
    body.castShadow = true;
    gun.add(body);

    // front barrel
    const barrel = new THREE.Mesh(
      new THREE.CylinderGeometry(0.03, 0.03, 0.45, 16),
      new THREE.MeshStandardMaterial({ color: 0x222222, metalness:0.7, roughness:0.35 })
    );
    barrel.rotation.x = Math.PI/2;
    barrel.position.set(0, -0.01, -0.45);
    gun.add(barrel);

    // tracker display: a small plane with a dynamic CanvasTexture, mounted on the side of the gun
    const trackerCanvas = document.createElement('canvas');
    trackerCanvas.width = 256; trackerCanvas.height = 128;
    const tctx = trackerCanvas.getContext('2d');

    function drawTrackerText(val){
      // background
      tctx.fillStyle = '#0a0a0a'; tctx.fillRect(0,0,trackerCanvas.width, trackerCanvas.height);
      // border
      tctx.strokeStyle = '#333'; tctx.lineWidth = 6; tctx.strokeRect(3,3, trackerCanvas.width-6, trackerCanvas.height-6);
      // text
      tctx.fillStyle = '#39ff14'; // retro green
      tctx.font = 'bold 70px monospace';
      tctx.textAlign = 'center'; tctx.textBaseline = 'middle';
      const padded = String(val).padStart(4,'0');
      tctx.fillText(padded, trackerCanvas.width/2, trackerCanvas.height/2 + 6);
    }

    let kills = 0;
    drawTrackerText(kills);
    const trackerTex = new THREE.CanvasTexture(trackerCanvas);
    trackerTex.anisotropy = Math.min(8, renderer.capabilities.getMaxAnisotropy() || 1);
    const tracker = new THREE.Mesh(
      new THREE.PlaneGeometry(0.28, 0.14),
      new THREE.MeshBasicMaterial({ map: trackerTex })
    );
    // mount on the side/top of the gun body
    tracker.position.set(0.14, 0.06, -0.18);
    tracker.rotation.y = Math.PI; // face toward the camera direction (-Z)
    gun.add(tracker);

    // === enemies ===
    const enemies = [];
    const enemyGeo = new THREE.SphereGeometry(0.45, 20, 20);
    function spawnEnemy(){
      const mat = new THREE.MeshStandardMaterial({ color: 0xff3b3b, metalness:0.3, roughness:0.6, emissive:0x330000, emissiveIntensity:0.4 });
      const m = new THREE.Mesh(enemyGeo, mat);
      const radius = 10 + Math.random()*25;
      const ang = Math.random()*Math.PI*2;
      m.position.set(Math.cos(ang)*radius, 0.5, Math.sin(ang)*radius);
      m.userData = {
        speed: 1.2 + Math.random()*0.8,
        alive: true,
      };
      enemies.push(m);
      scene.add(m);
    }
    for (let i=0;i<10;i++) spawnEnemy();

    function updateEnemies(delta){
      for (const e of enemies){
        if (!e.userData.alive) continue;
        const toCam = new THREE.Vector3().subVectors(camera.position, e.position);
        toCam.y = 0; // stay on ground plane
        const dist = toCam.length() || 1;
        toCam.normalize();
        // move toward player a bit
        e.position.addScaledVector(toCam, e.userData.speed * delta);
        // idle bob
        e.position.y = 0.5 + Math.sin(perfNow*0.002 + e.id || 0)*0.02;
        // very simple "avoid overlap"
        if (dist < 1) e.position.addScaledVector(toCam, -0.5);
      }
    }

    // === shooting ===
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(0,0); // center
    let lastShot = 0;
    const ROF = 120; // ms between shots
    const ammoEl = document.getElementById('ammo');
    const killsEl = document.getElementById('kills');

    function shoot(){
      const now = performance.now();
      if (now - lastShot < ROF) return;
      lastShot = now;

      // simple muzzle flash pulse (scale barrel briefly)
      barrel.scale.set(1, 0.8, 1);
      setTimeout(()=> barrel.scale.set(1,1,1), 30);

      // cast a ray from camera center
      raycaster.setFromCamera(mouse, camera);
      const hits = raycaster.intersectObjects(enemies.filter(e=>e.userData.alive), false);
      if (hits.length){
        // first hit enemy "dies"
        const target = hits[0].object;
        target.userData.alive = false;
        // tiny pop effect
        target.material.emissiveIntensity = 1.5;
        target.scale.setScalar(1.6);
        setTimeout(()=>{
          scene.remove(target);
          // respawn a new one
          spawnEnemy();
        }, 90);
        // increment counters + repaint tracker
        kills++;
        killsEl.textContent = kills;
        drawTrackerText(kills);
        trackerTex.needsUpdate = true;
      }
    }

    document.addEventListener('mousedown', (e) => {
      if (!controls.isLocked) return;
      if (e.button === 0) shoot();
    });

    // === resize ===
    window.addEventListener('resize', onResize);
    function onResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // === main loop ===
    const fpsEl = document.getElementById('fps');
    let last = performance.now();
    let perfNow = last;
    let fpsAccum = 0, fpsCount = 0, fpsLast = last;

    function animate(){
      requestAnimationFrame(animate);
      const now = performance.now();
      const delta = Math.min(0.05, (now - last)/1000);
      last = now;
      perfNow = now;

      handleMovement(delta);
      updateEnemies(delta);

      renderer.render(scene, camera);

      // fps (update once a second)
      fpsAccum += 1/delta; fpsCount++;
      if (now - fpsLast > 1000){
        const avg = fpsAccum / fpsCount;
        fpsEl.textContent = Math.round(avg);
        fpsAccum = 0; fpsCount = 0; fpsLast = now;
      }
    }
    animate();
  </script>
</body>
</html>