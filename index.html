<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>(CI logo) CrimIdle — Sidebar Nav</title>
<meta content="Fictional idle-game starter: dark theme, autosave, stats XP, heat, debug toggle, and a left sidebar navigation." name="description"/>
<style>
/* Roulette table layout */
.roulette-table { display:grid; grid-template-columns: repeat(13, minmax(34px,1fr)); gap:2px; user-select:none; }
.rt-cell { text-align:center; padding:6px 0; border:1px solid #1f2937; cursor:pointer; border-radius:6px; font-weight:600; }
.rt-zero { grid-row: 1 / span 3; grid-column: 1; writing-mode: vertical-rl; text-orientation: mixed; }
.rt-num { }
.rt-red { background:#731a1a; }
.rt-black { background:#111827; }
.rt-zero, .rt-num { color:#e5e7eb; }
.rt-out { grid-column: span 4; background:#0f172a; color:#e5e7eb; border:1px dashed #334155; }
.rt-col { grid-column: span 4; background:#0f172a; color:#e5e7eb; border:1px dashed #334155; }
.rt-selected { outline:2px solid #fbbf24; }

/* Canvas pointer */
#rouletteCanvas { position:relative; }
#rouletteCanvas::after { content:''; position:absolute; top:50%; left:50%; width:8px; height:8px; margin-left:-4px; margin-top:-4px; border-radius:50%; background:#fbbf24; box-shadow:0 0 0 2px #111827; }

    :root{
      --bg0:#0b0f14;
      --bg1:#0a0f16;
      --panel:#0f172a;
      --ink:#e5e7eb;
      --sub:#94a3b8;
      --muted:#1f2937;
      --muted-2:#334155;
      --accent:#22d3ee;
      --accent-warm:#f59e0b;
      --danger:#ef4444;
      --good:#22c55e;
      --sidebar-w: 250px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--ink);
      background:linear-gradient(to bottom, var(--bg0), var(--bg1));
    }
    /* Layout */
    .app{display:flex; min-height:100vh; width:100%;}
    aside.sidebar{
      width:var(--sidebar-w);
      background:var(--panel);
      border-right:1px solid var(--muted);
      padding:14px 12px;
      position:sticky; top:0; align-self:flex-start; height:100vh; overflow:auto;
    }
    .brand{display:flex; align-items:center; gap:10px; padding:8px 10px; margin-bottom:10px}
    .brand .logo{
      width:28px; height:28px; border-radius:8px; background:#111827; border:1px solid var(--muted); display:flex; align-items:center; justify-content:center; font-weight:900;
    }
    .brand .name{font-weight:800}
    nav.sidenav{display:flex; flex-direction:column; gap:6px; margin-top:6px}
    .sidelink{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px; border-radius:10px;
      color:var(--ink); text-decoration:none; cursor:pointer;
      border:1px solid transparent;
    }
    .sidelink:hover{ background:#111827; border-color:var(--muted-2); }
    .sidelink[aria-current="page"]{ background:#111827; border-color:var(--muted-2); box-shadow:0 0 0 1px var(--muted-2) inset; }
    .sidelink .k{width:18px; text-align:center; opacity:.9}
    .section-label{margin:12px 8px 6px; font-size:11px; color:var(--sub); letter-spacing:.08em; text-transform:uppercase}
    .sidebar-footer{margin-top:auto; display:flex; flex-direction:column; gap:6px; padding-top:10px}
    .small{font-size:12px}
    .muted{color:var(--sub)}
    .btn{border:1px solid var(--muted-2);background:#111827;color:var(--ink);padding:10px 14px;border-radius:12px;font-weight:600;cursor:pointer}
    .btn:hover{filter:brightness(1.1)}
    .btn[disabled]{background:#0b1220;border-color:#0b1220;color:#475569;cursor:not-allowed;filter:none}
    .btn.secondary{background:transparent;color:var(--ink);border-color:var(--muted)}
    .btn.toggle{background:#111827;border-color:var(--muted);}
    .btn.toggle[aria-pressed="true"]{border-color:var(--accent); box-shadow:0 0 0 1px var(--accent) inset;}
    
    .pill{background:var(--panel);border:1px solid var(--muted);padding:8px 12px;border-radius:16px;box-shadow:0 1px 2px rgba(0,0,0,.3)}
    .content{flex:1; min-width:0}
    .container{max-width:1200px;margin:0 16px 32px 12px;padding:8px 12px 24px}
    header{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size: clamp(20px, 4vw, 28px);margin:0}
    .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    /* Header info cluster */
    .info-cluster{display:flex;align-items:center;gap:10px;flex-wrap:wrap;background:#0b1220;border:1px solid var(--muted);border-radius:16px;padding:10px 12px}
    .clock-txt{margin-right:12px;display:flex;align-items:center;gap:8px}
    .clock-txt strong{letter-spacing:.2px}


    .row-wrap{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    .grid{display:grid;grid-template-columns:repeat(auto-fit, minmax(320px,1fr));gap:16px;align-items:start}
    .row-nowrap{flex-wrap:nowrap;overflow:visible}
    .row-nowrap > *{flex:0 0 auto}
    .pill{white-space:nowrap}
    /* Analytics grid allows spanning */
    .analytics-grid{grid-template-columns:repeat(auto-fit, minmax(360px,1fr))}
    .span-2{grid-column:1 / -1}

    /* Make header sticky with slight blur on scroll */
    header{position:sticky;top:0;z-index:5;background:linear-gradient(to bottom, rgba(11,15,20,.92), rgba(11,15,20,.70));backdrop-filter:saturate(1.2) blur(4px);border-bottom:1px solid var(--muted);padding:12px 16px;margin:0 -4px 16px;border-radius:0 0 12px 12px}

    /* Micro-interactions */
    .btn{transition:transform .06s ease, box-shadow .2s ease}
    .btn:hover{box-shadow:0 4px 14px rgba(0,0,0,.25)}
    .btn:active{transform:translateY(1px) scale(.995)}
    .card{transition:transform .08s ease, box-shadow .2s ease}
    .card:hover{transform:translateY(-1px);box-shadow:0 4px 18px rgba(0,0,0,.35)}
    /* Log as multi-column on wide screens */
    
    
    .card{background:var(--panel);border:1px solid var(--muted);border-radius:16px;padding:14px 14px 12px;box-shadow:0 2px 12px rgba(0,0,0,.35)}
    .card h3{margin:0 0 8px 0;font-size:18px}
    .progress{height:8px;width:100%;background:#0b1220;border-radius:999px;overflow:hidden;border:1px solid var(--muted)}
    .bar{height:8px;width:0;background:var(--accent);border-radius:999px;transition:width .1s linear}
    .list{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:8px}
    .li{background:#0b1220;border:1px solid var(--muted);border-radius:10px;padding:8px 10px;box-shadow:0 1px 3px rgba(0,0,0,.25);font-size:14px}
    /* Log color helpers */
    .logpiece{font-weight:600}
    .txp{color:var(--accent-warm)}        /* orange for XP gains */
    .tmoney{color:var(--good)}            /* green for currency gains */
    .tbad{color:var(--danger)}
    .red{color:var(--danger)}            /* red for failures/deductions */
    .statrow{display:flex;flex-direction:column;gap:6px;border:1px solid var(--muted);border-radius:12px;padding:10px 12px;background:#0b1220;box-shadow:0 1px 3px rgba(0,0,0,.25)}
    .statheader{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .statname{font-weight:700}
    .codepath{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;color:#a3e0ea}
    .heat-hi{color:var(--danger)}
    .heat-mid{color:var(--accent-warm)}
    .hidden{display:none !important}
    /* Chart */
    .chartWrap{background:#0b1220;border:1px solid var(--muted);border-radius:12px;padding:8px}
    .rangebar{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0 10px}
    .rangebtn{border:1px solid var(--muted);background:#111827;color:var(--ink);padding:6px 10px;border-radius:999px;font-weight:600;cursor:pointer}
    .rangebtn[aria-pressed="true"]{border-color:var(--accent);box-shadow:0 0 0 1px var(--accent) inset}
    .legend{display:flex;gap:12px;align-items:center;font-size:12px;color:var(--sub);margin-top:6px}
    .dot{display:inline-block;width:10px;height:10px;border-radius:50%}
    .dot.money{background:var(--good)}
    .dot.heat{background:var(--accent-warm)}
    
    /* Debug visibility helpers */
    .debug-inline{display:none}
    .debug-block{display:none}
    body.debug .debug-inline{display:inline}
    body.debug .debug-block{display:block}
    footer{margin-top:28px;text-align:center;font-size:12px;color:var(--sub)}
    /* Sleek dialogs */
    dialog{border:none;padding:0;background:transparent}
    dialog::backdrop{background:rgba(2,6,23,.6);backdrop-filter:saturate(1.1) blur(3px)}
    .modal-card{min-width:360px;max-width:520px;background:#0f172a;border:1px solid var(--muted);border-radius:16px;color:var(--ink);padding:16px 18px;box-shadow:0 16px 44px rgba(0,0,0,.6)}
    .modal-card h3{margin:4px 0 10px 0}
    .modal-card .field{display:flex;flex-direction:column;gap:6px;margin:8px 0}
    .modal-card input[type="text"]{width:100%;padding:12px 12px;border-radius:12px;border:1px solid var(--muted);background:#0b1220;color:var(--ink);font-size:16px}
    /* Shop list styling */
    .shop-row{display:flex;align-items:center;justify-content:space-between;gap:10px;border:1px solid var(--muted);background:#0b1220;border-radius:12px;padding:10px;margin:6px 0}
    .shop-row .meta{display:flex;flex-direction:column;gap:2px}
    .shop-row .name{font-weight:800}
    .shop-row .sub{font-size:12px;color:var(--sub)}
    /* Property cards */
    .prop-card{background:#0b1220;border:1px solid var(--muted);border-radius:14px;padding:12px 14px;box-shadow:0 1px 4px rgba(0,0,0,.25);display:flex;flex-direction:column;gap:8px}
    .prop-head{display:flex;align-items:center;justify-content:space-between}
    .prop-name{font-weight:800}
    .prop-meta{display:flex;gap:8px;flex-wrap:wrap}
    .prop-meta .pill{padding:4px 8px}
    .prop-actions{display:flex;gap:8px;margin-top:auto}
    /* Modal */
    .modal{position:fixed;inset:0;background:rgba(0,0,0,.4);display:flex;align-items:center;justify-content:center;z-index:70}
    .modal.hidden{display:none}
    .modal-card{background:#0b1220;border:1px solid var(--muted);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.5);width:min(1000px,90vw);max-height:80vh;overflow:auto;padding:12px}
    .modal-head{display:flex;align-items:center;justify-content:space-between;margin-bottom:8px}
    .store-item,.inv-item-sm{border:1px solid var(--muted);border-radius:10px;padding:8px;margin:6px 0;display:flex;align-items:center;justify-content:space-between;gap:8px;background:#0f172a}
    .inv-item-sm .name,.store-item .name{font-weight:700}
    .store-actions .btn,.inv-actions .btn{padding:4px 8px}

    /* ===== Fancy property cards ===== */
    .prop-card.luxe{position:relative;overflow:hidden;border-radius:16px;background:linear-gradient(180deg,#0f172a 0%, #0b1220 100%);border:1px solid var(--muted);padding:12px 14px;box-shadow:0 6px 20px rgba(0,0,0,.25);transition:transform .2s ease, box-shadow .2s ease}
    .prop-card.luxe:hover{transform:translateY(-2px);box-shadow:0 10px 28px rgba(0,0,0,.35)}
    .prop-hero{height:84px;border-radius:12px;margin:-6px -6px 10px -6px;opacity:.9}
    .tier-0 .prop-hero{background:linear-gradient(135deg,#22314f 0%, #10243d 100%)}
    .tier-1 .prop-hero{background:linear-gradient(135deg,#2a3a3f 0%, #0f3d2e 100%)}
    .tier-2 .prop-hero{background:linear-gradient(135deg,#3c2a4f 0%, #1d274a 100%)}
    .tier-3 .prop-hero{background:linear-gradient(135deg,#4f2a2a 0%, #3a1e45 100%)}
    .prop-head{display:flex;align-items:center;justify-content:space-between;gap:8px}
    .prop-name{font-weight:900;letter-spacing:.2px}
    .prop-loc{display:flex;align-items:center;gap:6px}
    .ico{display:inline-flex;width:14px;height:14px;line-height:1;opacity:.85}
    .prop-meta.fancy{display:flex;flex-wrap:wrap;gap:8px;margin:4px 0 2px}
    .prop-meta.fancy .pill{padding:4px 8px;border-radius:999px;border:1px solid var(--muted);background:#091224}
    .kv{display:flex;align-items:baseline;gap:6px}
    .kv .label{font-size:12px;color:var(--sub)}
    .kv .val{font-weight:900}
    .prop-price{display:flex;gap:12px;flex-wrap:wrap;margin:2px 0 6px}
    .price{display:flex;align-items:center;gap:8px;border:1px solid var(--muted);border-radius:12px;padding:6px 10px;background:#0b1220}
    .price .main{font-size:18px;font-weight:900}
    .price .per{font-size:12px;color:var(--sub)}
    .prop-actions{display:flex;gap:8px;margin-top:auto}
    .prop-actions .btn{flex:1}


    /* Compact vitals meters */
    .meters{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:12px;margin-top:6px}
    .meter{background:#0b1220;border:1px solid var(--muted);border-radius:12px;padding:8px 10px}
    .meter .head{display:flex;align-items:center;justify-content:space-between;margin-bottom:6px}
    .meter .head .label{font-weight:700}
    .progress.slim{height:8px;border-radius:8px}
    .progress.slim .bar{height:100%}
    .meter-inline{display:flex;align-items:center;gap:8px}
    .meter-inline .icon{font-size:14px;line-height:1;filter:saturate(1.1)}
    .meter-inline .codepath{margin-left:8px}
    .meter-inline .progress.tiny{width:120px;height:6px;border-radius:6px}
    .meter-inline .progress.tiny .bar{height:100%}


    .modal-card input[type="text"]:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 2px rgba(59,130,246,.25)}
    .modal-actions{display:flex;justify-content:flex-end;gap:10px;margin-top:14px}

    /* Inventory grid */
    .inv-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px}
    .inv-item{background:#0b1220;border:1px solid var(--muted);border-radius:12px;padding:10px 12px;display:flex;flex-direction:column;gap:8px;box-shadow:0 1px 4px rgba(0,0,0,.25);min-height:128px}
    .inv-item .top{display:flex;align-items:flex-start;justify-content:space-between;gap:8px;margin-bottom:4px}
    .inv-item .name{font-weight:700;font-size:16px;line-height:1.2;word-break:break-word}
    .inv-item .desc{font-size:12px;color:var(--sub);line-height:1.25;margin-top:2px}
    .tag{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--muted);border-radius:999px;padding:4px 8px;font-size:12px;background:#111827;line-height:1.1}
    .tag.slot{}
    .tag.rarity-common{border-color:#374151}
    .tag.rarity-uncommon{border-color:#4ade80}
    .tag.rarity-rare{border-color:#60a5fa}
    .inv-item .actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:auto}
    .inv-item.equipped{box-shadow:0 0 0 1px var(--good) inset}
    .btn.sm{padding:6px 10px;font-size:12px;border-radius:10px}

    /* Equipment (silhouette) */
    .equip-wrap{display:grid;grid-template-columns:200px 1fr;gap:16px;align-items:start;margin-top:10px}
    @media (max-width: 720px){ .equip-wrap{grid-template-columns:1fr} }
    .equip-figure{position:relative;width:200px;height:280px;border:1px solid var(--muted);border-radius:14px;background:#0b1220;box-shadow:inset 0 0 0 1px rgba(255,255,255,.03)}
    .equip-figure svg{position:absolute;inset:0;height:100%;width:100%}
    .slot{position:absolute;display:inline-flex;align-items:center;gap:6px;padding:6px 8px;border-radius:999px;border:1px solid var(--muted);background:#111827;color:var(--ink);font-weight:700;cursor:pointer;box-shadow:0 2px 6px rgba(0,0,0,.25)}
    .slot small{font-weight:600;color:var(--sub)}
    .slot:hover{border-color:var(--muted-2)}
    .slot .dot{width:8px;height:8px;border-radius:50%;background:#6b7280}
    .slot.filled .dot{background:var(--good)}
    .slot.badge{position:static}
    .slots-list{display:grid;grid-template-columns:repeat(auto-fit, minmax(180px,1fr));gap:8px}
    .equip-panel{display:flex;flex-direction:column;gap:8px}
    .equip-legend{font-size:12px;color:var(--sub)}
    /* Compact overlay dots */
    .slot.dotbtn{padding:0;width:16px;height:16px;border-radius:999px;border:1px solid var(--muted-2);background:#0f172a;box-shadow:none}
    .slot.dotbtn .dot{width:8px;height:8px;margin:0 auto;background:#6b7280}
    .slot.dotbtn.filled .dot{background:var(--good)}
    .slot.dotbtn:hover{border-color:var(--accent)}
    /* Sleek chips list on the right */
    .slots-list{display:grid;grid-template-columns:repeat(auto-fit, minmax(280px,1fr));gap:10px}
    .slot.badge{position:static;display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:16px;background:#111827;border:1px solid var(--muted);box-shadow:0 1px 4px rgba(0,0,0,.25);cursor:pointer}
    .slot.badge .dot{flex:0 0 8px}
    .slot.badge strong{font-weight:800}
    .slot.badge small{margin-left:auto}


    /* Responsive sidebar toggle */
    .collapse-btn{display:none}
    @media (max-width: 860px){
      :root{ --sidebar-w: 220px; }
      .app{ position:relative; }
      .collapse-btn{
        display:inline-flex; align-items:center; justify-content:center;
        border:1px solid var(--muted); background:#111827; color:var(--ink);
        border-radius:10px; padding:6px 10px; cursor:pointer;
      }
      aside.sidebar{ position:fixed; left:0; top:0; transform:translateX(-100%); transition:transform .2s ease; z-index:40; }
      aside.sidebar.open{ transform:translateX(0%); }
      .content{ padding-left:0 }
    }
  
.slotCanvas-frame .fadeMaskTop,.slotCanvas-frame .fadeMaskBot{
  position:absolute; left:0; right:0; height:22px; z-index:2; pointer-events:none;
  background: linear-gradient(180deg, rgba(11,19,42,1), rgba(11,19,42,0));
}
.slotCanvas-frame .fadeMaskBot{ bottom:0; top:auto; transform:scaleY(-1); }
.slotCanvas-frame .bars{ position:absolute; inset:0; pointer-events:none; z-index:2; }

/* Hide inline hint until reels settle */
.slotCanvas-wrap.slot-pending .slotCanvas-hint{
  visibility: hidden;
  opacity: 0;
  transition: opacity .2s ease;
}
/* Optionally dim the frame while spinning */
.slotCanvas-wrap.slot-pending .slotCanvas-frame{ filter: saturate(0.95); }

/* Keep Spin/Auto size consistent and full-width */
.slotCanvas-controls .btn{ width:100%; min-height:48px; padding:12px 16px; }
.slotCanvas-controls .btn:active{ transform:none !important; }
.slotCanvas-box{ flex:1 1 auto; width:100%; }


/* --- Slot controls: lock button size & prevent press-shrink --- */
.slotCanvas-controls .btn{
  width: 100% !important;
  min-height: 52px !important;
  padding: 14px 16px !important;
}
.slotCanvas-controls .btn:hover,
.slotCanvas-controls .btn:active{
  transform: none !important;
}
.slotCanvas-controls .btn[disabled]{
  transform: none !important;
  filter: none !important;
}


/* Layout: stack frame and controls; make both full width to match */
.slotCanvas-wrap{ display:flex; flex-direction:column; align-items:stretch; gap:14px; }
.slotCanvas-box{ width:100%; }
.slotCanvas-frame{ width:100%; }
.slotCanvas-controls{ width:100%; }
.slotCanvas-controls .btn{ width:100% !important; min-height:52px !important; padding:14px 16px !important; }


/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="visual-flair-upgrade">
  /* --- Visual Flair Pack -------------------------------------- */
  :root{
    --bg-1: #0f1224;
    --bg-2: #13162a;
    --panel: #151a2e;
    --panel-2: #0e1327;
    --border: rgba(255,255,255,.06);
    --primary: #8b5cf6;   /* violet */
    --accent:  #22d3ee;   /* cyan   */
    --success: #34d399;
    --warning: #f59e0b;
    --danger:  #f87171;
    --text:    #e5e7eb;
    --muted:   #a7b0c3;
  }

  /* Background: layered gradient with soft vignette */
  body{
    background:
      radial-gradient(1200px 800px at 10% -10%, rgba(139,92,246,.18), transparent 60%),
      radial-gradient(1000px 700px at 100% 0%, rgba(34,211,238,.12), transparent 65%),
      linear-gradient(180deg, var(--bg-1), var(--bg-2));
    color: var(--text);
  }

  /* Cards: glassy panels with soft shadow */
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    border: none;
    border-radius: 16px;
    box-shadow: 0 10px 28px rgba(2,6,23,.35), inset 0 1px 0 rgba(255,255,255,.03);
    backdrop-filter: blur(6px);
    transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease;
    will-change: transform;
    animation: floatIn .35s ease both;
  }
  .card:hover{
    transform: translateY(-2px);
    box-shadow: 0 16px 36px rgba(2,6,23,.5), inset 0 1px 0 rgba(255,255,255,.04);
    
  }
  @keyframes floatIn{
    from{ opacity:0; transform: translateY(6px); }
    to{ opacity:1; transform: translateY(0); }
  }

  /* Pills (meta chips under rental cards) */
  .pill{
    background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border: none;
    border-radius: 999px;
  }

  /* Buttons with subtle gradient + ripple */
  .btn{
    position: relative;
    overflow: hidden;
    border-radius: 12px;
    transition: transform .12s ease, box-shadow .12s ease, background .2s ease, border-color .2s ease;
    box-shadow: 0 6px 16px rgba(2,6,23,.25);
  }
  .btn:hover{ transform: translateY(-1px); }
  .btn:active{ transform: translateY(0); }
  .btn.primary, .btn:not(.secondary):not(.ghost){
    background: linear-gradient(90deg, rgba(139,92,246,.28), rgba(34,211,238,.28));
  }
  .btn.secondary{
    background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    border: none;
  }
  .btn .ripple{
    position:absolute; pointer-events:none; border-radius:50%;
    transform: scale(0); opacity:.55; background: rgba(255,255,255,.45);
    animation: ripple .6s ease-out;
  }
  @keyframes ripple{
    to{ transform: scale(4); opacity:0; }
  }

  /* Progress bars with animated sheen */
  .progress{ background: rgba(255,255,255,.045); border-radius: 999px; overflow: hidden; }
  .progress .bar{
    background: linear-gradient(90deg, var(--primary), var(--accent));
    transition: width .45s ease;
    position: relative;
  }
  .progress .bar::after{
    content:""; position:absolute; inset:0;
    background: linear-gradient(45deg,
      rgba(255,255,255,.18) 25%, transparent 25%, transparent 50%,
      rgba(255,255,255,.18) 50%, rgba(255,255,255,.18) 75%, transparent 75%, transparent);
    background-size: 24px 24px;
    animation: slideSheen 2s linear infinite;
    mix-blend-mode: overlay;
    opacity: .35;
    pointer-events: none;
  }
  @keyframes slideSheen{
    from{ background-position: 0 0; }
    to{   background-position: 24px 0; }
  }

  /* Tabs or active controls highlighting (generic) */
  .active, .tab.active, .nav .active{
    box-shadow: inset 0 -2px 0 0 var(--accent);
    color: #fff;
  }

  /* Muted text remains readable on dark bg */
  .muted{ color: var(--muted); }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  /* Layout helpers for card headers */
  .row.between{ justify-content: space-between; }
  .row.nowrap{ flex-wrap: nowrap; }
  .hq-head h3{ margin: 0; }
  .hq-head{ margin-bottom: 8px; }
  @media (max-width: 720px){
    .hq-head{ flex-wrap: wrap; gap: 8px 12px; }
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  /* HQ tabs placement */
  .hq-head{ margin-bottom: 10px; }
  .hq-head #hqActions{ margin-bottom: 8px; }
  .hq-head h3{ margin: 0; }
  @media (max-width: 720px){
    .hq-head #hqActions{ gap: 6px; }
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  /* HQ tabs above the HQ card */
  .hq-tabs{ margin: 0 0 -10px 0; padding-left: 12px; }
  .hq-tabs .row{ gap: 8px; flex-wrap: wrap; }
  .hq-tabs .btn{ border-bottom-left-radius: 0; border-bottom-right-radius: 0; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  .hq-col{ display:block; }
  .hq-tabs{ margin: 0 0 -10px 0; padding-left: 12px; }
  .hq-tabs .row{ gap: 8px; flex-wrap: wrap; }
  .hq-tabs .btn{ border-bottom-left-radius: 0; border-bottom-right-radius: 0; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="hq-tabs-nudge">
  /* Move HQ tabs slightly left (≈20px), no overlap */
  .hq-tabs{
    margin: 0 0 8px -8px;  /* was 12px; with existing padding-left:12px net ≈4px indent */
    position: static;
    z-index: auto;
  }
  .hq-tabs .btn{
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="topbar-darken">
  /* Soften the top info cluster (Clock/Balance/Heat/Autosave/Reset) */
  .info-cluster{
    border: none !important;
    background: var(--panel-2) !important; /* slate black tone */
    box-shadow: inset 0 1px 0 rgba(255,255,255,.03), 0 6px 14px rgba(2,6,23,.28);
  }
  .info-cluster .pill{ border: none; box-shadow: inset 0 1px 0 rgba(255,255,255,.04); }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="analytics-spent-dot">.dot.spent{background:var(--danger);}


/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="log-ts-style">
  #logList .ts{
    color: var(--muted);
    margin-right: .6rem;
    font-size: .95em;
    opacity: .85;
    font-variant-numeric: tabular-nums;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="rarity-text-colors">
  /* Rarity-to-color mapping for Activity Log item mentions */
  .rarity-text-common{ color:#9ca3af; }   /* gray */
  .rarity-text-uncommon{ color:#34d399; } /* emerald/green */
  .rarity-text-rare{ color:#60a5fa; }     /* blue */



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="header-logo-style">
  .header-logo{
    width: 48px;
    height: 48px;
    border-radius: 10px;
    background:#111827;
    border:1px solid var(--muted);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    font-size: 20px;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="recruit-cand-grid-2up">
  /* Recruitment candidates: 2-up grid on desktop, 1-up on small screens */
  #recruitCandidates{
    display: grid;
    grid-template-columns: repeat(2, minmax(260px, 1fr));
    gap: 12px;
    align-items: stretch;
  }
  @media (max-width: 820px){
    #recruitCandidates{ grid-template-columns: 1fr; }
  }
  /* Make nested candidate cards breathe a bit inside the grid */
  #recruitCandidates > .card{ margin: 0; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
  .badge{
    margin-left:auto;
    min-width:18px; height:18px;
    border-radius:10px;
    background:var(--danger);
    color:#fff; font-size:11px; font-weight:700;
    display:inline-flex; align-items:center; justify-content:center;
    padding:0 6px; line-height:1; box-shadow:0 0 0 1px rgba(0,0,0,.25) inset;
  }
  .mail-grid{ display:grid; gap:12px; grid-template-columns: 320px 1fr; }
  @media (max-width: 820px){ .mail-grid{ grid-template-columns: 1fr; } }
  .mail-left{ background:var(--panel); border:1px solid var(--muted); border-radius:12px; padding:6px; }
  .mail-right{ background:var(--panel); border:1px solid var(--muted); border-radius:12px; padding:12px; min-height:240px; }
  .mail-item{ display:flex; flex-direction:column; gap:2px; padding:10px; border-radius:10px; cursor:pointer; border:1px solid transparent; }
  .mail-item:hover{ background:#111827; border-color:var(--muted-2); }
  .mail-item.selected{ background:#111827; border-color:var(--accent); box-shadow:0 0 0 1px var(--accent) inset; }
  .mail-item .sender{ font-weight:700; }
  .mail-item.unread .sender::after{ content:' •'; color:var(--accent); }
  .mail-item .subj{ color:var(--ink); opacity:.9; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  .mail-item .meta{ color:var(--sub); font-size:12px; display:flex; gap:8px; }
  .mail-body{ white-space:pre-wrap; line-height:1.5; }
  @keyframes bump { 0%{transform:scale(1)} 40%{transform:scale(1.2)} 100%{transform:scale(1)} }
  .badge.bump { animation:bump .28s ease; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-retro-style">
  /* Email client: retro black terminal vibe */
  #view-mail, #view-mail *{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
    letter-spacing: .2px;
  }
  #view-mail .card,
  #view-mail .mail-left,
  #view-mail .mail-right{
    background: #000 !important;
    border-color: #1b1b1b !important;
    color: var(--ink);
  }
  #view-mail h3, #view-mail h4{ color: var(--ink); }
  #view-mail .mail-item{ background:#000; border-color:#1b1b1b; }
  #view-mail .mail-item:hover{ background:#080808; border-color:#2a2a2a; }
  #view-mail .mail-item.selected{ background:#080808; border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent) inset; }
  #view-mail .mail-body{ color: var(--ink); }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-selection-enhance">
  /* Stronger selection state for left pane */
  #view-mail .mail-item{ position: relative; }
  #view-mail .mail-item.selected{
    background:#0a0a0a !important;
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 1px var(--accent) inset, 0 0 12px rgba(0,0,0,.2);
  }
  #view-mail .mail-item.selected::before{
    content:''; position:absolute; left:-2px; top:6px; bottom:6px; width:4px;
    border-radius:4px; background: var(--accent);
    box-shadow: 0 0 8px var(--accent);
  }
  #view-mail .mail-item.selected .sender{ color:#fff; }
  #view-mail .mail-item.selected .subj{ color:#e6e6e6; opacity:1; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-crt-style">
  /* Toggle chip */
  #view-mail .mail-chip{
    float:right; margin-left:8px; padding:4px 10px; font-size:12px; border-radius:999px;
    background:#0a0a0a; border:1px solid #2a2a2a; color:var(--ink); cursor:pointer;
  }
  #view-mail.crt-on .mail-chip{ border-color: var(--accent); color: var(--accent); }

  /* Positioning for scanline overlay */
  #view-mail .mail-left, #view-mail .mail-right{ position: relative; overflow: hidden; }

  /* CRT theme: soft green text + scanlines + glow */
  #view-mail.crt-on{ --crt-green: #b7ffb7; }
  #view-mail.crt-on, #view-mail.crt-on *{ text-shadow: 0 0 4px rgba(129,255,146,0.34); }
  #view-mail.crt-on .mail-left, #view-mail.crt-on .mail-right, #view-mail.crt-on .card{
    color: var(--crt-green);
  }
  #view-mail.crt-on .mail-item .sender,
  #view-mail.crt-on .mail-item .subj,
  #view-mail.crt-on .mail-body{ color: var(--crt-green); }
  #view-mail.crt-on .mail-left::after, #view-mail.crt-on .mail-right::after{
    content:''; position:absolute; inset:0; pointer-events:none; border-radius:inherit;
    background:
      repeating-linear-gradient(0deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 1px, transparent 2px, transparent 4px);
    opacity:.35;
    mix-blend-mode: overlay;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-crt-colors">
  /* CRT color tuning: keep body green, change "white" accents to yellow, sender to cyan */
  #view-mail.crt-on {
    --crt-green: #b7ffb7;
    --crt-yellow: #ffe08a;
    --crt-cyan: #7ad7ff;
  }
  /* Right pane subject (was white) -> yellow */
  #view-mail.crt-on #mailSubj{ color: var(--crt-yellow) !important; }
  /* Meta line: sender -> cyan; time/labels -> soft yellow */
  #view-mail.crt-on #mailFrom{ color: var(--crt-cyan) !important; }
  #view-mail.crt-on .mail-right .small{ color: rgba(255, 224, 138, 0.95) !important; }
  /* Left list: sender -> cyan; selected subject (was near-white) -> yellow */
  #view-mail.crt-on .mail-item .sender{ color: var(--crt-cyan) !important; }
  #view-mail.crt-on .mail-item.selected .sender{ color: var(--crt-cyan) !important; }
  #view-mail.crt-on .mail-item.selected .subj{ color: var(--crt-yellow) !important; opacity:1 !important; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-noncrt-colors">
  /* Non-CRT theme colours for Email */
  #view-mail:not(.crt-on) #mailSubj{ color:#fff !important; }
  #view-mail:not(.crt-on) #mailFrom{ color: var(--accent) !important; }
  #view-mail:not(.crt-on) #mailAgo{ color: var(--accent-warm) !important; font-weight:700; }

  /* Left list */
  #view-mail:not(.crt-on) .mail-item .sender{ color: var(--accent) !important; }
  #view-mail:not(.crt-on) .mail-item .subj{ color: #e5e7eb !important; opacity:.95; }
  #view-mail:not(.crt-on) .mail-item .meta{ color: var(--accent-warm) !important; opacity:.95; }

  /* Selected state refinement */
  #view-mail:not(.crt-on) .mail-item.selected .subj{ color:#fff !important; opacity:1 !important; }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style>
/* === Equipment Panel Hard Alignment Reset (v4) === */
.equip-wrap, .equip-panel, .slots-list {
  text-align: left !important;
  justify-items: start !important;
  align-items: start !important;
}

/* Ensure each slot content anchors left and fills row neatly */
.equip-panel .slot.badge {
  display: flex !important;
  justify-content: flex-start !important;
  align-items: center !important;
  width: 100% !important;
}

/* Reset any auto margins and tiny font on equipped text */
.equip-panel .slot.badge small {
  margin-left: 6px !important;
  margin-right: 0 !important;
  font-size: 1em !important;
  text-align: left !important;
  flex: 0 0 auto !important;
}

/* Nuke global small auto-margins inside the equipment area */
.equip-wrap small, .equip-panel small, .slots-list small {
  margin-left: 0 !important;
  margin-right: 0 !important;
}

/* As a final guard, prevent right alignment via flex on any inner wrappers */
.equip-wrap *[style*="text-align:right"],
.equip-panel *[style*="text-align:right"] {
  text-align: left !important;
}



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="mail-theme-polish-v2">
  /* === Email UI Polish (non-functional) =====================================
     - Read vs Unread: darker text on left pane for read items
     - Visual refresh to better match overall UI theme (violet/cyan accents)
     - Keep CRT theme intact; only non-CRT gets sans-serif + gradients
  ============================================================================ */

  /* Use app's default type in non-CRT mode (CRT keeps monospace) */
  #view-mail:not(.crt-on), 
  #view-mail:not(.crt-on) *{
    font-family: inherit !important;
    letter-spacing: normal !important;
  }

  /* Read vs Unread state in left list */
  /* Treat anything not .unread as read (no JS changes required) */
  #view-mail .mail-item:not(.unread) .sender{
    font-weight: 600 !important;
    color: var(--sub) !important;
    opacity: .9 !important;
  }
  #view-mail .mail-item:not(.unread) .subj{
    color: var(--sub) !important;
    opacity: .85 !important;
  }
  #view-mail .mail-item:not(.unread) .meta{
    color: var(--muted) !important;
    opacity: .85 !important;
  }
  /* Keep unread strong and vivid */
  #view-mail .mail-item.unread .sender{
    font-weight: 800 !important;
  }

  /* Panels adopt "card" look in non-CRT */
  #view-mail:not(.crt-on) .mail-left,
  #view-mail:not(.crt-on) .mail-right{
    background: linear-gradient(180deg, rgba(255,255,255,.055), rgba(255,255,255,.025)) !important;
    border: none !important;
    box-shadow: 0 10px 28px rgba(2,6,23,.30), inset 0 1px 0 rgba(255,255,255,.03) !important;
  }

  /* Left list items: subtle separators + hover/selected harmony */
  #view-mail .mail-item{
    position: relative;
    background: transparent;
    border: 1px solid rgba(255,255,255,.06);
  }
  #view-mail .mail-item + .mail-item{
    margin-top: 6px;
  }
  #view-mail .mail-item:hover{
    background: rgba(255,255,255,.035) !important;
    border-color: rgba(255,255,255,.12) !important;
  }
  #view-mail .mail-item.selected{
    background: rgba(34,211,238,.10) !important; /* cyan tint */
    border-color: var(--accent) !important;
    box-shadow: 0 0 0 1px var(--accent) inset, 0 0 18px rgba(34,211,238,.15) !important;
  }

  /* Right pane headings & meta harmony in non-CRT */
  #view-mail:not(.crt-on) #mailSubj{
    color: #fff !important;
    text-shadow: 0 1px 0 rgba(0,0,0,.2);
  }
  #view-mail:not(.crt-on) .mail-right .small{
    color: var(--muted) !important;
  }

  /* Badge tone siiiightly softer */
  #view-mail .badge{
    background: var(--danger);
    opacity: .95;
  }

  /* Respect existing CRT colors; just ensure read-state still dims inside CRT */
  #view-mail.crt-on .mail-item:not(.unread) .sender,
  #view-mail.crt-on .mail-item:not(.unread) .subj,
  #view-mail.crt-on .mail-item:not(.unread) .meta{
    opacity: .8 !important;
    filter: saturate(.85);
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="slot-canvas-styles">
/* === Canvas Slot (3D-ish) =============================================== */
.slotCanvas-wrap{ display:flex; gap:16px; align-items:center; flex-wrap:wrap; }
.slotCanvas-box{
  position:relative; padding:16px; border-radius:14px;
  background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.015));
  border:1px solid rgba(255,255,255,.08);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05), 0 10px 26px rgba(0,0,0,.4);
}
.slotCanvas-frame{ width:100%; border-radius: 12px; overflow:hidden;
  background: radial-gradient(120% 110% at 50% 50%, rgba(20,26,45,.95), rgba(5,9,25,.98));
  box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), inset 0 8px 22px rgba(255,255,255,.03);
}
.slotCanvas-frame:after{ /* glassy sheen */
  content:""; position:absolute; inset:0; pointer-events:none; border-radius:inherit;
  background: linear-gradient(90deg, rgba(255,255,255,.20), transparent 28%, transparent 72%, rgba(255,255,255,.12));
  opacity:.25; mix-blend-mode: overlay;
}
.slotCanvas-divider{ width:2px; height:72px; background:rgba(255,255,255,.08); border-radius:2px; }
.slotCanvas-controls{ display:flex; flex-direction:column; gap:8px; min-width: 190px;}
.slotCanvas-hint{ min-height:2.2em;}
/* Win pulse */
.slotCanvas-frame.win{ animation: slotCanvasPulse .9s ease-out 0s 1; }
@keyframes slotCanvasPulse{
  0%{ box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), 0 0 0 rgba(0,0,0,0); }
  30%{ box-shadow: inset 0 0 0 1px rgba(52,211,153,.6), 0 0 24px rgba(52,211,153,.55); }
  100%{ box-shadow: inset 0 0 0 1px rgba(255,255,255,.05), 0 0 0 rgba(0,0,0,0); }
}
/* removed fixed small-screen slotCanvas-frame sizing to keep responsive width */



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="slotButtonGuard">
.slotCanvas-controls .btn{ width:100% !important; min-height:52px !important; padding:14px 16px !important; }
.slotCanvas-controls .btn:hover,.slotCanvas-controls .btn:active{ transform:none !important; }

/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="slotWrapGuard">
.slotCanvas-wrap{ display:flex; flex-direction:column; align-items:stretch; gap:14px; }
.slotCanvas-box,.slotCanvas-frame,.slotCanvas-controls{ width:100%; }

/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<style id="brand-logo-css">
.brand-logo-wrap{ display:flex; flex-direction:column; align-items:flex-start; }
.brand-logo-img{ height: 88px; width:auto; display:block; }
.brand-tagline{ margin-top: 6px; font-size: 20px; line-height: 1.3; opacity: 0.95; font-weight: 500; }
@media (max-width: 640px){
  .brand-logo-img{ height: 68px; }
  .brand-tagline{ font-size: 18px; }
}
</style>
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#111111">

</head>
<body>
<script>window.slotDelayLog = true;</script>
<!-- DISCLAIMER: This is a purely fictional idle-game prototype.
       It is not advice or instruction for real-world actions. -->
<div class="app">
<aside class="sidebar" id="sidebar">
<div class="brand">
<div class="logo">CI</div>
<div class="name">Crimidle</div>
</div>
<div class="section-label">Main</div>
<nav aria-label="Main Sections" class="sidenav" role="tablist">
<a class="sidelink" data-tab="mail" id="mailLink">
<span class="k">📫</span>
<span>Email</span>
<span aria-label="unread messages" class="badge hidden" id="mailBadge">0</span>
</a>
<a class="sidelink" data-tab="headquarters"><span class="k">🏢</span><span>Headquarters</span></a>
<a class="sidelink" data-tab="property"><span class="k">🏠</span><span>Property Market</span></a>
<a aria-current="page" class="sidelink" data-tab="activities"><span class="k">🎲</span><span>Activities</span></a>
<a class="sidelink" data-tab="gambling"><span class="k">🎰</span><span>Gambling</span></a>
<a class="sidelink" data-tab="recruitment"><span class="k">🧑‍🤝‍🧑</span><span>Recruitment</span></a>
<a class="sidelink" data-tab="stats"><span class="k">📊</span><span>Stats</span></a>
<a class="sidelink" data-tab="inventory"><span class="k">🎒</span><span>Inventory</span></a>
<a class="sidelink" data-tab="territory" id="territoryLink"><span class="k">⚔️</span><span>Territory Battle</span></a>
<a class="sidelink" data-tab="upgrades"><span class="k">🛠️</span><span>Upgrades (WIP)</span></a>
<a class="sidelink" data-tab="shop"><span class="k">🛒</span><span>Shop</span></a>
<a class="sidelink" data-tab="analytics"><span class="k">📈</span><span>Analytics</span></a>
</nav>
<div class="sidebar-footer">
<button class="btn secondary" id="debugBtn" title="Show or hide code details">Debug: Off</button>
<button class="btn secondary collapse-btn" id="toggleSidebarBtn">Close Menu</button>
<div class="small muted">Fictional prototype</div>
</div>
</aside>
<main class="content">
<div class="container">
<header>
<div class="row">
<button class="collapse-btn" id="openSidebarBtn">Menu</button>
<div class="row" style="align-items:center; gap:10px"><img alt="CrimIdle — Start with nothing. Become legend." class="brand-logo-img" src="crimidle-logo-ui-nobg.png"/></div>
</div>
<div class="row headerbar" style="justify-content:flex-end"><div class="info-cluster">
<div class="clock-txt" id="clockTxt">Clock: <strong><span id="clockText">Day 1 — 00:00</span></strong>
<span class="small muted codepath debug-block">Source: <strong>state.time.epochMs + state.time.gameMs</strong> • scale <strong>GAME_TIME_SCALE</strong> • advanced by <strong>advanceGameTime(dtMs)</strong></span>
</div>
<div class="pill">Balance: <strong>£<span id="balanceValue">0</span></strong></div>
<div class="pill" id="heatPill">
              Heat: <strong><span id="heatValue">0</span></strong>
<div class="small codepath debug-block">
                Source: <strong>state.heat</strong> (0..100) • Decay: <span id="heatDecayText">-1 per 5s</span> • Gains: <span id="heatGainsText">+4 success, +7 fail</span><br/>
                Penalty: <span id="heatPenaltyText">successChance() − (0.002 × heat)</span>
</div></div>
<div class="pill" id="autosavePill">
<span class="muted">Autosave</span>:
              <span class="codepath debug-inline"><strong id="saveKeyText">localStorage['idle-underworld-save-v1']</strong></span>
<span class="muted debug-inline"> • Last save: <span id="lastSaveText">never</span></span>
<button class="btn secondary debug-inline" id="copyKeyBtn" style="padding:6px 10px">Copy key</button>
</div>
<button class="btn secondary debug-block" id="sim10mBtn" title="Simulate 10 minutes offline (real time)">Sim +10m</button>
<button class="btn secondary debug-block" id="sim1hBtn" title="Simulate 1 hour offline (real time)">Sim +1h</button>
<button class="btn secondary debug-block" id="giveCashBtn" title="Grant £100">+£100</button>
<button class="btn secondary debug-block" id="giveXPBtn" title="Grant XP to all stats">+XP</button>
<button class="btn secondary" id="resetBtn">Reset</button>
</div>
</div>
</header>
<!-- Views -->
<section aria-hidden="true" class="hidden" id="view-headquarters" role="tabpanel">
<div class="grid two">
<div class="hq-col">
<div class="hq-tabs"><div class="row" id="hqActions" style="gap:8px;flex-wrap:wrap">
<button class="btn" id="btnHQStorage">Storage</button>
<button class="btn secondary" id="btnHQGarage">Garage</button>
</div></div>
<div class="card">
<div class="hq-head">
<h3>Headquarters</h3>
</div>
<div class="muted" id="hqNone">No headquarters selected. Go to <strong>Property → Holdings</strong> and choose <em>Set as HQ</em>.
                <div class="small codepath debug-block">Debug: hqId=<strong id="hqDbgId">null</strong>; holdings=<strong id="hqDbgHoldN">0</strong>; offers=<strong id="hqDbgOffN">0</strong>; pool=<strong id="hqDbgPoolN">?</strong></div>
<div class="row"><button class="btn secondary debug-block" id="hqRefresh">Refresh HQ</button></div>
</div>
<div class="hidden" id="hqDetails">
<div class="row" style="gap:8px;flex-wrap:wrap">
<div class="pill">Name: <strong id="hqName">—</strong></div>
<div class="row" style="gap:12px;flex-wrap:wrap;margin:10px 0 12px 0">
<button class="btn" id="btnCrewJobs">Crew Jobs</button>
<span class="muted debug-inline">• UI: <strong>renderCrewActionsPanel()</strong></span>
</div>
<div aria-hidden="true" class="card hidden" id="hqCrewPanel">
<h4>Crew Actions</h4>
<div id="hqCrewList"></div>
<div class="small codepath debug-block">Source: <strong>state.recruitment.crew</strong> • UI: <strong>renderCrewActionsPanel()</strong></div>
</div>
<div class="pill">Location: <strong id="hqLoc">—</strong></div>
</div>
<div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
<div class="pill">Storage: <strong id="hqStorage">—</strong></div>
<div class="pill">Occupied: <strong id="hqStorageUsed">0</strong>/<strong id="hqStorageCap">0</strong></div>
<div class="pill">Garage: <strong id="hqGarage">—</strong></div>
<div class="pill">Monthly: <strong id="hqMonthly">—</strong></div>
</div>
<div class="small codepath debug-block">Source: <strong>state.hq.propertyId</strong> → lookup in <strong>state.properties.holdings</strong></div>
</div>
</div>
</div>
  <div id="hqBasement3D" class="hidden" style="margin-top:12px">
    <div class="small muted" style="margin-bottom:6px">HQ: Virtual Space</div>
    <div id="basement3DWrap" style="position:relative; height:260px; background:#0b0f14; border:1px solid var(--muted-2); border-radius:10px; overflow:hidden">
      <canvas id="basement3DCanvas"></canvas>
      <div id="basement3DHint" style="position:absolute; left:8px; bottom:8px; font-size:12px; color:#94a3b8; background:rgba(15,23,42,0.6); padding:4px 6px; border-radius:6px">
        Click to look around • WASD to move • Esc to release mouse
      </div>
    </div>
  </div>

<div class="card">
<h3>Planned Systems</h3>
<ul class="list">
<li class="li">Upgrades: security, stash size, counterfeit lab</li>
<li class="li">Staff: recruiters, fences, fixers</li>
<li class="li">Passive income buildings &amp; upkeep</li>
</ul>
<p class="small muted">These are placeholders — no mechanics wired yet.</p>
</div>
</div>
<div aria-hidden="true" aria-label="HQ Storage Manager" class="modal hidden" id="storageModal" role="dialog">
<div class="modal-card">
<div class="modal-head">
<h4>HQ Storage</h4>
<button class="btn sm secondary" id="closeStorage">Close</button>
</div>
<div class="row" style="gap:8px;flex-wrap:wrap;margin-bottom:8px">
<div class="pill">Capacity: <strong id="storeCap">0</strong></div>
<div class="pill">Used: <strong id="storeUsed">0</strong></div>
<div class="pill">Free: <strong id="storeFree">0</strong></div>
</div>
<div class="grid two">
<div class="card">
<h4>Inventory</h4>
<div id="invForStore"></div>
</div>
<div class="card">
<h4>HQ Storage</h4>
<div id="gridStorage"></div>
</div>
</div>
<div class="small codepath debug-block">Source: <strong>state.storage</strong> (items[], cap from HQ holding.storage) • UI: <strong>renderStorageManager()</strong></div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-recruitment" role="tabpanel">
<div class="row" style="gap:12px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Daily rotation: <strong id="recruitDayKey">—</strong></div>
<div class="pill">Next refresh: <strong id="recruitNextRefresh">—</strong></div>
<span class="muted debug-inline">• Data: <strong>RECRUIT_NAME_POOL</strong></span>
</div>
<div class="grid two">
<div class="card">
<h3>Daily Candidates</h3>
<div id="recruitCandidates"></div>
<div class="small codepath debug-block" id="recruitDbg">Debug: dayKey=<strong id="recruitDbgKey">—</strong>; cands=<strong id="recruitDbgN">0</strong>; crew=<strong id="recruitDbgCrewN">0</strong></div>
<div class="small codepath debug-block">Source: <strong>state.recruitment.daily</strong> • UI: <strong>renderRecruitmentView()</strong></div>
</div>
<div class="card">
<h3>Your Crew <span class="muted small">(max 3)</span></h3>
<div id="crewList"></div>
<div class="small codepath debug-block">Source: <strong>state.recruitment.crew</strong> • Actions: <strong>doCrewPickpocket()</strong></div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-property" role="tabpanel">
<div class="row" id="propertyCats" style="margin:6px 0 10px 0">
<button aria-pressed="true" class="btn toggle" id="btnPropRent" title="Category: Rent">Rent</button>
<button aria-pressed="false" class="btn toggle" id="btnPropBuy" title="Category: Buy">Buy</button>
<button aria-pressed="false" class="btn toggle" id="btnPropHoldings" title="Category: Holdings">Holdings</button>
</div>
<div class="catwrap" id="prop-rent">
<div class="row" style="gap:12px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Daily rotation: <strong id="rentDayKey">—</strong></div>
<div class="pill">Next refresh: <strong id="rentNextRefresh">—</strong></div>
</div>
<div class="grid" id="rentOffers"></div>
<div class="small codepath debug-block">Source: <strong>state.properties.daily</strong> • Pool: <strong>RENTAL_POOL</strong> • UI: <strong>renderRentOffers()</strong></div>
</div>
<div class="catwrap hidden" id="prop-buy">
<div class="grid">
<div class="card">
<h3>Buy a Property</h3>
<p class="small">Purchase **fronts**, **lockups**, and **workshops**. (Placeholder)</p>
<div class="row"><button class="btn secondary" disabled="">Open Marketplace (WIP)</button></div>
<div class="small codepath debug-block">Source: <strong>view-property → prop-buy</strong></div>
</div>
</div>
</div>
<div class="catwrap hidden" id="prop-holdings">
<div class="grid" id="holdingsList"></div>
<div class="small codepath debug-block">Source: <strong>state.properties.holdings[]</strong> • UI: <strong>renderHoldings()</strong></div>
</div>
</section>
<section id="view-activities" role="tabpanel">
<div class="row" id="activityCats" style="margin:6px 0 10px 0">
<button aria-pressed="true" class="btn toggle" id="btnCatPetty" title="Category: Petty Crime">Petty Crime</button>
<button aria-pressed="false" class="btn toggle" id="btnCatSmall" title="Category: Small Jobs">Small Jobs</button>
</div>
<div class="catwrap" id="cat-petty">
<div class="grid">
<div class="card" data-category="petty">
<h3>Pickpocket (Starter Action)</h3>
<p class="small">Make a quick attempt to lift some spare change. Outcomes are random and purely fictional.</p>
<div class="row" style="margin:10px 0 8px">
<div aria-label="Cooldown progress" aria-live="polite" class="progress">
<div class="bar" id="progressBar"></div>
</div>
</div>
<div class="row">
<div class="small muted">
                  Chance of success: <strong><span id="chanceValue">50</span>%</strong>
<span class="small debug-inline">(<span id="chanceDetail"></span>)</span>
</div>
<button class="btn" id="pickBtn">Attempt Pickpocket</button>
</div>
</div>
</div>
</div>
<div class="card" data-category="petty" id="card-searchbags">
<h3>Search bags (Unlocks at Sleight L1)</h3>
<p class="small">Higher rewards than pickpocketing, but a lower base chance. Purely fictional.</p>
<div class="row" style="margin:10px 0 8px">
<div aria-label="Cooldown progress (shared)" aria-live="polite" class="progress">
<div class="bar" id="searchProgressBar"></div>
</div>
</div>
<div class="row">
<div class="small muted">
      Chance of success: <strong><span id="searchChanceValue">35</span>%</strong>
<span class="small debug-inline">(<span id="searchChanceDetail"></span>)</span>
<span class="small red" id="searchLockedNote" style="margin-left:8px; display:none">Locked: Sleight of Hand L1</span>
</div>
<button class="btn" id="searchBtn">Search Bags</button>
</div>
</div>
<div class="catwrap hidden" id="cat-small">
<div class="grid">
<div class="card" data-category="petty">
<h3>Small Jobs (Placeholder)</h3>
<p class="small">General odd jobs and favors. This category will hold abstract, safe mini-tasks (no real-world methods).</p>
<div class="row">
<button class="btn" disabled="" id="smallJobBtn">Coming soon</button>
</div>
</div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-stats" role="tabpanel">
<div class="grid">
<div class="card">
<h3>Player Info</h3>
<div class="row" style="gap:12px;flex-wrap:wrap">
<div class="pill">Alias: <strong id="aliasText">(unset)</strong> <button class="btn sm secondary" id="aliasEditBtn" style="margin-left:8px">Edit</button></div>
<div class="pill">Reputation: <strong>Neutral</strong></div>
<div class="pill meter-inline">
<span class="icon">❤️</span><span class="small muted">Health</span>
<div class="progress tiny"><div class="bar" id="healthBar" style="width:100%"></div></div>
<span id="healthPct">100%</span>
<span class="small muted codepath debug-block">Source: <strong>state.vitals.health</strong> • updated by <strong>addHealth(pct)</strong></span>
</div>
<div class="pill meter-inline">
<span class="icon">🍞</span><span class="small muted">Hunger</span>
<div class="progress tiny"><div class="bar" id="hungerBar" style="width:100%"></div></div>
<span id="hungerPct">100%</span>
<span class="small muted codepath debug-block">Source: <strong>state.vitals.hunger</strong> • decays via <strong>decayHunger(dt)</strong> • restored by <strong>addHunger(pct)</strong> / <strong>useConsumable()</strong></span>
</div>
</div>
<div class="small codepath debug-block">Source: <strong>state.profile.alias</strong></div>
<div class="equip-wrap">
<div aria-label="Equipment silhouette" class="equip-figure">
<!-- Simple inline SVG silhouette -->
<svg aria-hidden="true" viewbox="0 0 180 300">
<defs>
<lineargradient id="sil_g" x1="0" x2="0" y1="0" y2="1">
<stop offset="0" stop-color="#0f172a"></stop>
<stop offset="1" stop-color="#0b1220"></stop>
</lineargradient>
</defs>
<!-- Head -->
<circle cx="90" cy="40" fill="url(#sil_g)" r="26" stroke="#1f2937"></circle>
<!-- Body -->
<rect fill="url(#sil_g)" height="80" rx="16" stroke="#1f2937" width="70" x="55" y="70"></rect>
<!-- Arms -->
<rect fill="url(#sil_g)" height="60" rx="10" stroke="#1f2937" width="25" x="30" y="78"></rect>
<rect fill="url(#sil_g)" height="60" rx="10" stroke="#1f2937" width="25" x="125" y="78"></rect>
<!-- Legs -->
<rect fill="url(#sil_g)" height="90" rx="10" stroke="#1f2937" width="24" x="58" y="152"></rect>
<rect fill="url(#sil_g)" height="90" rx="10" stroke="#1f2937" width="24" x="98" y="152"></rect>
<!-- Feet -->
<rect fill="url(#sil_g)" height="16" rx="6" stroke="#1f2937" width="32" x="50" y="244"></rect>
<rect fill="url(#sil_g)" height="16" rx="6" stroke="#1f2937" width="32" x="98" y="244"></rect>
</svg>
<style>
  /* Map sizing tweaks */
  #tbMap{ max-width:560px; }
  @media (max-width: 900px){
    #tbMap{ height:160px; } /* avoid crowding on smaller widths */
  }
</style>
<!-- Clickable slots -->
<button class="slot dotbtn" data-slot="head" style="left:50%;transform:translateX(-50%); top:8px" title="Head"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="chest" style="left:50%;transform:translateX(-50%); top:96px" title="Chest"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="hands" style="left:8px; top:104px" title="Hands"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="legs" style="left:50%;transform:translateX(-50%); top:190px" title="Legs"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="feet" style="left:50%;transform:translateX(-50%); top:254px" title="Feet"><span class="dot"></span></button>
<button class="slot dotbtn" data-slot="accessory" style="right:8px; top:104px" title="Accessory"><span class="dot"></span></button>
</div>
<div class="equip-panel">
<div class="slots-list">
<div class="slot badge" data-slot="head"><span class="dot"></span><strong>Head</strong> <span class="muted" id="slot-head-label">(Empty)</span></div>
<div class="slot badge" data-slot="chest"><span class="dot"></span><strong>Chest</strong> <span class="muted" id="slot-chest-label">(Empty)</span></div>
<div class="slot badge" data-slot="hands"><span class="dot"></span><strong>Hands</strong> <span class="muted" id="slot-hands-label">(Empty)</span></div>
<div class="slot badge" data-slot="legs"><span class="dot"></span><strong>Legs</strong> <span class="muted" id="slot-legs-label">(Empty)</span></div>
<div class="slot badge" data-slot="feet"><span class="dot"></span><strong>Feet</strong> <span class="muted" id="slot-feet-label">(Empty)</span></div>
<div class="slot badge" data-slot="accessory"><span class="dot"></span><strong>Accessory</strong> <span class="muted" id="slot-accessory-label">(Empty)</span></div>
</div>
<div class="equip-legend muted small debug-block">
                Source: <strong>state.equipment</strong> → head, chest, hands, legs, feet, accessory
              </div>
<div class="small muted">Click a slot or chip to open the equip panel. Loot is WIP.</div>
</div>
</div>
<div class="buffs" style="margin-top:12px">
<h4 style="margin:6px 0 8px 0">Equipment Buffs</h4>
<div class="row" id="buffPills" style="gap:8px;flex-wrap:wrap">
<span class="pill muted">No active buffs</span>
</div>
<div class="small codepath debug-block">Source: <strong>getEquippedBuffTotals(state)</strong> (derived)</div>
</div>
</div>
<div class="card">
<h3>Skills &amp; Progress</h3>
<div class="small muted" id="statsEmpty">No stats yet.</div>
<div aria-busy="false" aria-live="polite" class="stack" id="statsList">
<!-- Filled by updateUI() via renderStatRow(...) -->
</div>
</div></div>
</section>
<section aria-hidden="true" class="hidden" id="view-inventory" role="tabpanel">
<div class="grid">
<div class="card span-2">
<h3>Inventory</h3>
<p class="small" id="invSpaceText">Space: <span id="invUsed">0</span>/<span id="invCap">6</span></p>
<div class="small codepath debug-block">Source: <strong>state.inventory[]</strong> (id, name, slot, rarity, equipped)</div>
<p class="small muted" id="invEmpty">Your inventory is empty.</p>
<div class="inv-grid hidden" id="invGrid"></div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-shop" role="tabpanel">
<div class="grid">
<div class="card span-2">
<h3>Shop</h3>
<div class="row" style="gap:8px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Balance: <strong>£<span id="shopBalance">0</span></strong></div>
<span class="muted debug-inline">• Data: <strong>SHOP_ITEMS</strong></span>
</div>
<h4>Food &amp; Drink</h4>
<ul class="list" id="shopFood"></ul>
<h4>Medical</h4>
<ul class="list" id="shopMed"></ul>
<div class="small codepath debug-block">
        Source: <strong>SHOP_ITEMS</strong> • UI: <strong>renderShop()</strong> • Purchase: <strong>buyShop(id)</strong><br/>
        Inventory add: <strong>addConsumableToInventory(item)</strong> • Use: <strong>useConsumable(itemId)</strong><br/>
        Effect: <strong>target="hunger"</strong> • <strong>pct=40</strong> for Burger
      </div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-analytics" role="tabpanel">
<div class="grid analytics-grid">
<div class="card">
<h3>Economy Analytics</h3>
<div class="row" style="flex-wrap:wrap; gap:12px">
<div class="pill">Earned: <strong id="metricEarned">£0</strong></div>
<div class="pill">Outgoings: <strong id="metricSpent">£0</strong></div>
<div class="pill">Net: <strong id="metricNet">£0</strong></div>
</div>
<div class="small codepath debug-block">Source: <strong>state.metrics.money</strong> → earned=<span id="metricEarnedSrc">0</span>, spent=<span id="metricSpentSrc">0</span>, net=earned−spent</div>
</div>
<div class="card span-2">
<h3>Heat Analytics</h3>
<div class="row row-nowrap" style="gap:12px">
<div class="pill">Current: <strong><span id="metricHeatCurrent">0</span></strong></div>
<div class="pill">Peak: <strong><span id="metricHeatPeak">0</span></strong></div>
<div class="pill">Gained: <strong><span id="metricHeatGained">0</span></strong></div>
<div class="pill">Cooled: <strong><span id="metricHeatCooled">0</span></strong></div>
<div class="pill">Avg (session): <strong><span id="metricHeatAvg">0</span></strong></div>
</div>
<div aria-label="Current heat" class="progress">
<div class="bar" id="metricHeatBar" style="width:0%"></div>
</div>
<div class="small codepath debug-block">Source: <strong>state.metrics.heat</strong> → peak=<span id="metricHeatPeakSrc">0</span>, gained=<span id="metricHeatGainedSrc">0</span>, cooled=<span id="metricHeatCooledSrc">0</span>, avg=<span id="metricHeatAvgSrc">0</span></div>
</div>
<div class="card span-2">
<h3>Realtime Graph</h3>
<div class="rangebar" id="chartRanges">
<button aria-pressed="false" class="rangebtn" data-range="60000">1m</button>
<button aria-pressed="true" class="rangebtn" data-range="300000">5m</button>
<button aria-pressed="false" class="rangebtn" data-range="900000">15m</button>
<button aria-pressed="false" class="rangebtn" data-range="3600000">1h</button>
<button aria-pressed="false" class="rangebtn" data-range="session">Session</button>
<button aria-pressed="false" class="rangebtn" data-range="all">All-time</button>
</div>
<div class="chartWrap">
<canvas height="220" id="analyticsChart" width="1000"></canvas>
</div>
<div class="legend"><span class="dot money"></span> Balance • <span class="dot heat"></span> Heat • <span class="dot spent"></span> Outgoings</div>
<div class="small codepath debug-block">Source: <strong>history/session</strong> + <strong>history/lifetime</strong> • sample=<span id="dbgSampleCt">0</span> • range=<span id="dbgRangeLabel">5m</span> • y=[<span id="dbgYMin">0</span>, <span id="dbgYMax">0</span>] • last hist save=<span id="dbgHistSave">never</span></div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-upgrades" role="tabpanel">
<div class="grid">
<div class="card">
<h3>Upgrades (Placeholder)</h3>
<ul class="small">
<li>Skill tree (unlock faster cooldowns, better chances)</li>
<li>Locations (safer areas vs. risky areas)</li>
<li>Passive systems (purely fictional)</li>
<li>Heat/Attention meter (rises with failures)</li>
<li>Simple save/load via localStorage</li>
</ul>
</div>
</div>
</section>
<!-- Global Activity Log (always visible) -->
<section aria-hidden="true" class="hidden" id="view-mail" role="tabpanel">
<div class="card span-2">
<h3>Email <button class="mail-chip" id="mailThemeToggle" title="Toggle CRT theme">CRT: OFF</button></h3>
<div class="mail-grid">
<div class="mail-left">
<ul aria-busy="false" aria-live="polite" class="list mail-list" id="mailList"></ul>
</div>
<div class="mail-right">
<div class="small muted" id="mailEmpty">No messages yet.</div>
<div aria-hidden="true" class="hidden" id="mailRead">
<h4 id="mailSubj">—</h4>
<div class="small muted" style="margin:-6px 0 10px 0">
            From: <strong id="mailFrom">—</strong> • <span id="mailAgo">—</span>
</div>
<div class="mail-body" id="mailBody"></div>
</div>
</div>
</div>
<div class="small codepath debug-block">Source: <strong>state.mail.inbox[]</strong> • UI: <strong>renderMailView()</strong></div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-gambling" role="tabpanel">
<div class="grid">
<div class="card span-2">
<h3>Gambling</h3>
<!-- Tier toggles (similar placement to Property page buy/rent/holdings) -->
<div class="row" id="gamblingTiers" style="margin:6px 0 10px 0">
<button aria-pressed="true" class="btn toggle" id="btnTier1" title="Tier 1">Tier 1</button>
<button aria-pressed="false" class="btn toggle" id="btnTier2" title="Tier 2 (Placeholder)">Tier 2</button>
<button aria-pressed="false" class="btn toggle" id="btnTier3" title="Tier 3 (Placeholder)">Tier 3</button>
</div>
<!-- Tier 1: Fruit Machine -->
<div class="catwrap" id="tier-1">
<div class="row" style="gap:12px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Balance: <strong>£<span id="gambleBalance">0</span></strong></div>
<div class="pill">Bet per spin: <input id="betInput" min="1" step="1" style="width:80px;margin-left:6px" type="number" value="1"/></div>
</div>
<div class="grid">
<div class="card">
<h4>Fruit Machine</h4>
<div class="slotCanvas-wrap">
<div class="slotCanvas-box">
<div class="slotCanvas-frame" id="slotCanvasFrame">
<canvas aria-label="Slot reels" height="140" id="slotCanvas" width="360"></canvas><div class="fadeMaskTop"></div><div class="fadeMaskBot"></div><div class="bars"></div>
</div>
</div>
<div class="slotCanvas-divider"></div>
<div class="slotCanvas-controls">
<button class="btn" id="spinBtn">Spin (£<span id="spinCost">1</span>)</button>
<button class="btn secondary" id="spinAutoBtn" title="Auto spins 10x if funds allow">Auto x10</button>
<div class="small muted slotCanvas-hint" id="slotMsg">Match symbols to win. Three of a kind pays best; any two pays small; cherry in first reel refunds bet.</div>
</div>
</div>
</div>
<div class="card">
<h4>Payouts</h4>
<ul class="list small">
<li class="li">7️⃣7️⃣7️⃣ → <strong>20× bet</strong></li>
<li class="li">⭐⭐⭐ → <strong>10× bet</strong></li>
<li class="li">🔔🔔🔔 → <strong>6× bet</strong></li>
<li class="li">🍒🍒🍒 → <strong>4× bet</strong></li>
<li class="li">Two 7️⃣ → <strong>3× bet</strong></li>
<li class="li">Two ⭐ → <strong>2× bet</strong></li>
<li class="li">Two 🔔 → <strong>1× bet</strong></li>
<li class="li">Two 🍒 → <strong>1× bet</strong></li>
<li class="li">🍒 in the first reel → <strong>1× bet</strong> (refund)</li>
</ul>
<div class="small codepath debug-block">Module: slotCanvas → initSlotCanvas(), doCanvasSpin(), applyCanvasPayout()</div>
</div>
</div>
</div>
<!-- Placeholders for T2/T3 -->
<div class="catwrap hidden" id="tier-2">
<div class="row" style="gap:12px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Balance: <strong>£<span id="rouletteBalance">0</span></strong></div>
<div class="pill">Chip: £<input id="rouletteChip" min="1" step="1" style="width:80px;margin-left:6px" type="number" value="1"/></div>
<div class="pill">Total Bet: <strong>£<span id="rouletteTotal">0</span></strong></div>
</div>
<div class="grid">
<div class="card span-2">
<h4>Roulette (European)</h4>
<div class="row" style="gap:10px;align-items:center;flex-wrap:wrap">
<canvas height="340" id="rouletteCanvas" style="background:#0b0f14;border-radius:50%;box-shadow:0 0 0 1px #1f2937 inset" width="340"></canvas>
<div style="min-width:260px;max-width:420px">
<div class="small" id="rouletteExplainer">
                  Place chips on numbers or outside bets. European roulette uses a single 0 (house edge ≈ 2.70%). Payouts: straight 35:1, dozen/column 2:1, even-money (red/black, odd/even, low/high) 1:1. Choose a chip value, click bets to add them, then press <em>Spin</em>. The wheel spins every round; results and history appear below.
                </div>
<div class="row" style="gap:8px;margin-top:8px;flex-wrap:wrap">
<button class="btn" id="rouletteSpin">Spin</button>
<button class="btn secondary" id="rouletteClear">Clear Bets</button>
<button class="btn secondary" id="rouletteRebet">Rebet</button>
</div>
<div class="small muted" id="rouletteMsg" style="margin-top:8px"></div>
<div class="small" style="margin-top:8px">Last 10: <span id="rouletteHistory"></span></div>
</div>
</div>
</div>
<div class="card span-2">
<h4>Betting Table</h4>
<div class="roulette-table" id="rouletteTable"></div>
<div class="small muted" style="margin-top:8px">Tip: Click again on a placed bet in the list to remove it. You can place multiple bets before spinning.</div>
<h5 style="margin-top:10px">Placed Bets</h5>
<ul class="list" id="rouletteBets"></ul>
</div>
</div>
</div>
<div class="catwrap hidden" id="tier-3">
<div class="card"><h4>Tier 3</h4><p class="small">Placeholder — coming soon.</p></div>
</div>
</div>
</div>
</section>
<section aria-hidden="true" class="hidden" id="view-territory" role="tabpanel">
<div class="grid">
<div class="card span-2">
<h3>Territory Battle</h3>
<div class="card" style="margin-bottom:10px">
<h4>City Map</h4>
<div class="tbMapWrap" style="display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap;">
<div class="tbMapCol" style="flex:1 1 420px; min-width:320px;">
<svg aria-label="Territory Map (6 regions)" height="190" id="tbMap" role="img" viewbox="0 0 300 200" width="100%">
<style>
    #tbMap [data-r]{ stroke:#121821; stroke-width:2; stroke-linejoin:round; stroke-linecap:round; }
  </style>
<!-- 2 rows x 3 cols -->
<!-- Stylized city territories (irregular, but same 2x3 layout) -->
<path d="M0,0 L100,0 L94,40 L108,80 L98,100 L0,100 Z" data-r="0"></path>
<path d="M100,0 L200,0 L206,40 L192,70 L202,100 L140,106 L98,100 L108,80 L94,40 Z" data-r="1"></path>
<path d="M200,0 L300,0 L300,102 L260,102 L202,100 L192,70 L206,40 Z" data-r="2"></path>
<path d="M0,100 L98,100 L104,140 L96,180 L100,200 L0,200 Z" data-r="3"></path>
<path d="M98,100 L140,106 L202,100 L190,140 L210,172 L200,200 L100,200 L96,180 L104,140 Z" data-r="4"></path>
<path d="M202,100 L260,102 L300,102 L300,200 L200,200 L210,172 L190,140 Z" data-r="5"></path>
<!-- labels -->
<g dominant-baseline="middle" fill="#ddd" font-size="12" id="tbMapLabels" text-anchor="middle">
<text x="50" y="50"></text>
<text x="150" y="50"></text>
<text x="250" y="50"></text>
<text x="50" y="150"></text>
<text x="150" y="150"></text>
<text x="250" y="150"></text>
</g>
</svg>
<div class="small codepath debug-block" id="tbDebug"></div>
</div>
<div class="tbExplainCol" style="flex:1 1 360px; min-width:300px;">
<style>
    /* Scoped styles for the map help panel */
    .tbHelpPanel{background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.06);
      border-radius:12px;padding:12px 14px;}
    .tbHelpPanel h5{margin:4px 0 10px 0;}
    .tbHelpPanel .tbLegendTitle{font-size:12px;opacity:.8;letter-spacing:.04em;text-transform:uppercase;margin:2px 0 6px 0;}
    .tbHelpPanel .tbLegend{display:grid;grid-template-columns:auto 1fr;gap:8px 12px;margin:0 0 10px 0;align-items:center}
    .tbHelpPanel .badge{padding:6px 12px;border-radius:999px;font-weight:600;box-shadow:inset 0 0 0 1px rgba(0,0,0,.2)}
    .tbHelpPanel .badge.target{background:#f1c40f;color:#0e141b}
    .tbHelpPanel .badge.captured{background:#2ecc71;color:#0e141b}
    .tbHelpPanel .badge.locked{background:#2c3e50;color:#d6e1ea}
    .tbHelpPanel ul{margin:0;padding-left:18px}
    .tbHelpPanel li{margin:0 0 8px 0;line-height:1.5}
  </style>
<div class="tbHelpPanel">
<h5 class="muted">How Territory Works</h5>
<div class="tbLegendTitle">Legend</div>
<div class="tbLegend">
<div class="badge target">Target</div><div>Current objective</div>
<div class="badge captured">Captured</div><div>Under your control</div>
<div class="badge locked">Locked</div><div>Capture more to unlock</div>
</div>
<ul>
<li><strong>Goal:</strong> Capture all 6 regions.</li>
<li><strong>Runs &amp; Waves:</strong> Each run has 10 waves. Win waves to advance; a loss ends the run.</li>
<li><strong>Capture:</strong> Clearing wave 10 captures the current <em>Target</em> region and the next locked region becomes the new target.</li>
<li><strong>Tiers:</strong> Tier <em>N</em> unlocks after capturing <em>N−1</em> regions (Tier = captured + 1, max T6). Higher tiers spawn tougher enemies.</li>
<li><strong>Combat:</strong> <em>Strength</em> becomes your <em>Power</em> (damage &amp; max HP). <em>Toughness</em> reduces incoming damage and boosts regen. The message shows estimated TTK and expected damage if you win.</li>
<li><strong>Loot:</strong> Wins can drop gear. Use <em>Transfer</em> to move items to your inventory; <em>Discard</em> to skip.</li>
<li><strong>Tip:</strong> Use <em>Quick Sim (10 waves)</em> to speed through a run once you’re healthy enough.</li>
</ul>
</div>
</div>
</div>
<div class="row" style="gap:8px;flex-wrap:wrap;margin:6px 0 10px 0">
<div class="pill">Tier: 
          <button aria-pressed="true" class="btn toggle" id="tbTier1">T1</button>
<button aria-pressed="false" class="btn toggle" id="tbTier2">T2</button>
<button aria-pressed="false" class="btn toggle" id="tbTier3">T3</button>
<button aria-pressed="false" class="btn toggle" id="tbTier4">T4</button>
<button aria-pressed="false" class="btn toggle" id="tbTier5">T5</button>
<button aria-pressed="false" class="btn toggle" id="tbTier6">T6</button>
</div>
<div class="small muted" id="tbTierHint" style="margin-left:8px"></div>
<div class="pill">Wave: <strong id="tbWave">1</strong>/10</div>
</div>
<div class="grid">
<div class="card">
<h4>You</h4>
<div class="row" style="gap:12px;flex-wrap:wrap">
<div class="pill">Strength: <strong id="tbYouStr">0</strong></div>
<div class="pill">Toughness: <strong id="tbYouTgh">0</strong></div>
<div class="pill">Power: <strong id="tbYouPow">0</strong></div>
<div class="pill meter-inline">
<span class="icon">❤️</span><span class="small muted">Your Health</span>
<div class="progress tiny"><div class="bar" id="tbHealthBar" style="width:100%"></div></div>
<span id="tbHealthPct">100%</span>
</div>
</div>
</div>
<div class="card">
<h4>Enemy</h4>
<div class="row" style="gap:12px;flex-wrap:wrap">
<div class="pill">Name: <strong id="tbEnemyName">—</strong></div>
<div class="pill">Strength: <strong id="tbEnemyStr">0</strong></div>
<div class="pill">Toughness: <strong id="tbEnemyTgh">0</strong></div>
<div class="pill">Power: <strong id="tbEnemyPow">0</strong></div>
<div class="pill meter-inline">
<span class="icon">💀</span><span class="small muted">Enemy Health</span>
<div class="progress tiny"><div class="bar" id="tbEnemyHealthBar" style="width:100%"></div></div>
<span id="tbEnemyHealthPct">100%</span>
</div></div>
</div>
</div>
<div class="row" style="gap:10px;margin-top:10px;flex-wrap:wrap">
<button class="btn" id="tbStartBtn">Start / Next Wave</button>
<button class="btn secondary" id="tbSimBtn">Quick Sim (10 waves)</button>
<span class="small muted">Win waves to advance. Loss ends the run.</span>
</div>
<div class="pill meter-inline" id="tbBattleProgWrap" style="margin-top:6px">
<span class="icon">⏳</span><span class="small muted">Battle</span>
<div class="progress tiny"><div class="bar" id="tbBattleProgBar" style="width:0%"></div></div> <span id="tbBattleProgText">Ready</span>
</div>
<div class="small muted" id="tbMsg" style="margin-top:8px"></div>
<h4 style="margin-top:10px">Battle Log</h4>
<ul class="list" id="tbLog"></ul>
<div class="card" id="tbLootArea" style="margin-top:12px;">
<h4>Dropped Loot (Unclaimed)</h4>
<p class="small muted" id="tbLootEmpty">No unclaimed drops yet.</p>
<ul class="list" id="tbLootList"></ul>
</div>
</div>
</div>
</div></section>
<section aria-labelledby="activity-log-title" id="activity-log-global" role="region">
<div class="grid" style="margin-top:14px">
<div class="card">
<h3 id="activity-log-title">Activity Log</h3>
<p class="small muted" id="logEmpty">No activity yet. Try an action to begin.</p>
<ul aria-live="polite" class="list hidden" id="logList"></ul>
</div>
</div>
</section>
<footer>Fictional game prototype. Do not use as real-life guidance.</footer>
</div>
</main>
</div>
<script>
    // === PUBLIC API (stats) ===================================================
    window.getAllStats = function(){ return JSON.parse(JSON.stringify(state.stats)); };
    window.getStat = function(name){ return state.stats[name] ? { level: state.stats[name].level, xp: state.stats[name].xp } : null; };
    window.getStatLevel = function(name){ return state.stats[name]?.level ?? null; };
    window.getStatXP = function(name){ return state.stats[name]?.xp ?? null; };
    // ==========================================================================

    // === AUTOSAVE =============================================================
    const SAVE_KEY = 'idle-underworld-save-v1'; // shown in Debug
    const DEBUG_KEY = 'idle-underworld-debug';  // persists debug on/off
    window.getSaveKey = () => SAVE_KEY;
    window.forceSave = () => saveGame({ silent: false });
    window.clearSave = () => { localStorage.removeItem(SAVE_KEY); try{ if(state && state.territory){ delete state.territory; } }catch(e){} lastSavedAt = null; updateAutoSaveUI(); };

    let lastSavedAt = null;
    let saveTimer = null;
    function scheduleSave(){
      if(saveTimer) return;
      saveTimer = setTimeout(() => { saveTimer = null; saveGame({ silent: true }); }, 250);
    }
    function saveGame({ silent } = { silent: true }){
      try{
        const payload = {
version: 2,
          money: state.money,
          heat: state.heat,
          stats: state.stats,
          inventory: state.inventory,
          log: state.log.slice(0, MAX_LOG),
          equipment: state.equipment,
          profile: state.profile,
          vitals: state.vitals,
          metrics: state.metrics,
          history: { session: state.history.session.slice(-MAX_SESSION_SAMPLES) },
          time: state.time,
          properties: state.properties,
          recruitment: state.recruitment,
          storage: state.storage,
          hq: state.hq,
          territory: state.territory,
          lifetime: { all: state.lifetime.all.slice(-MAX_ALL_SAMPLES) },
          pickEndsAt,
          ts: Date.now(),
  mail: state.mail
};
        localStorage.setItem(SAVE_KEY, JSON.stringify(payload));
        lastSavedAt = Date.now();
        if(!silent) addLog('Game saved.');
        updateAutoSaveUI();
      }catch(e){
        console.error('Save failed', e);
      }
    }
    function sanitizeNumber(n, d=0){ return (Number.isFinite(n) ? n : d); }
    function sanitizeStats(obj){
      const out = {};
      for(const [name, val] of Object.entries(obj || {})){
        if(!val || typeof val !== 'object') continue;
        let level = Number.isFinite(val.level) ? Math.max(0, Math.floor(val.level)) : 0;
        let xp = Number.isFinite(val.xp) ? Math.max(0, Math.floor(val.xp)) : 0;
        out[name] = { level, xp };
      }
      return out;
    }
    function sanitizeLogEntries(arr){
      const out = [];
      if(!Array.isArray(arr)) return out;
      for(const entry of arr.slice(0, MAX_LOG)){
        if(typeof entry === 'string'){
          out.push(String(entry).slice(0, 300));
        }else if(entry && typeof entry === 'object' && typeof entry.html === 'string'){
          let s = String(entry.html);
          if(s.length > 500) s = s.slice(0, 500);
          // strip any script tags if tampered
          s = s.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
          out.push({ html: s });
        }
      }
      return out;
    }

    function sanitizeMetrics(m){
      const mm = m && typeof m === 'object' ? m : {};
      const money = mm.money && typeof mm.money === 'object' ? mm.money : {};
      const heat = mm.heat && typeof mm.heat === 'object' ? mm.heat : {};
      return {
        money: {
          earned: sanitizeNumber(money.earned, 0),
          spent: sanitizeNumber(money.spent, 0)
        },
        heat: {
          peak: sanitizeNumber(heat.peak, 0),
          gained: sanitizeNumber(heat.gained, 0),
          cooled: sanitizeNumber(heat.cooled, 0),
          avg: sanitizeNumber(heat.avg, 0),
          _samples: sanitizeNumber(heat._samples, 0),
          _sum: sanitizeNumber(heat._sum, 0)
        }
      };
    }

    function sanitizeHistory(h){
      const obj = h && typeof h === 'object' ? h : {};
      return {
        session: sanitizeSamples(obj.session),
      };
    }
    function sanitizeLifetime(h){
      const obj = h && typeof h === 'object' ? h : {};
      return {
        all: sanitizeSamples(obj.all),
        seededOnce: !!obj.seededOnce
      };
    }

    function sanitizeEquipment(eq){
      const def = { head:null, chest:null, hands:null, legs:null, feet:null, accessory:null };
      const out = { ...def };
      if(eq && typeof eq === 'object'){
        for(const k of Object.keys(def)){
          const v = eq[k];
          out[k] = (typeof v === 'string' && v.length <= 60) ? v : null;
        }
      }
      return out;
    }
    function sanitizeProfile(p){
      const out = { alias: "" };
      if(p && typeof p === 'object'){
        let a = String(p.alias || "").trim();
        // allow letters, numbers, spaces, hyphen and underscore
        a = a.replace(/[^a-zA-Z0-9 _-]/g, "").slice(0,24);
        out.alias = a;
      }
      return out;
    }

    function sanitizeVitals(v){
      const out = { health: 100, hunger: 100 };
      if(v && typeof v === 'object'){
        let h = Number(v.health); if(!Number.isFinite(h)) h = 100; out.health = Math.max(0, Math.min(100, h));
        let g = Number(v.hunger); if(!Number.isFinite(g)) g = 100; out.hunger = Math.max(0, Math.min(100, g));
      }
      return out;
    }
    
    

function sanitizeTerritory(obj){
  const def = { tier:1, wave:1, active:false, enemy:null, lootQueue: [], regions: null, currentTarget: 0 };
  try{
    const o = obj || {};
    const out = {};
    // Core fields
    out.tier = Number.isFinite(o.tier) ? Math.max(1, Math.min(6, Math.floor(o.tier))) : 1;
    out.wave = Number.isFinite(o.wave) ? Math.max(1, Math.min(10, Math.floor(o.wave))) : 1;
    out.active = !!o.active;
    out.enemy = null;
    // Loot queue (safe)
    const q = Array.isArray(o.lootQueue) ? o.lootQueue : [];
    out.lootQueue = q.filter(it => it && typeof it==='object' && typeof it.id!=='undefined' && Array.isArray(it.mods)).slice(0, 50);
    // Regions (6 fixed)
    const names = ['Downtown','Harbor','Old Town','Heights','Industrial','Suburbs'];
    let regs = Array.isArray(o.regions) ? o.regions : [];
    if(regs.length !== 6){
      regs = names.map((name,i)=>({ id:i, name, status: i===0?'target':'locked' }));
    }else{
      regs = regs.map((r,i)=>({ id:i, name: String((r && r.name) || names[i]), status: (r && r.status)==='captured' ? 'captured' : ((r && r.status)==='target' ? 'target' : 'locked') }));
    }
    out.regions = regs;
    // Current target
    if(Number.isFinite(o.currentTarget)){
      out.currentTarget = Math.max(0, Math.min(5, Math.floor(o.currentTarget)));
    }else{
      const idx = regs.findIndex(r=>r.status==='target');
      out.currentTarget = idx>=0 ? idx : Math.min(5, regs.findIndex(r=>r.status!=='captured'));
    }
    // Preserve persisted battle log history (sanitized)
    try{
      const lh = Array.isArray(o.logHistory) ? o.logHistory.slice(0,200) : [];
      out.logHistory = lh.map(it => ({
        ts: (it && typeof it.ts!=='undefined') ? String(it.ts) : '',
        html: (it && typeof it.html!=='undefined') ? String(it.html) : ''
      }));
    }catch(e){ out.logHistory = []; }
    return Object.assign({}, def, out);
    }catch(e){
    return def;
  }
}


    function sanitizeTime(t){
      const now = Date.now();
      const out = { gameMs: 0, startedAt: now, epochMs: now - (now % (24*60*60*1000)) };
      if(t && typeof t === 'object'){
        const gm = Number(t.gameMs);
        out.gameMs = Number.isFinite(gm) && gm >= 0 ? Math.floor(gm) : 0;
        const sa = Number(t.startedAt);
        out.startedAt = Number.isFinite(sa) ? sa : now;
        const em = Number(t.epochMs);
        if(Number.isFinite(em) && em > 0) out.epochMs = em;
      }
      return out;
    }
    
    function sanitizeProperties(p){
      const out = { holdings: [], daily:{ dayKey:'', offers: [] } };
      if(!p || typeof p !== 'object') return out;
      // holdings
      if(Array.isArray(p.holdings)){
        for(const h of p.holdings.slice(0,50)){
          if(!h || typeof h!=='object') continue;
          const id = String(h.id||'').slice(0,60);
          const name = String(h.name||'').slice(0,80);
          const loc = String(h.loc||'').slice(0,80);
          const storage = Math.max(0, Math.min(9999, Number(h.storage)||0));
          const garage = Math.max(0, Math.min(9, Number(h.garage)||0));
          const monthly = Math.max(0, Math.min(1e7, Number(h.monthly)||0));
          const deposit = Math.max(0, Math.min(1e7, Number(h.deposit)||0));
          const nextRentDue = Math.max(0, Number(h.nextRentDue)||0);
          const overdue = !!h.overdue;
          const paid = Math.max(0, Number(h.paid)||0);
          const isHQ = !!h.isHQ;
          if(id && name){
            const storeItems = Array.isArray(h.storeItems) ? h.storeItems.slice(0,200).map(it=>({ id:String(it.id||'').slice(0,80), name:String(it.name||'').slice(0,80), slot: it.slot?String(it.slot):undefined, rarity: it.rarity?String(it.rarity):'common', type: it.type?String(it.type):undefined })) : [];
            out.holdings.push({ id, name, loc, storage, garage, monthly, deposit, nextRentDue, overdue, paid, isHQ, storeItems });
          }
        }

    function sanitizeRecruitment(r){
try{ window.sanitizeRecruitment = sanitizeRecruitment; }catch(e){}

      const out = { daily: { dayKey:'', candidates: [] }, crew: [] };
      if(!r || typeof r!=='object') return out;
      // daily
      const d = r.daily && typeof r.daily==='object' ? r.daily : {};
      out.daily.dayKey = String(d.dayKey||'');
      out.daily.candidates = Array.isArray(d.candidates) ? d.candidates.slice(0,12).map(c=>{
        if(!c || typeof c!=='object') return null;
        const id = String(c.id||'').slice(0,80);
        const name = String(c.name||'').slice(0,60);
        const alias = String(c.alias||'').slice(0,60);
        const bio = String(c.bio||'').slice(0,180);
        const cut = 0.5; // clamp to 50%
        const hireCost = 500;
        return { id, name, alias, bio, cut, hireCost };
      }).filter(Boolean) : [];
      // crew
      if(Array.isArray(r.crew)){
        for(const m of r.crew.slice(0,10)){
          if(!m || typeof m!=='object') continue;
          const id = String(m.id||'').slice(0,80);
          const name = String(m.name||'').slice(0,60);
          const alias = String(m.alias||'').slice(0,60);
          const bio = String(m.bio||'').slice(0,180);
          const cut = 0.5;
          const role = (typeof m.role==='string' && (m.role==='pick' || m.role==='pickpocket')) ? (m.role==='pick'?'pick':'pickpocket') : 'pickpocket';
          const auto = !!m.auto;

          const hiredAt = Math.max(0, Math.floor(Number(m.hiredAt)||0));
          const nextReadyAt = Math.max(0, Math.floor(Number(m.nextReadyAt)||0));
          out.crew.push({ id, name, alias, bio, cut, hiredAt, nextReadyAt, role, auto });
        }
      }
      return out;
    }

      }
      // daily offers
      if(p.daily && typeof p.daily==='object'){
        out.daily.dayKey = String(p.daily.dayKey||'');
        out.daily.offers = Array.isArray(p.daily.offers) ? p.daily.offers.filter(Boolean).slice(0,20) : [];
      }
      return out;
    }
    function sanitizeHQ(h){
      const out = { propertyId: null };
      if(h && typeof h === 'object'){
        const id = h.propertyId;
        if(typeof id === 'string' && id.length <= 60){ out.propertyId = id; }
      }
      return out;
    }
    function sanitizeStorage(s){
      const out = { items: [] };
      if(!s || typeof s!=='object') return out;
      if(Array.isArray(s.items)){
        for(const it of s.items.slice(0,200)){
          if(!it || typeof it!=='object') continue;
          const id = String(it.id||'').slice(0,80);
          const name = String(it.name||'').slice(0,80);
          const slot = it.slot ? String(it.slot) : undefined;
          const rarity = it.rarity ? String(it.rarity) : 'common';
          const type = it.type ? String(it.type) : undefined;
          out.items.push({ id, name, slot, rarity, type });
        }
      }
      return out;
    }
    
// --- Fallback to ensure sanitizeRecruitment exists before loadGame ---
if (typeof sanitizeRecruitment !== 'function') {
  function sanitizeRecruitment(r){
    const out = { daily: { dayKey:'', candidates: [] }, crew: [] };
    if(!r || typeof r!=='object') return out;
    const d = r.daily && typeof r.daily==='object' ? r.daily : {};
    out.daily.dayKey = String(d.dayKey||'');
    out.daily.candidates = Array.isArray(d.candidates) ? d.candidates.slice(0,12).map(c=>{
      if(!c || typeof c!=='object') return null;
      const id = String(c.id||'').slice(0,80);
      const name = String(c.name||'').slice(0,60);
      const alias = String(c.alias||'').slice(0,60);
      const bio = String(c.bio||'').slice(0,180);
      const cut = 0.5;
const hireCost = 500;
      return { id, name, alias, bio, cut, hireCost };
    }).filter(Boolean) : [];
    if(Array.isArray(r.crew)){
      for(const m of r.crew.slice(0,10)){
        if(!m || typeof m!=='object') continue;
        const id = String(m.id||'').slice(0,80);
        const name = String(m.name||'').slice(0,60);
        const alias = String(m.alias||'').slice(0,60);
        const bio = String(m.bio||'').slice(0,180);
        const cut = 0.5;
        const hiredAt = Math.max(0, Math.floor(Number(m.hiredAt)||0));
        const nextReadyAt = Math.max(0, Math.floor(Number(m.nextReadyAt)||0));
                  const role = (typeof m.role==='string' && (m.role==='pick' || m.role==='pickpocket')) ? (m.role==='pick'?'pick':'pickpocket') : 'pickpocket';
          const auto = !!m.auto;
out.crew.push({ id, name, alias, bio, cut, hiredAt, nextReadyAt, role, auto });
      }
    }
    return out;
  }
}

function loadGame(){
      try{
        const raw = localStorage.getItem(SAVE_KEY);
        if(!raw) return false;
        const data = JSON.parse(raw);
        if(!data || typeof data !== 'object') return false;
        state.money = Number.isFinite(data.money) && data.money >= 0 ? Math.floor(data.money) : 0;
        state.heat = Number.isFinite(data.heat) ? clamp(data.heat, HEAT_MIN, HEAT_MAX) : 0;
        state.stats = sanitizeStats(data.stats);
        ensureDefaultStats();
        state.inventory = sanitizeInventory(data.inventory);
        try{ const _hood=(state.inventory||[]).find(x=>x.id==='itm-hoodie'); if(_hood && typeof _hood.invCapAdd!=='number'){ _hood.invCapAdd=2; } }catch(e){}; state.log = sanitizeLogEntries(data.log);
        state.equipment = sanitizeEquipment(data.equipment);
        state.profile = sanitizeProfile(data.profile);
        state.vitals = sanitizeVitals(data.vitals);
        state.metrics = sanitizeMetrics(data.metrics);
        state.history = sanitizeHistory(data.history);
        state.lifetime = sanitizeLifetime(data.lifetime);
        state.recruitment = sanitizeRecruitment(data.recruitment);
        
        // Migration: mark seededOnce for existing saves so we don't re-seed on HQ-less refresh
        try{ if(!state.lifetime.seededOnce){ state.lifetime.seededOnce = true; scheduleSave(); } }catch(e){}        
state.time = sanitizeTime(data.time);
        state.properties = sanitizeProperties(data.properties);
        state.storage = sanitizeStorage(data.storage);
        state.hq = sanitizeHQ(data.hq);
        // Territory (persisted)
        try{
          state.territory = sanitizeTerritory(data.territory);
        }catch(e){
          if(!state.territory){
            state.territory = { tier:1, wave:1, active:false, enemy:null, lootQueue: [] };
          }
        }

        
        // Load persisted mail (read status, selection, CRT)
        state.mail = (typeof window.sanitizeMail === 'function'
  ? window.sanitizeMail(data.mail)
  : (data.mail && typeof data.mail==='object' ? data.mail : { inbox: [], unread: 0, nextId: 1, seededWelcome: false, crt: false }));
try{ if(typeof window.ensureMailState==='function') window.ensureMailState(); }catch(e){}
if(!hasSeededOnce() && !state.inventory.length && getHQStore().length===0){ seedFakeItems(); }
        reconcileEquipment();
        // Reconcile HQ from holdings if missing
        try{
          if(!state.hq || !state.hq.propertyId){
            const mark = (state.properties?.holdings||[]).find(x=>x.isHQ);
            if(mark){ state.hq = { propertyId: mark.id }; }
          }
        }catch(e){
        // Migrate legacy global storage (state.storage.items) into current HQ property's storeItems
        try{
          const legacy = (state.storage?.items)||[];
          if(legacy.length){
            const h = getHQRecord();
            if(h){
              if(!Array.isArray(h.storeItems)) h.storeItems = [];
              for(const it of legacy.slice(0,200)){
                if(it && typeof it==='object'){
                  h.storeItems.push({ id: String(it.id||'').slice(0,80), name: String(it.name||'').slice(0,80), slot: it.slot?String(it.slot):undefined, rarity: it.rarity?String(it.rarity):'common', type: it.type?String(it.type):undefined });
                }
              }
              state.storage = { items: [] };
              try{ addLog('Migrated legacy storage into HQ property.'); }catch(e){}
              try{ scheduleSave(); }catch(e){}
            }
          }
        }catch(e){}}

        try{ renderHeadquarters(); 
      // Recruitment view
      renderRecruitmentView();
      const btnCrew = document.getElementById('btnCrewJobs');
      if(btnCrew && !btnCrew.dataset.bound){
        btnCrew.addEventListener('click', ()=> {
          const p = document.getElementById('hqCrewPanel'); if(p){ p.classList.toggle('hidden'); p.setAttribute('aria-hidden', String(p.classList.contains('hidden'))); }
          renderCrewActionsPanel();
        });
        btnCrew.dataset.bound='1';
      }
}catch(e){}
        pickEndsAt = (typeof data.pickEndsAt === 'number' && data.pickEndsAt > Date.now()) ? data.pickEndsAt : null;
        lastSavedAt = Number.isFinite(data.ts) ? data.ts : null;
        if(lastSavedAt){ try{ applyOfflineCatchup(Date.now() - lastSavedAt); }catch(e){} }
        ensureDailyOffers();
        
  ensureRecruitmentDaily(); // recruitment
processRentDue();
        lastSampleAt = Date.now();
        return true;
      }catch(e){
        console.warn('Load failed', e);
        return false;
      }
    }
    function formatTimeAgo(ts){
      if(!ts) return 'never';
      const s = Math.max(0, Math.floor((Date.now() - ts) / 1000));
      if(s < 60) return s + 's ago';
      const m = Math.floor(s / 60);
      if(m < 60) return m + 'm ago';
      const h = Math.floor(m / 60);
      return h + 'h ago';
    }
    function updateAutoSaveUI(){
      const keyEl = document.getElementById('saveKeyText');
      const lastEl = document.getElementById('lastSaveText');
      if(keyEl) keyEl.textContent = "localStorage['" + SAVE_KEY + "']";
      if(lastEl) lastEl.textContent = formatTimeAgo(lastSavedAt);
    }
    // ==========================================================================

    // --- Config (tweak here) ---
    const COOLDOWN_MS = 5000;           
// Track active petty job
let currentJob = null;
// 5 seconds
    const TICK_MS = 1000;              // game loop tick (ms)
    const GAME_TIME_SCALE = 60;        // 1 real sec = 60 in-game seconds
    const BASE_SUCCESS = 0.50;          // 50%
    const PICK_MIN_CASH = 5;            // £5
    const PICK_MAX_CASH = 20;           
// --- Search Bags (unlocks at Sleight of Hand L1) ---
const SEARCH_BASE_SUCCESS = 0.35;   // Lower base chance than pickpocket
const SEARCH_MIN_CASH = 10;         // £10
const SEARCH_MAX_CASH = 60;         // £60
const SEARCH_UNLOCK_LEVEL = 1;      // Requires Sleight of Hand level 1
// £20
    const MAX_LOG = 8;                  // keep last 8 entries

    // XP & Leveling
    const XP_BASE = 100;                   // XP needed for level 0 -> 1
    const XP_GROWTH = 1.25;                // exponential growth per level
    const SLEIGHT_BONUS_PER_LEVEL = 0.02;  // +2% success per Sleight of Hand level
    const XP_AWARD_SUCCESS = { "Sleight of Hand": 15, "Street Smarts": 8 };
    const XP_AWARD_FAIL    = { "Sleight of Hand": 3 }; // consolation XP for trying

    // HEAT system
    const HEAT_MIN = 0;
    const HEAT_MAX = 100;
    const HEAT_GAIN_SUCCESS = 4;
    const HEAT_GAIN_FAIL = 7;
    const HEAT_PENALTY_PER_HEAT = 0.002;     // -0.2 at 100 heat
    const HEAT_DECAY_INTERVAL_MS = 5000;     // -1 heat every 5s
    let lastHeatDecayAt = Date.now();

    // --- State ---
    const state = {
      money: 0,
      heat: 0,
      stats: {},       // { [name]: { level, xp } }
      inventory: [],
      log: [],
      equipment: { head:null, chest:null, hands:null, legs:null, feet:null, accessory:null },
      profile: { alias: "" },
      vitals: { health: 100, hunger: 100 },
      metrics: {
        money: { earned: 0, spent: 0 },
        heat: { peak: 0, gained: 0, cooled: 0, avg: 0, _samples: 0, _sum: 0 }
      },
      history: { session: [] },
      lifetime: { all: [] },
      recruitment: { daily: { dayKey: '', candidates: [] }, crew: [] },

      time: { gameMs: 0, startedAt: Date.now(), epochMs: (function(){ const n=Date.now(); const DAY=24*60*60*1000; return n - (n % DAY); })() },
      properties: { holdings: [], daily:{ dayKey:'', offers: [] } },
      hq: { propertyId: null },
      storage: { items: [] }
    };
    let pickEndsAt = null; // timestamp or null

    // --- Utilities ---
    const qs = (sel, root=document) => root.querySelector(sel);
    const qsa = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));

    function changeMoney(delta, reason='misc'){
      const before = state.money;
      const next = Math.max(0, Math.floor(before + delta));
      const applied = next - before; // in case floor clamps
      state.money = next;
      if(applied >= 0){ state.metrics.money.earned += applied; }
      else{ state.metrics.money.spent += -applied; }
      scheduleSave(); try{ saveGame({silent:true}); }catch(e){}
    }
    function randInt(min, max){
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }
    function addLog(message){
      // Delegate to pushLog so we always get consistent objects ({html}|{text})
      pushLog(message);
    }

    // Rich log helper: store safe HTML fragments we generate (not user input)
    
    // Format ISO timestamp as local HH:MM
    function fmtTime(ts){
      try{ return new Date(ts).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); }
      catch(e){ return '--:--'; }
    }
function pushLog(entry){
      const ts = new Date().toISOString();
      let item;
      if (entry && typeof entry === 'object' && (('html' in entry) || ('text' in entry))) {
        item = Object.assign({ ts }, entry);
      } else if (typeof entry === 'string') {
        if (/<\/?[a-z][\s\S]*>/i.test(entry)) {
          const safe = entry.replace(/<script[\s\S]*?>[\s\S]*?<\/script>/gi, '');
          item = { ts, html: safe };
        } else {
          item = { ts, text: entry };
        }
      } else {
        item = { ts, text: String(entry ?? '') };
      }
      state.log.unshift(item);
      if (state.log.length > MAX_LOG) state.log.pop();
      scheduleSave();
    }

// Hook: drive the canvas from Activity Log entries (fallback)
if(!window.__slotLogHooked){
  window.__slotLogHooked = true;
  (function(){
    const _origPushLog = pushLog;
    window.pushLog = function(entry){
      const ret = _origPushLog(entry);
      try{
        let raw = (typeof entry==='string') ? entry : (entry && (entry.html||entry.text) || '');
        // Strip tags to handle HTML log variants
        raw = String(raw).replace(/<[^>]+>/g,'');
        const m = raw.match(/Fruit machine\s+([🍒🍋🔔⭐7️⃣🍇🍉🍀7])\s+([🍒🍋🔔⭐7️⃣🍇🍉🍀7])\s+([🍒🍋🔔⭐7️⃣🍇🍉🍀7])/i);
        if(m && window.slot && typeof window.slot.visualSpin === 'function'){
          const toSeven = {'7':'7️⃣'};
          const trip = [m[1],m[2],m[3]].map(ch=> toSeven[ch] || ch);
          window.slot.visualSpin(trip);
        }
      }catch(e){}
      return ret;
    };
  })();
}


    function spanXP(amount, stat){
      const s = escapeHtml(stat);
      return `<span class="logpiece txp">+${amount} XP ${s}</span>`;
    }
    function spanMoney(amount){
      return `<span class="logpiece tmoney">+£${amount}</span>`;
    }
    function spanBad(text){
      return `<span class="logpiece tbad">${escapeHtml(text)}</span>`;
    }
    function escapeHtml(str){
      return String(str).replace(/[&<>'"]/g, (c)=>({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        "'": '&#39;',
        '"': '&quot;'
      }[c]));
    }
    function slug(name){
      return String(name).toLowerCase().replace(/[^a-z0-9\s-]/g,"").trim().replace(/\s+/g,"-").replace(/-+/g,"-");
    }

    
    // === Rarity helpers for Activity Log ===
    function rarityFrom(it){
      if(!it) return 'common';
      if (it.rarity) return String(it.rarity).toLowerCase();
      const tier = typeof it.tier === 'number' ? it.tier : 0;
      if (tier >= 2) return 'rare';
      if (tier >= 1) return 'uncommon';
      return 'common';
    }
    function rarityColor(r){
      const key = String(r||'common').toLowerCase();
      if(key === 'uncommon') return '#34d399'; // green
      if(key === 'rare') return '#60a5fa'; // blue
      return '#9ca3af'; // grey
    }
    function spanItemName(name, rarity){
      const color = rarityColor(rarity);
      return `<span class="logpiece" style="color:${color}">${escapeHtml(name)}</span>`;
    }
    function spanItem(it){
      if(!it) return `<span class="logpiece">${escapeHtml('item')}</span>`;
      const rar = rarityFrom(it);
      return spanItemName(it.name || 'item', rar);
    }

    // === History / Chart =====================================================
    const SAMPLE_EVERY_MS = 1000;      // 1s
    const MAX_SESSION_SAMPLES = 7200;  // last 2 hours at 1s
    const MAX_ALL_SAMPLES = 28800;     // ~8 hours total cap

    let lastSampleAt = 0;
    let chartRange = 300000; // default 5m in ms; can be "session" or "all"
    let chartNeedsDraw = true;

    function pushSample(){
      const now = Date.now();
            if(typeof window.__prevSpentTotal !== "number"){ window.__prevSpentTotal = (state.metrics?.money?.spent|0) || 0; }
      const totalSpent = (state.metrics?.money?.spent|0) || 0;
      const sampleSpent = Math.max(0, totalSpent - window.__prevSpentTotal)|0;
      window.__prevSpentTotal = totalSpent;
state.history.session.push({ t: now, heat: state.heat|0, money: state.money|0, spent: sampleSpent });
      if(state.history.session.length > MAX_SESSION_SAMPLES) state.history.session.shift();

      state.lifetime.all.push({ t: now, heat: state.heat|0, money: state.money|0, spent: sampleSpent });
      if(state.lifetime.all.length > MAX_ALL_SAMPLES) state.lifetime.all.shift();

      // Throttled autosave so history survives refresh even without actions
      if(!window.__lastHistorySaveAt || (now - window.__lastHistorySaveAt) >= 15000){
        window.__lastHistorySaveAt = now;
        scheduleSave();
      }
    }

    function sanitizeSamples(list){
      const out = [];
      if(!Array.isArray(list)) return out;
      for(const s of list){
        if(s && typeof s === 'object' && Number.isFinite(s.t) && Number.isFinite(s.heat) && Number.isFinite(s.money)){
          out.push({ t: s.t|0, heat: s.heat|0, money: s.money|0, spent: (Number(s.spent)||0)|0 });
        }
        if(out.length >= MAX_ALL_SAMPLES) break;
      }
      return out;
    }

    function getSamplesForRange(){
      const now = Date.now();
      if(chartRange === 'all') return state.lifetime.all.slice();
      if(chartRange === 'session') return state.history.session.slice();
      const ms = Number(chartRange) || 300000;
      const start = now - ms;
      // Prefer lifetime for coverage; fallback to session
      const base = state.lifetime.all.length ? state.lifetime.all : state.history.session;
      const sliced = base.filter(s => s.t >= start);
      if(sliced.length > 1) return sliced;
      // If empty due to time gaps, show last N points
      const N = Math.min(120, base.length);
      return base.slice(Math.max(0, base.length - N));
    }

    function mapY(value, minY, maxY, h, pad=8){
      if(maxY === minY) return h/2;
      const pct = (value - minY) / (maxY - minY);
      return Math.round((1 - pct) * (h - pad*2) + pad);
    }

    // Back-compat wrapper called from tick(); simply renders the analytics chart
    function drawLiveChart(){ try{ drawChart(); }catch(e){} }

    function drawChart(){
      const c = document.getElementById('analyticsChart');
      if(!c) return;
      const ctx = c.getContext('2d');
      const w = c.width = c.clientWidth || c.width;
      const h = c.height = 220;

      const series = getSamplesForRange();
      const count = series.length;
      // gather Y bounds from both lines, with padding
      let minY = Infinity, maxY = -Infinity;
      for(const s of series){
        if(s.money < minY) minY = s.money;
        if(s.money > maxY) maxY = s.money;
        if(s.heat  < minY) minY = s.heat;
        if(s.heat  > maxY) maxY = s.heat;
        if((s.spent||0) < minY) minY = (s.spent||0);
        if((s.spent||0) > maxY) maxY = (s.spent||0);
      }
      if(!Number.isFinite(minY) || !Number.isFinite(maxY)){
        minY = 0; maxY = 1;
      }
      if(minY === maxY){ maxY = minY + 1; }
      // clear
      ctx.clearRect(0,0,w,h);
      // grid
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--muted-2') || '#334155';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let i=0;i<=4;i++){
        const y = Math.round((h-16) * (i/4) + 8);
        ctx.moveTo(0,y); ctx.lineTo(w,y);
      }
      ctx.stroke();
      ctx.globalAlpha = 1;

      // X scaling
      if(count < 2) return;
      const t0 = series[0].t;
      const tN = series[count-1].t;
      const span = Math.max(1, tN - t0);
      const xFor = (t)=> Math.round(((t - t0) / span) * (w - 10) + 5);

      const style = getComputedStyle(document.documentElement);
      const colSpent = style.getPropertyValue('--danger') || '#ef4444';
      const colMoney = style.getPropertyValue('--good') || '#22c55e';
      const colHeat  = style.getPropertyValue('--accent-warm') || '#f59e0b';

      // draw line helper
      function drawLine(getY, color){
        ctx.beginPath();
        ctx.lineWidth = 2;
        ctx.strokeStyle = color.trim();
        for(let i=0;i<count;i++){
          const s = series[i];
          const x = xFor(s.t);
          const y = getY(s);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }

      drawLine(s => mapY(s.money, minY, maxY, h), colMoney);
      drawLine(s => mapY(s.heat,  minY, maxY, h), colHeat);
      drawLine(s => mapY((s.spent||0),  minY, maxY, h), colSpent);

      // Debug labels
      const dbgCt = document.getElementById('dbgSampleCt'); if(dbgCt) dbgCt.textContent = String(count);
      const dbgYMin = document.getElementById('dbgYMin'); if(dbgYMin) dbgYMin.textContent = String(minY);
      const dbgYMax = document.getElementById('dbgYMax'); if(dbgYMax) dbgYMax.textContent = String(maxY);
    }
    // =========================================================================
    
    
    

    // Stats helpers
    function ensureStat(name){
      if(!state.stats[name]) state.stats[name] = { level: 0, xp: 0 };
      return state.stats[name];
    }
    function xpToNext(level){
      return Math.floor(XP_BASE * Math.pow(XP_GROWTH, level));
    }
    function emitStatChange(name, leveled){
      const s = state.stats[name];
      if(!s) return;
      window.dispatchEvent(new CustomEvent('statchange', {
        detail: { name, stat: { level: s.level, xp: s.xp }, leveled: !!leveled }
      }));
      scheduleSave(); // autosave on stat change
    }
    function awardXP(name, amount){
      const s = ensureStat(name);
      s.xp += amount;
      let leveled = false;
      let needed = xpToNext(s.level);
      while(s.xp >= needed){
        s.xp -= needed;
        s.level++;
        leveled = true;
        addLog(`${name} leveled up! Now L${s.level}.`);
        needed = xpToNext(s.level);
      }
      emitStatChange(name, leveled);
      return leveled;
    }
    function getLevel(name){
      return (state.stats[name]?.level) || 0;
    }

    // Inventory helpers =======================================================
    const VALID_SLOTS = ['head','chest','hands','legs','feet','accessory'];
    const VALID_RARITY = ['common','uncommon','rare'];

      // === Inventory capacity (base 6, expandable by equipped items) ===
      function BASE_INV_CAPACITY(){ return 6; } // use function for hoisting friendliness

      
    // (removed duplicate getEquippedItems; using original)


      function getInventoryCapacity(){
        // Base capacity + any equipped item modifiers
        let cap = BASE_INV_CAPACITY();
        try{
          const equipped = getEquippedItems();
          for(const it of equipped){
            if(!it) continue;
            // Simple numeric property support
            if(typeof it.invCapAdd === 'number'){ cap += Math.max(0, it.invCapAdd|0); }
            // Mods array support: { kind:'invCapAdd', value:number }
            if(Array.isArray(it.mods)){
              for(const m of it.mods){
                if(m && (m.kind === 'invCapAdd' || m.type === 'invCapAdd')){
                  const v = Number(m.value||m.amount||0);
                  if(!isNaN(v)) cap += Math.max(0, v|0);
                }
              }
            }
          }
        }catch(e){}
        return Math.max(1, cap|0);
      }

      function inventoryUsed(){
        try{ return (state.inventory && state.inventory.length) ? state.inventory.length|0 : 0; }catch(e){ return 0; }
      }

      function hasInventorySpace(extraSlots){
        const need = Math.max(1, Number(extraSlots)||1);
        return (inventoryUsed() + need) <= getInventoryCapacity();
      }
    function sanitizeInventory(arr){
      const out = [];
      if(!Array.isArray(arr)) return out;
      for(const it of arr.slice(0,50)){
        if(!it || typeof it !== 'object') continue;
        let id = String(it.id || '').slice(0, 40);
        let name = String(it.name || '').slice(0, 60);
        const type = (it.type === 'consumable') ? 'consumable' : null;
        if(type === 'consumable'){
          const qty = Math.max(0, Math.min(99, Number(it.qty)||0));
          const eff = it.effect && typeof it.effect === 'object' ? { target: (it.effect.target==='hunger'?'hunger':'health'), pct: Math.max(0, Math.min(100, Number(it.effect.pct)||0)) } : null;
          if(id && name && eff){ out.push({ id, name, type, qty: qty||1, effect: eff, rarity:'common' }); }
          continue;
        }
        let slot = VALID_SLOTS.includes(it.slot) ? it.slot : null;
        let rarity = VALID_RARITY.includes(it.rarity) ? it.rarity : 'common';
        let equipped = !!it.equipped;
        if(id && name && slot){
          const invCapAdd = (typeof it.invCapAdd === 'number') ? it.invCapAdd|0 : undefined;
          const mods = Array.isArray(it.mods) ? it.mods.slice(0,10) : undefined;
          const obj = { id, name, slot, rarity, equipped };
          if(typeof invCapAdd === 'number') obj.invCapAdd = invCapAdd;
          if(mods) obj.mods = mods;
          out.push(obj);
        }
      }
      return out;
    }
    function hasSeededOnce(){ try{ return !!(state.lifetime && state.lifetime.seededOnce); }catch(e){ return false; } }

function seedFakeItems(){
      if(Array.isArray(state.inventory) && state.inventory.length) return;
      state.inventory = [
        { id:'itm-beanie',   name:'Worn Beanie',        slot:'head',      rarity:'common',   equipped:false },
        { id:'itm-hoodie',   name:'Threadbare Hoodie',  slot:'chest',     rarity:'common',   invCapAdd: 2, equipped:false },{ id:'itm-gloves',   name:'Work Gloves',        slot:'hands',     rarity:'common',   equipped:false },
        { id:'itm-trousers', name:'Cargo Trousers',     slot:'legs',      rarity:'common',   equipped:false },
        { id:'itm-trainers', name:'Old Trainers',       slot:'feet',      rarity:'common',   equipped:false },
        { id:'itm-charm',    name:'Lucky Charm',        slot:'accessory', rarity:'uncommon', equipped:false }
      ];
    
      state.lifetime = state.lifetime || {}; state.lifetime.seededOnce = true;
    }
    function getEquippedId(slot){
      const v = state.equipment[slot];
      if(!v) return null;
      return String(v);
    }
    function itemById(id){
      return (state.inventory || []).find(i => i.id === id);
    }
    function reconcileEquipment(){
      // If equipment points to non-existent items, clear it.
      for(const s of VALID_SLOTS){
        const id = getEquippedId(s);
        if(!id || !itemById(id)){
          state.equipment[s] = null;
        }
      }
      // If any items marked equipped but slot not set, set them.
      for(const it of state.inventory){
        if(it.equipped){
          const cur = getEquippedId(it.slot);
          if(!cur){ state.equipment[it.slot] = it.id; }
          else if(cur !== it.id){ it.equipped = false; }
        }
      }
    }
    function equipItem(itemId){
      const it = itemById(itemId);
      if(!it) return;
      const slot = it.slot;
      const prev = getEquippedId(slot);
      if(prev){
        const old = itemById(prev);
        if(old) old.equipped = false;
      }
      state.equipment[slot] = it.id;
      it.equipped = true;
      pushLog(`Equipped ${spanItem(it)} → ${slot}`);
      scheduleSave();
      updateUI();
    }
    function unequipSlot(slot){
      const prev = getEquippedId(slot);
      if(!prev) return;
      const it = itemById(prev);
      const _logFrag = it ? spanItem(it) : 'item';
      if(it) it.equipped = false;
      state.equipment[slot] = null;
      pushLog(`Unequipped ${_logFrag} from ${slot}`);
      scheduleSave();
      updateUI();
    }
    
    // Helper: summarize item mods into a short human-readable buff line
    function getItemBuffLine(it){
      try{
        const mods = Array.isArray(it && it.mods) ? it.mods : [];
        const parts = [];
        for(const m of mods){
          if(!m || typeof m!=='object') continue;
          const v = Number(m.value)||0;
          if(m.kind === 'strAdd'){ parts.push(`+${v} Strength`); }
          else if(m.kind === 'toughAdd'){ parts.push(`+${v} Toughness`); }
          else if(m.kind === 'moneyMult'){ parts.push(`${v>0?'+':''}${Math.round(v*100)}% Money`); }
          else if(m.kind === 'heatGainMult'){ parts.push(`${v>0?'+':''}${Math.round(v*100)}% Heat Gain`); }
          else if(m.kind === 'heatDecayMult'){ parts.push(`${v>0?'+':''}${Math.round(v*100)}% Heat Decay`); }
          else if(m.kind === 'successAdd' && m.action){ parts.push(`${v>0?'+':''}${Math.round(v*100)}% ${String(m.action)} success`); }
        }
        return parts.length ? `Provides ${parts.join(', ')}.` : '';
      }catch(e){ return ''; }
    }

    function renderInventoryGrid(){
      const grid = document.getElementById('invGrid');
      const empty = document.getElementById('invEmpty');
      if(!grid || !empty) return;
      const items = state.inventory || [];
      // Update inventory space text
      try{
        const usedEl = document.getElementById('invUsed');
        if(usedEl) usedEl.textContent = String(inventoryUsed());
        const capEl = document.getElementById('invCap');
        if(capEl) capEl.textContent = String(getInventoryCapacity());
      }catch(e){}
      if(items.length === 0){
        empty.classList.remove('hidden');
        grid.classList.add('hidden');
        grid.innerHTML = '';
        return;
      }
      empty.classList.add('hidden');
      grid.classList.remove('hidden');
      grid.innerHTML = items.map(it => {
        const isEquip = it.slot && !it.type;
        const isCons = it.type === 'consumable';
        const eq = isEquip && (getEquippedId(it.slot) === it.id);
        const rightTag = isCons ? `<span class="tag">x${it.qty||1}</span>` : `<span class="tag rarity-${escapeHtml(it.rarity)}">${escapeHtml(it.rarity||'')}</span>`;
        const subTag  = isCons ? `<span class="tag">Use: ${escapeHtml((it.effect?.target||'')+ ' +' + (it.effect?.pct||0) + '%')}</span>` : `<span class="tag slot">Slot: ${escapeHtml(it.slot||'')}</span>`;
        const btns = isCons
          ? `<button class="btn sm" data-use="${it.id}">Use</button>`
          : (eq ? `<button class="btn sm secondary" data-unequip="${it.slot}">Unequip</button>` : `<button class="btn sm" data-equip="${it.id}">Equip</button>`);
                const descHtml = (function(){
          // Base flavor for known items
          let base = (function(){
            switch(it.id){
              case 'itm-beanie':   return 'Keeps your head just warm enough.';
              case 'itm-hoodie':   return 'Roomy and familiar. Grants +2 inventory space.';
              case 'itm-gloves':   return 'Scuffed work gloves—better grip; fewer splinters.';
              case 'itm-trousers': return 'Beat-up cargos with too many pockets.';
              case 'itm-trainers': return 'Old but comfy. Better than barefoot.';
              case 'itm-charm':    return 'A trinket said to tilt the odds in your favour.';
              default: return '';
            }
          })();
          const buffLine = typeof getItemBuffLine==='function' ? getItemBuffLine(it) : '';
          const full = [base, buffLine].filter(Boolean).join(' ');
          return full ? `<div class="desc">${escapeHtml(full)}</div>` : '';
        })();
return `
          <div class="inv-item ${eq ? 'equipped':''}" data-id="${escapeHtml(it.id)}">
            <div class="top"><div class="name">${escapeHtml(it.name)}</div>
              ${rightTag}
            </div>
                        ${descHtml}
            <div class="row" style="gap:6px">${subTag}</div>

            <div class="actions">${btns}</div>
          </div>`;
      }).join('');
      // Wire buttons
      grid.querySelectorAll('[data-equip]').forEach(btn => { btn.addEventListener('click', () => equipItem(btn.getAttribute('data-equip'))); });
      grid.querySelectorAll('[data-unequip]').forEach(btn => { btn.addEventListener('click', () => unequipSlot(btn.getAttribute('data-unequip'))); });
      grid.querySelectorAll('[data-use]').forEach(btn => { btn.addEventListener('click', () => useConsumable(btn.getAttribute('data-use'))); });
      enhanceInventoryWithStoreButtons();
    }

    
    // Add contextual "Store" buttons to inventory cards when HQ has capacity
    function enhanceInventoryWithStoreButtons(){
      try{
        const grid = document.getElementById('invGrid'); if(!grid) return;
        const h = getHQRecord();
        if(!h) return; // no HQ, no store buttons
        const cap = getHQCapacity();
        const used = storageUsed();
        const full = used >= cap;
        grid.querySelectorAll('.inv-item').forEach(el => {
          if(el.classList.contains('equipped')) return; // don't allow storing equipped items
          const id = el.getAttribute('data-id');
          if(!id) return;
          const actions = el.querySelector('.actions'); if(!actions) return;
          if(actions.querySelector('[data-store]')) return; // already added
          const btn = document.createElement('button');
          btn.className = 'btn sm';
          btn.textContent = 'Store';
          btn.setAttribute('data-store', id);
          if(full) btn.disabled = true;
          actions.appendChild(btn);
        });
        // Wire listeners
        grid.querySelectorAll('[data-store]').forEach(btn => {
          btn.addEventListener('click', () => moveToStorage(btn.getAttribute('data-store')));
        });
      }catch(e){}
    }

    // Default stats to seed into state so the Stats screen isn't empty.
    const DEFAULT_STATS = [
      "Sleight of Hand",
      "Street Smarts",
      "Awareness",
      "Negotiation",
      "Charm",
      "Leadership",
      "Logistics",
      "Reputation"
    ];
    function ensureDefaultStats(){
      DEFAULT_STATS.forEach(n => ensureStat(n));
    }

    // HEAT helpers
    function addHeat(delta){
      const before = state.heat;
      state.heat = clamp(state.heat + delta, HEAT_MIN, HEAT_MAX);
      const change = state.heat - before;
      if(change !== 0){
        if(change > 0){ state.metrics.heat.gained += change; } else { state.metrics.heat.cooled += -change; }
        if(state.heat > state.metrics.heat.peak) state.metrics.heat.peak = state.heat;
        addLog(`Heat ${change > 0 ? "+"+change : change} (now ${state.heat})`);
        scheduleSave();
      }
    }
    function decayHeat(){
      const now = Date.now();
      if(state.heat <= HEAT_MIN) { lastHeatDecayAt = now; return; }
      const elapsed = now - lastHeatDecayAt;
      if(elapsed >= HEAT_DECAY_INTERVAL_MS){
        const steps = Math.floor(elapsed / HEAT_DECAY_INTERVAL_MS);
        lastHeatDecayAt += steps * HEAT_DECAY_INTERVAL_MS;
        addHeat(-steps);
      }
    }

    // Success chance depends on Sleight of Hand level and Heat penalty
    function successChance(){
      const base = BASE_SUCCESS;
      const bonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
      const penalty = state.heat * HEAT_PENALTY_PER_HEAT;
      const raw = base + bonus - penalty;
      return clamp(raw, 0.05, 0.90);
    }
    function isCooling(){ return !!(pickEndsAt && Date.now() < pickEndsAt); }
    function timeLeft(){ return Math.max(0, (pickEndsAt || 0) - Date.now()); }

    // Keep chance debug text in sync for both actions
    function updateChanceDebug(){
      // Pickpocket
      try{
        const ch = successChance();
        const base = BASE_SUCCESS;
        const bonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
        const penalty = state.heat * HEAT_PENALTY_PER_HEAT;
        const detEl = document.getElementById("chanceDetail");
        if(detEl){ detEl.textContent = `base ${Math.round(base*100)}% + sleight ${Math.round(bonus*100)}% − heat ${Math.round(penalty*100)}% (clamped 5–90%)`; }
        const cv = document.getElementById("chanceValue");
        if(cv){ cv.textContent = Math.round(ch * 100); }
      }catch(e){}
      // Search Bags
      try{
        const sch = successChanceSearch();
        const sDet = document.getElementById("searchChanceDetail");
        if(sDet){
          const sBase = SEARCH_BASE_SUCCESS;
          const sBonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
          const sPenalty = state.heat * HEAT_PENALTY_PER_HEAT;
          sDet.textContent = `base ${Math.round(sBase*100)}% + sleight ${Math.round(sBonus*100)}% − heat ${Math.round(sPenalty*100)}% (clamped 5–90%)`;
        }
        const sVal = document.getElementById("searchChanceValue");
        if(sVal){ sVal.textContent = Math.round(sch * 100); }
      }catch(e){}
    }

    function syncActionButtons(){
      const pickBtn = document.getElementById("pickBtn");
      const searchBtn = document.getElementById("searchBtn");
      const searchLockedNote = document.getElementById("searchLockedNote");
      const unlocked = typeof canUseSearchBags === 'function' ? canUseSearchBags() : true;
      const cooling = isCooling();
      if (pickBtn){
        pickBtn.disabled = cooling;
        pickBtn.textContent = cooling ? `Cooling… ${Math.ceil(timeLeft()/1000)}s` : "Attempt Pickpocket";
      }
      if (searchBtn){
        searchBtn.disabled = cooling || !unlocked;
      }
      if (searchLockedNote){
        searchLockedNote.style.display = unlocked ? 'none' : 'inline';
      }
    }

    // --- Core action ---
function doPickpocket(){
  if(isCooling()) return;
  currentJob = 'pick';
  pickEndsAt = Date.now() + COOLDOWN_MS;

  const roll = Math.random();
  if(roll < successChance()){
    const cash = randInt(PICK_MIN_CASH, PICK_MAX_CASH);
    changeMoney(cash, 'pickpocket');
    Object.entries(XP_AWARD_SUCCESS).forEach(([name, amt]) => awardXP(name, amt));
    addHeat(HEAT_GAIN_SUCCESS);
    pushLog(`Success: you lifted ${spanMoney(cash)}. (${spanXP(XP_AWARD_SUCCESS["Sleight of Hand"], "Sleight of Hand")}, ${spanXP(XP_AWARD_SUCCESS["Street Smarts"], "Street Smarts")})`);
  }else{
    Object.entries(XP_AWARD_FAIL).forEach(([name, amt]) => awardXP(name, amt));
    addHeat(HEAT_GAIN_FAIL);
    pushLog(`${spanBad('Failed attempt')}: no gain. (${spanXP(XP_AWARD_FAIL["Sleight of Hand"], "Sleight of Hand")}, Heat +${HEAT_GAIN_FAIL})`);
  }
  scheduleSave();
  updateUI();
}

// --- New Action: Search Bags ---

function successChanceSearch(){
  const base = SEARCH_BASE_SUCCESS;
  const bonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
  const penalty = state.heat * HEAT_PENALTY_PER_HEAT;
  return clamp(base + bonus - penalty, 0.05, 0.90);
}
function canUseSearchBags(){
  return getLevel("Sleight of Hand") >= SEARCH_UNLOCK_LEVEL;
}
function doSearchBags(){
  if(isCooling()) return;
  if(!canUseSearchBags()) return;
  currentJob = 'search';
  pickEndsAt = Date.now() + COOLDOWN_MS;

  const roll = Math.random();
  if(roll < successChanceSearch()){
    const cash = randInt(SEARCH_MIN_CASH, SEARCH_MAX_CASH);
    changeMoney(cash, 'searchbags');
    Object.entries(XP_AWARD_SUCCESS).forEach(([name, amt]) => awardXP(name, amt));
    addHeat(HEAT_GAIN_SUCCESS);
    pushLog(`Success: you searched a bag and found ${spanMoney(cash)}. (${spanXP(XP_AWARD_SUCCESS["Sleight of Hand"], "Sleight of Hand")}, ${spanXP(XP_AWARD_SUCCESS["Street Smarts"], "Street Smarts")})`);
  }
else{
        Object.entries(XP_AWARD_FAIL).forEach(([name, amt]) => awardXP(name, amt));
        addHeat(HEAT_GAIN_FAIL);
        pushLog(`${spanBad('Failed attempt')}: no gain. (${spanXP(XP_AWARD_FAIL["Sleight of Hand"], "Sleight of Hand")}, Heat +${HEAT_GAIN_FAIL})`);
      }
      scheduleSave();
      updateUI();
    }

    // --- UI update ---
    function renderStatRow(name, s){
      const needed = xpToNext(s.level);
      const pct = needed > 0 ? Math.min(1, s.xp / needed) : 1;
      const id = slug(name);
      // Show gear contribution for Strength/Toughness
      const buffs = getEquippedBuffTotals();
      const gearAdd = name === 'Strength' ? (buffs.strAdd||0) : (name === 'Toughness' ? (buffs.toughAdd||0) : 0);
      const gearFrag = gearAdd ? ` <span class="pill sm">+${gearAdd} gear</span>` : '';
      return `
        <div class="statrow" id="stat-${id}" data-stat-name="${escapeHtml(name)}" data-level="${s.level}" data-xp="${s.xp}">
          <div class="statheader">
            <div class="statname">${escapeHtml(name)}</div>
            <div class="small muted">L<span id="stat-${id}-level">${s.level}</span>${gearFrag} • <span id="stat-${id}-pct">${Math.round(pct*100)}%</span> (<span id="stat-${id}-xp">${s.xp}</span>/<span id="stat-${id}-need">${needed}</span> XP)</div>
          </div>
          <div class="progress" aria-label="${escapeHtml(name)} XP progress">
            <div class="bar" id="stat-${id}-bar" style="width:${(pct*100).toFixed(2)}%"></div>
          </div>
          <div class="small codepath debug-block">
            Source: <strong>state.stats['${escapeHtml(name)}']</strong>, xp=<span id="stat-${id}-xp-inline">${s.xp}</span>, toNext=<span id="stat-${id}-need-inline">${needed}</span>
          </div>
        </div>
      `;
    }

    function applyDebugUI(){
      const debug = localStorage.getItem(DEBUG_KEY) === '1';
      document.body.classList.toggle('debug', debug);
      const btn = document.getElementById('debugBtn');
      if(btn){ btn.textContent = 'Debug: ' + (debug ? 'On' : 'Off'); }
      updateAutoSaveUI();
      // Analytics render
      const m = state.metrics;
      const eEl = document.getElementById("metricEarned");
      if(eEl){
        const earned = m.money.earned|0, spent = m.money.spent|0, net = Math.max(0, earned - spent);
        eEl.textContent = "£" + earned;
        const sEl = document.getElementById("metricSpent"); if(sEl) sEl.textContent = "£" + spent;
      // Refresh debug chance lines on toggle
      try{ updateChanceDebug(); }catch(e){}
        const nEl = document.getElementById("metricNet"); if(nEl){ nEl.textContent = "£" + net; nEl.style.color = (net >= 0 ? "var(--good)" : "var(--danger)"); }
        const eSrc = document.getElementById("metricEarnedSrc"); if(eSrc) eSrc.textContent = String(earned);
        const sSrc2 = document.getElementById("metricSpentSrc"); if(sSrc2) sSrc2.textContent = String(spent);
        // Heat
        const hc = document.getElementById("metricHeatCurrent"); if(hc) hc.textContent = String(state.heat);
        const hp = document.getElementById("metricHeatPeak"); if(hp) hp.textContent = String(m.heat.peak|0);
        const hg = document.getElementById("metricHeatGained"); if(hg) hg.textContent = String(m.heat.gained|0);
        const hco = document.getElementById("metricHeatCooled"); if(hco) hco.textContent = String(m.heat.cooled|0);
        const ha = document.getElementById("metricHeatAvg"); if(ha) ha.textContent = String(m.heat.avg||0);
        const hSrcP = document.getElementById("metricHeatPeakSrc"); if(hSrcP) hSrcP.textContent = String(m.heat.peak|0);
        const hSrcG = document.getElementById("metricHeatGainedSrc"); if(hSrcG) hSrcG.textContent = String(m.heat.gained|0);
        const hSrcC = document.getElementById("metricHeatCooledSrc"); if(hSrcC) hSrcC.textContent = String(m.heat.cooled|0);
        const hSrcA = document.getElementById("metricHeatAvgSrc"); if(hSrcA) hSrcA.textContent = String(m.heat.avg||0);
        const hb = document.getElementById("metricHeatBar"); if(hb){ hb.style.width = Math.min(100, (state.heat/HEAT_MAX)*100).toFixed(2) + "%"; }
      }

    }

    function toggleDebug(){
      const debug = localStorage.getItem(DEBUG_KEY) === '1';
      localStorage.setItem(DEBUG_KEY, debug ? '0' : '1');
      applyDebugUI();
    }

    function setActiveTab(id){
      // side links
      
      // Category buttons
      const bPetty = document.getElementById("btnCatPetty");
      const bSmall = document.getElementById("btnCatSmall");
      
      
      renderPropertyMarket();
      renderHeadquarters();
      const btnHqRef=document.getElementById('hqRefresh'); if(btnHqRef){ btnHqRef.addEventListener('click', ()=>renderHeadquarters()); }
      const bStore=document.getElementById('btnHQStorage'); if(bStore){ bStore.addEventListener('click', openStorageManager); }
      const bGarage=document.getElementById('btnHQGarage'); if(bGarage){ bGarage.addEventListener('click', ()=> addLog('Garage UI WIP')); }
      const closeS=document.getElementById('closeStorage'); if(closeS){ closeS.addEventListener('click', closeStorageManager); }
      const bRent = document.getElementById('btnPropRent');
      const bBuy  = document.getElementById('btnPropBuy');
      const bHold = document.getElementById('btnPropHoldings');
      if(bRent && !bRent.dataset.bound){ bRent.addEventListener('click', () => setPropertyCategory('rent')); bRent.dataset.bound='1'; }
      if(bBuy  && !bBuy.dataset.bound ){ bBuy .addEventListener('click', () => setPropertyCategory('buy'));  bBuy.dataset.bound='1'; }
      if(bHold && !bHold.dataset.bound){ bHold.addEventListener('click', () => setPropertyCategory('holdings')); bHold.dataset.bound='1'; }
document.querySelectorAll(".sidelink").forEach(link => {
        const active = link.dataset.tab === id;
        link.setAttribute("aria-current", active ? "page" : "");
      });
      const views = ["headquarters", "property", "activities", "recruitment", "stats", "inventory", "upgrades", "shop", "analytics","mail","gambling"]; const catsRow = document.getElementById("activityCats");
      views.forEach(v => {
        const el = document.getElementById("view-" + v);
        const active = (v === id);
        el.classList.toggle("hidden", !active); if(catsRow){ catsRow.classList.toggle("hidden", id !== "activities"); }
        el.setAttribute("aria-hidden", (!active).toString());
      });
      if(id === "analytics"){ const label = document.getElementById("dbgRangeLabel"); if(label){ label.textContent = (chartRange === "all" ? "all" : chartRange === "session" ? "session" : (Math.round((chartRange/60000)) + "m")); } chartNeedsDraw = true; drawChart(); }
      if(id === "shop"){ renderShop(); }
      if(id === "property"){ renderPropertyMarket(); }
      if(id === "headquarters"){ renderHeadquarters(); }
    }

    
    function renderEquipmentUI(){
      const slots = ['head','chest','hands','legs','feet','accessory'];
      slots.forEach(slot => {
        const val = state.equipment[slot];
        const label = document.getElementById(`slot-${slot}-label`);
        const badges = document.querySelectorAll(`.slot[data-slot="${slot}"]`);
        const filled = !!val;
        badges.forEach(b => b.classList.toggle('filled', filled));
        if(label){
          let txt = '(Empty)';
          if(filled){ const it = itemById(String(val)); txt = it ? it.name : String(val); }
          label.textContent = txt;
          label.classList.toggle('muted', !filled);
        }
      });
    }
    
function renderEquipChoices(slot){
  const list = document.getElementById('equipList');
  const none = document.getElementById('equipNone');
  const unequipBtn = document.getElementById('equipUnequipBtn');

  if(!list || !none || !unequipBtn) return;

  const inv = Array.isArray(state.inventory) ? state.inventory : [];
  const items = inv.filter(it => it && it.slot === slot);
  const equippedId = getEquippedId(slot);

  list.innerHTML = items.map(it => {
    const isEquipped = equippedId === it.id;
    const action = isEquipped
      ? `<span class="pill">Equipped</span>`
      : `<button class="btn" data-equip="${escapeHtml(it.id)}">Equip</button>`;
    const rarity = it.rarity ? String(it.rarity) : '';
    const name = it.name ? String(it.name) : `Item ${escapeHtml(it.id)}`;
    return `
      <li class="shop-row" data-id="${escapeHtml(it.id)}">
        <div class="meta">
          <div class="name">${escapeHtml(name)}</div>
          <div class="sub">
            ${rarity ? `<span class="tag rarity-${escapeHtml(rarity)}">${escapeHtml(rarity)}</span>` : ''}
            <span class="tag slot">Slot: ${escapeHtml(slot)}</span>
          </div>
        </div>
        <div class="row" style="gap:8px">${action}</div>
      </li>`;
  }).join('');

  none.textContent = `You don't have any ${slot} items to equip.`;
  none.style.display = items.length ? 'none' : 'block';

  unequipBtn.disabled = !equippedId;

  list.querySelectorAll('[data-equip]').forEach(btn => {
    btn.addEventListener('click', () => {
      const id = btn.getAttribute('data-equip');
      equipItem(id);
      // Close dialog (support browsers without <dialog>)
      const dlg = document.getElementById('equipDialog');
      try{ dlg.close(); }catch(e){ dlg.removeAttribute('open'); }
    }, { once: true });
  });

  unequipBtn.onclick = (e) => {
    e.preventDefault();
    unequipSlot(slot);
    const dlg = document.getElementById('equipDialog');
    try{ dlg.close(); }catch(e){ dlg.removeAttribute('open'); }
  };
}


function openEquipSlot(slot){
  const dlg = document.getElementById('equipDialog');
  if(!dlg) return;
  const nameMap = { head:'Head', chest:'Chest', hands:'Hands', legs:'Legs', feet:'Feet', accessory:'Accessory' };
  document.getElementById('equipSlotName').textContent = nameMap[slot] || slot;
  document.getElementById('equipSlotKey').textContent = slot;

  // Populate choices for this slot
  renderEquipChoices(slot);

  try{ dlg.showModal(); }catch(e){ dlg.setAttribute('open',''); }
}


    
    function setAlias(name){
      const trimmed = String(name || '').trim();
      const safe = trimmed.replace(/[^a-zA-Z0-9 _-]/g, '').slice(1-1, 24); // keep 0..24 safe chars
      state.profile.alias = safe;
      addLog(safe ? `Alias set to: ${safe}` : 'Alias cleared');
      scheduleSave();
      updateUI();
    }
    function openAliasDialog(){
      const dlg = document.getElementById('aliasDialog');
      const input = document.getElementById('aliasInput');
      const err = document.getElementById('aliasError');
      if(!dlg || !input || !err) return;
      input.value = state.profile.alias || '';
      err.style.display = 'none';
      try{ dlg.showModal(); }catch(e){ dlg.setAttribute('open',''); }
    }

    
    // === Buff Totals (derived from equipped items) ===========================
    // Supported mod kinds per item: 
    //  - { kind:'moneyMult', value:+0.05 }
    //  - { kind:'heatGainMult', value:-0.10 }
    //  - { kind:'heatDecayMult', value:+0.15 }
    //  - { kind:'successAdd', action:'pickpocket', value:+0.02 }
    //  - { kind:'statXpMult', stat:'Sleight of Hand', value:+0.10 }
    function getEquippedItems(){
      const slots = ['head','chest','hands','legs','feet','accessory'];
      const out = [];
      for(const s of slots){
        const id = state.equipment[s];
        if(!id) continue;
        const it = itemById(String(id));
        if(it) out.push(it);
      }
      return out;
    }
    function getEquippedBuffTotals(){
      const totals = {
        moneyMult: 0,
        heatGainMult: 0,
        heatDecayMult: 0,
        successAdd: { pickpocket: 0 },
        statXpMult: {},
        strAdd: 0,
        toughAdd: 0
      };
      const items = getEquippedItems();
      for(const it of items){
        const mods = Array.isArray(it.mods) ? it.mods : [];
        for(const m of mods){
          if(!m || typeof m !== 'object') continue;
          const kind = m.kind;
          const val = Number(m.value) || 0;
          if(kind === 'moneyMult'){ totals.moneyMult += val; }
          else if(kind === 'heatGainMult'){ totals.heatGainMult += val; }
          else if(kind === 'heatDecayMult'){ totals.heatDecayMult += val; }
          else if(kind === 'successAdd'){
            const a = m.action || 'pickpocket';
            totals.successAdd[a] = (totals.successAdd[a]||0) + val;
          }
          else if(kind === 'statXpMult' && m.stat){
            const s = String(m.stat);
            totals.statXpMult[s] = (totals.statXpMult[s]||0) + val;
          }
          else if(kind === 'strAdd'){ totals.strAdd += val; }
          else if(kind === 'toughAdd'){ totals.toughAdd += val; }
        }
      }
      return totals;
    }
    
function renderBuffSummary(){
  const el = document.getElementById('buffPills'); if(!el) return;
  const t = getEquippedBuffTotals();
  const pills = [];
  const pct = (x)=> `${x>0?'+':''}${Math.round(x*100)}%`;
  if(t.moneyMult) pills.push(`<span class="pill">Money ${pct(t.moneyMult)}</span>`);
  if(t.heatGainMult) pills.push(`<span class="pill">Heat gain ${pct(t.heatGainMult)}</span>`);
  if(t.heatDecayMult) pills.push(`<span class="pill">Heat decay ${pct(t.heatDecayMult)}</span>`);
  if(t.successAdd && t.successAdd.pickpocket) pills.push(`<span class="pill">Pickpocket success ${pct(t.successAdd.pickpocket)}</span>`);
  // Stat XP multipliers
  if(t.statXpMult){
    for(const [stat,val] of Object.entries(t.statXpMult)){ if(val) pills.push(`<span class="pill">${escapeHtml(stat)} XP ${pct(val)}</span>`); }
  }
  // New: flat stat adds from gear
  if(t.strAdd)   pills.push(`<span class="pill">Strength +${t.strAdd}</span>`);
  if(t.toughAdd) pills.push(`<span class="pill">Toughness +${t.toughAdd}</span>`);
  if(!pills.length) pills.push('<span class="pill muted">No active buffs</span>');
  el.innerHTML = pills.join('');
}

// === Vitals & Shop =======================================================
    const HUNGER_DECAY_PER_SEC = 0.02; // % per second
    function clampPct(x){ const n = Number(x); return Math.max(0, Math.min(100, Number.isFinite(n)? n : 0)); }
    function addHealth(pct){ const before = state.vitals.health; state.vitals.health = clampPct(before + pct); addLog(`Health ${pct>0?'+':''}${pct}% (now ${Number(state.vitals.health).toFixed(0)}%)`); scheduleSave(); }
    function addHunger(pct){ const before = state.vitals.hunger; state.vitals.hunger = clampPct(before + pct); addLog(`Hunger ${pct>0?'+':''}${pct}% (now ${Number(state.vitals.hunger).toFixed(0)}%)`); scheduleSave(); }
    function decayHunger(dtSec){ if(dtSec<=0) return; const delta = HUNGER_DECAY_PER_SEC * dtSec; if(delta>0){ state.vitals.hunger = clampPct(state.vitals.hunger - delta); } }

    const SHOP_ITEMS = {
      food: [
        { id:'food-bread',   name:'Bread Roll',   pct:10, cost:5,  desc:'Restore 10% hunger', target:'hunger' },
        { id:'food-burger',  name:'Burger',       pct:40, cost:10, desc:'Restore 40% hunger', target:'hunger' },
        { id:'food-sand',    name:'Sandwich',     pct:25, cost:15, desc:'Restore 25% hunger', target:'hunger' },
        { id:'food-ramen',   name:'Hot Ramen',    pct:40, cost:30, desc:'Restore 40% hunger', target:'hunger' },
      ],
      med: [
        { id:'med-small',    name:'Small Medkit', pct:20, cost:25, desc:'Restore 20% health', target:'health' },
        { id:'med-large',    name:'Medkit',       pct:50, cost:60, desc:'Restore 50% health', target:'health' },
      ]
    };

    function renderShop(){
      const bal = document.getElementById('shopBalance'); if(bal) bal.textContent = String(state.money|0);
      const food = document.getElementById('shopFood'); const med = document.getElementById('shopMed');
      if(food){ food.innerHTML = SHOP_ITEMS.food.map(it => `<li class="shop-row"><div class="meta"><div class="name">${escapeHtml(it.name)}</div><div class="sub">${escapeHtml(it.desc)}</div></div><div class="row" style="gap:8px"><div class="pill">£${it.cost}</div><button class="btn" data-buy="${it.id}">Buy</button></div></li>`).join(''); }
      if(med){  med.innerHTML  = SHOP_ITEMS.med .map(it => `<li class="shop-row"><div class="meta"><div class="name">${escapeHtml(it.name)}</div><div class="sub">${escapeHtml(it.desc)}</div></div><div class="row" style="gap:8px"><div class="pill">£${it.cost}</div><button class="btn" data-buy="${it.id}">Buy</button></div></li>`).join(''); }
      document.querySelectorAll('[data-buy]').forEach(btn => btn.addEventListener('click', () => buyShop(btn.getAttribute('data-buy'))));
    }

    function buyShop(id){
      const it = SHOP_ITEMS.food.find(x=>x.id===id) || SHOP_ITEMS.med.find(x=>x.id===id);
      if(!it) return;
      // Capacity check: if this would create a new stack and there's no space, block purchase
      const willStack = !!(state.inventory||[]).find(x => x.type==='consumable' && x.id===it.id);
      if(!willStack && !hasInventorySpace(1)){ addLog('<span class="red">Inventory full</span>: no space for '+escapeHtml(it.name)); return; }
      if((state.money|0) < it.cost){ addLog('<span class="red">Not enough money</span> to buy '+escapeHtml(it.name)); return; }
      changeMoney(-it.cost, 'shop');
      addConsumableToInventory(it);
      pushLog(`<span class="red">-£${it.cost}</span> Bought ${spanItem(it)}`);
      renderInventoryGrid(); renderShop(); updateUI();
    }

    function addConsumableToInventory(shopItem){
      // Stack by id if already in inventory (consumable)
      const existing = (state.inventory||[]).find(x => x.type==='consumable' && x.id===shopItem.id);
      if(existing){ existing.qty = Math.min(99, (existing.qty||0)+1); return true; }
      if(!hasInventorySpace(1)){ addLog('<span class="red">Inventory full</span>: no space for '+escapeHtml(shopItem.name)); return false; }
      state.inventory.push({ 
        id: shopItem.id, name: shopItem.name, type:'consumable', qty:1,
        effect:{ target: shopItem.target, pct: shopItem.pct }, rarity:'common'
      });
      return true;
    };
    function dateKeyFromGameTime(){
      const d = new Date((state.time?.epochMs||0) + (state.time?.gameMs||0));
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,'0');
      const day = String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${day}`;
    }

    // ---- Restored helpers ----
function seededShuffle(arr, seed){
      let s = seed >>> 0;
      function rnd(){ s = (1664525 * s + 1013904223) >>> 0; return s / 4294967296; }
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(rnd()*(i+1));
        [a[i],a[j]] = [a[j],a[i]];
}
      return a;
    }

function endOfMonthMsFrom(ms){
      const d = new Date((state.time?.epochMs||0) + ms);
      // set to last day of month 23:59
      const y = d.getFullYear();
      const m = d.getMonth();
      const last = new Date(y, m+1, 0, 23, 59, 0, 0);
      return last.getTime() - (state.time?.epochMs||0);
    }

function useConsumable(itemId){
      const it = (state.inventory||[]).find(x => x.type==='consumable' && x.id===itemId);
      if(!it) return;
      const { target, pct } = it.effect || {};
      if(target==='hunger') addHunger(pct||0);
      else if(target==='health') addHealth(pct||0);
      // decrement qty/remove
      it.qty = Math.max(0, (it.qty||1) - 1);
      if(it.qty === 0){
        const idx = state.inventory.indexOf(it);
        if(idx >= 0) state.inventory.splice(idx,1);
      }
      scheduleSave();
      renderInventoryGrid(); updateUI();
    }

function simulateOffline(ms){ applyOfflineCatchup(ms); updateUI(); }

function applyOfflineCatchup(elapsedMs){
      if(!elapsedMs || elapsedMs <= 0) return;
      // advance in-game clock
      advanceGameTime(elapsedMs);
      // heat cool-down in batches (no hunger change)
      if(state.heat > HEAT_MIN){
        const steps = Math.floor(elapsedMs / HEAT_DECAY_INTERVAL_MS);
        if(steps > 0){
          addHeat(-steps);
        }
        // reset heat timer baseline so next decay happens after the remaining remainder
        lastHeatDecayAt = Date.now() - (elapsedMs % HEAT_DECAY_INTERVAL_MS);
      } else {
        lastHeatDecayAt = Date.now();
      }
      addLog(`Offline catch-up: +${formatDuration(elapsedMs)} (clock only), heat adjusted; hunger unchanged.`);
    }
    // Restored RENTAL_POOL
    const RENTAL_POOL = [
      { id:'rm-basement-1', name:'Damp Basement', loc:'South Quarter', storage:20, garage:0, monthly:60,  deposit:30, tier:0 },
      { id:'rm-locker-1',   name:'Storage Locker A12', loc:'Central Depot', storage:10, garage:0, monthly:35,  deposit:20, tier:0 },
      { id:'rm-locker-2',   name:'Storage Locker B7',  loc:'North Depot',   storage:16, garage:0, monthly:48,  deposit:24, tier:0 },
      { id:'rm-bedsit-1',   name:'Tiny Bedsit',       loc:'Old Town',      storage:12, garage:0, monthly:85,  deposit:50, tier:1 },
      { id:'rm-garage-1',   name:'Single Garage',     loc:'Riverside',     storage:8,  garage:1, monthly:120, deposit:80, tier:1 },
      { id:'rm-garage-2',   name:'Lock-up Garage',    loc:'Industrial Park',storage:14,garage:1, monthly:140, deposit:100, tier:1 },
      { id:'rm-shop-1',     name:'Corner Kiosk (Backroom)', loc:'Market Row', storage:25, garage:0, monthly:180, deposit:120, tier:2 },
      { id:'rm-workshop-1', name:'Tiny Workshop',     loc:'Back Alley',     storage:30, garage:0, monthly:220, deposit:160, tier:2 },
      { id:'rm-flat-1',     name:'Studio Flat',       loc:'Harbour',        storage:28, garage:0, monthly:250, deposit:200, tier:2 },
      { id:'rm-warehouse-1',name:'Half Warehouse Bay',loc:'Docks',          storage:60, garage:2, monthly:480, deposit:300, tier:3 },
      { id:'rm-warehouse-2',name:'Small Warehouse Unit',loc:'Ring Road',    storage:80, garage:1, monthly:520, deposit:360, tier:3 },
      { id:'rm-office-1',   name:'Back Office Space', loc:'Arcade',         storage:18, garage:0, monthly:160, deposit:120, tier:2 },
      { id:'rm-lockup-3',   name:'Hidden Lockup',     loc:'Canal Side',     storage:34, garage:0, monthly:260, deposit:180, tier:2 },
      { id:'rm-yard-1',     name:'Yard Shed',         loc:'Scrap Yard',     storage:22, garage:0, monthly:140, deposit:100, tier:1 },
      { id:'rm-shopback-2', name:'Back of Shop (Sublet)', loc:'High Street',storage:20, garage:0, monthly:210, deposit:150, tier:2 }
    ];






    function ensureDailyOffers(){

      if(!state.properties.daily) state.properties.daily = { dayKey:'', offers: [] };
      if(!state.hq || typeof state.hq !== 'object') state.hq = { propertyId: null };
      if(!state.storage || typeof state.storage !== 'object') state.storage = { items: [] };
      const key = dateKeyFromGameTime();
      if((state.properties.daily?.dayKey ?? '') !== key){
        // new day: choose 4-6 offers
        const seed = key.split('-').reduce((acc, s)=> (acc*131 + parseInt(s,10))|0, 7) >>> 0;
        const shuffled = seededShuffle(RENTAL_POOL, seed);
        const count = 4 + Math.floor((seed % 3)); // 4..6
        state.properties.daily.dayKey = key;
        state.properties.daily.offers = shuffled.slice(0, count);
        scheduleSave();
        addLog(`Property Market refreshed (${count} offers).`);
      }
    }
function renderRentOffers(){
      const wrap = document.getElementById('rentOffers'); if(!wrap) return;
      ensureDailyOffers();
      const dayEl = document.getElementById('rentDayKey'); if(dayEl) dayEl.textContent = state.properties.daily.dayKey || '—';
      const nextEl = document.getElementById('rentNextRefresh'); if(nextEl){
        // compute next midnight
        const d = new Date((state.time?.epochMs||0) + (state.time?.gameMs||0));
        const next = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1, 0, 0, 0, 0);
        nextEl.textContent = next.toDateString();
      }
      const offers = state.properties.daily.offers || [];
      if(offers.length === 0){
        wrap.innerHTML = '<div class="card"><p class="muted">No offers right now. Check back after midnight.</p></div>';
        return;
      }
      const owned = new Set((state.properties.holdings||[]).map(h=>h.id));
      
      wrap.innerHTML = offers.map(it => {
        const rented = owned.has(it.id);
        const tier = typeof it.tier === 'number' ? it.tier : 0;
        return `<div class="prop-card luxe tier-${tier}">
          <div class="prop-hero" aria-hidden="true"></div>
          <div class="prop-head">
            <div class="prop-name">${escapeHtml(it.name)}</div>
            <div class="prop-loc"><span class="ico">📍</span><span class="muted small">${escapeHtml(it.loc)}</span></div>
          </div>
          <div class="prop-meta fancy">
            <span class="pill"><span class="ico">📦</span> <span class="kv"><span class="label">Storage</span><span class="val">${it.storage}</span></span></span>
            <span class="pill"><span class="ico">🚗</span> <span class="kv"><span class="label">Garage</span><span class="val">${it.garage}</span></span></span>
          
          </div>
          <p class="small muted">${escapeHtml(describeProperty(it))}</p>
          <div class="prop-price">
            <div class="price" title="Monthly rent">
              <div class="main">£${it.monthly}</div>
              <div class="per">/month</div>
            </div>
            <div class="price" title="Refundable deposit (rules WIP)">
              <div class="main">£${it.deposit}</div>
              <div class="per">deposit</div>
            </div>
          </div>
          <div class="prop-actions">
            <button class="btn" ${rented?'disabled':''} data-rent="${it.id}">${rented?'Already Rented':'Rent this'}</button>
          </div>
        </div>`;
      }).join('');


      wrap.querySelectorAll('[data-rent]').forEach(btn => {
        btn.addEventListener('click', () => tryRent(btn.getAttribute('data-rent')));
      });
    }

    function tryRent(id){
      const it = (state.properties?.daily?.offers||[]).find(x=>x.id===id);
      if(!it) return;
      // check already rented
      if((state.properties.holdings||[]).some(h=>h.id===id)){
        addLog('You already rent this property.'); return;
      }
      if(state.money < it.deposit){
        addLog('<span class="red">Not enough money</span> for the deposit.');
        return;
      }
      changeMoney(-it.deposit, 'deposit');
      // first rent due = last day of current month 23:59 (game time)
      const due = endOfMonthMsFrom(state.time.gameMs||0);
      const rec = { id: it.id, name: it.name, loc: it.loc, storage: it.storage, garage: it.garage, monthly: it.monthly, deposit: it.deposit, nextRentDue: due, overdue:false, paid:0 };
      state.properties.holdings = state.properties.holdings || [];
      state.properties.holdings.push(rec);
      addLog(`Rented ${escapeHtml(it.name)} — deposit <span class="red">-£${it.deposit}</span>, first rent due at month end.`);
      scheduleSave();
      renderHoldings();
      renderRentOffers();
      updateUI();
    }

    function renderHoldings(){
      const list = document.getElementById('holdingsList'); if(!list) return;
      const arr = state.properties?.holdings || [];
      if(arr.length === 0){ list.innerHTML = '<div class="card"><p class="muted">No properties yet.</p></div>'; return; }
      
      list.innerHTML = arr.map(h => {
        const due = new Date((state.time?.epochMs||0) + h.nextRentDue);
        const dueStr = due.toDateString();
        const isHQ = ( (state.hq && state.hq.propertyId === h.id) || h.isHQ );
        const hqTag = isHQ ? `<span class="tag">HQ</span>` : '';
        const hqBtn = isHQ ? `<button class="btn secondary" disabled>Current HQ</button>`
                           : `<button class="btn" data-sethq="${h.id}">Set as HQ</button>`;
        return `<div class="prop-card">
          <div class="prop-head"><div class="prop-name">${escapeHtml(h.name)} ${hqTag}</div><div class="muted small">${escapeHtml(h.loc)}</div></div>
          <div class="prop-meta">
            <span class="pill">Storage: <strong>${h.storage}</strong></span>
            <span class="pill">Garage: <strong>${h.garage}</strong></span>
            <span class="pill">Monthly: <strong>£${h.monthly}</strong></span>
            <span class="pill">Next Due: <strong>${escapeHtml(dueStr)}</strong></span>
          </div>
          <div class="prop-actions">
            ${hqBtn}
            <button class="btn secondary" data-end="${h.id}">End Lease (forfeit deposit)</button>
          </div>
        </div>`;
      }).join('');


      list.querySelectorAll('[data-sethq]').forEach(btn => { btn.addEventListener('click', () => setHQ(btn.getAttribute('data-sethq'))); });
      list.querySelectorAll('[data-end]').forEach(btn => {
        btn.addEventListener('click', () => endLease(btn.getAttribute('data-end')));
      });
    }

    function endLease(id){
      const arr = state.properties?.holdings || [];
      const idx = arr.findIndex(h=>h.id===id);
      if(idx<0) return;
      const h = arr[idx];
      arr.splice(idx,1);
      if(state.hq && state.hq.propertyId === id){ state.hq.propertyId = null; }
      try{ if(h) h.isHQ = false; }catch(e){}
      addLog(`Ended lease for ${escapeHtml(h.name)}. Deposit forfeited.`);
      scheduleSave();
      renderHoldings();
      renderRentOffers();
      renderHeadquarters();
      updateUI();
    }

    function setHQ(id){
      const h = (state.properties?.holdings||[]).find(x=>x.id===id);
      if(!h){ addLog('Invalid HQ selection.'); return; }
      state.hq = { propertyId: id };
      try{ (state.properties?.holdings||[]).forEach(hh => hh.isHQ = (hh.id === id)); }catch(e){}
      addLog(`Headquarters set to: ${escapeHtml(h.name)} (${escapeHtml(h.loc)}) <span class=\"small muted debug-block\">(state.hq.propertyId = ${id})</span>`);
      scheduleSave();
      renderHoldings();
      renderHeadquarters();
      updateUI();
      setActiveTab('headquarters');
    }

    function processRentDue(){
      const nowMs = state.time?.gameMs || 0;
      const arr = state.properties?.holdings || [];
      for(const h of arr){
        if(nowMs >= h.nextRentDue){
          if(state.money >= h.monthly){
            changeMoney(-h.monthly, 'rent');
            h.paid = (h.paid||0) + h.monthly;
            addLog(`<span class="red">-£${h.monthly}</span> Rent paid for ${escapeHtml(h.name)}.`);
            // schedule next month due
            h.nextRentDue = endOfMonthMsFrom(h.nextRentDue + 24*60*60*1000); // next month end
          } else {
            h.overdue = true;
            addLog(`<span class="red">Rent overdue</span> for ${escapeHtml(h.name)} (need £${h.monthly}).`);
            // still move next due to next month to avoid infinite loop; arrears handling can be added later
            h.nextRentDue = endOfMonthMsFrom(h.nextRentDue + 24*60*60*1000);
          }
          scheduleSave();
        }
      }
    }

    function renderPropertyMarket(){
      renderRentOffers();
      renderHoldings();
    }

    
    
    
    let __hqRecoveredOnce = false;
    function getHQRecord(){
      // 1) If we already have an id, resolve it and return
      let id = state.hq?.propertyId;
      const holdings = (state.properties?.holdings||[]);
      if(id){
        const hold = holdings.find(x=>x.id===id);
        if(hold) return hold;
        try{
          if(state.properties?.daily?.offers){
            const off = state.properties.daily.offers.find(x=>x.id===id);
            if(off) return off;
          }
          if(typeof RENTAL_POOL!=='undefined' && RENTAL_POOL){
            const base = RENTAL_POOL.find(x=>x.id===id);
            if(base) return base;
          }
        }catch(e){}
      }
      // 2) Try to recover from holdings.isHQ or single holding
      const candidate = holdings.find(x=>x.isHQ) || (holdings.length===1 ? holdings[0] : null);
      if(candidate){
        // Set id silently; guard to avoid repeated logs/saves
        state.hq = { propertyId: candidate.id };
        if(!__hqRecoveredOnce){
          __hqRecoveredOnce = true;
          try{ saveGame({silent:true}); }catch(e){}
          try{ addLog(`Recovered HQ: ${escapeHtml(candidate.name)} (${escapeHtml(candidate.loc)})`); }catch(e){}
        }
        return candidate;
      }
      return null;
    }
    
    // Human-friendly blurb for a rental based on attributes
    function describeProperty(p){
      const parts = [];
      const loc = String(p.loc||'').trim();
      if(loc) parts.push(`${loc} area.`);
      // Tier vibe
      const t = Number(p.tier)||0;
      if(t <= 0) parts.push('Basic, no‑frills.');
      else if(t === 1) parts.push('Modest starter space.');
      else if(t >= 2) parts.push('Better condition; suitable as a main base.');
      // Storage
      const s = Math.max(0, Number(p.storage)||0);
      if(s === 0) parts.push('No on‑site storage.');
      else if(s <= 10) parts.push(`Small on‑site storage (${s} items).`);
      else if(s <= 25) parts.push(`Moderate storage (${s} items).`);
      else parts.push(`Large storage (${s} items).`);
      // Garage
      const g = Math.max(0, Number(p.garage)||0);
      if(g === 1) parts.push('Single‑bay garage.');
      else if(g > 1) parts.push(`${g}-bay garage.`);
      return parts.join(' ');
    }

    
    
    // ===== HQ Storage Manager =====
    function getHQCapacity(){
      const h = getHQRecord();
      return h ? Math.max(0, Number(h.storage)||0) : 0;
    }
    
    // Returns the storage items array for the current HQ property.
    function getHQStore(){
      const h = getHQRecord();
      if(!h) return [];
      if(!Array.isArray(h.storeItems)) h.storeItems = [];
      return h.storeItems;
    }
function storageUsed(){ return getHQStore().length; }
    function openStorageManager(){
      const h = getHQRecord();
      if(!h){ addLog('No HQ selected.'); return; }
      const modal = document.getElementById('storageModal'); if(!modal) return;
      modal.classList.remove('hidden');
      renderStorageManager();
    }
    function closeStorageManager(){
      const modal = document.getElementById('storageModal'); if(!modal) return;
      modal.classList.add('hidden');
    }
    function renderStorageManager(){
      const capEl = document.getElementById('storeCap');
      const usedEl= document.getElementById('storeUsed');
      const freeEl= document.getElementById('storeFree');
      const cap = getHQCapacity();
      const used = storageUsed();
      if(capEl) capEl.textContent = cap;
      if(usedEl) usedEl.textContent = used;
      if(freeEl) freeEl.textContent = Math.max(0, cap - used);
      // Inventory list (items that are NOT equipped and not consumables in-use)
      const inv = (state.inventory||[]).filter(it => !it.equipped);
      const invBox = document.getElementById('invForStore');
      if(invBox){
        invBox.innerHTML = inv.length ? inv.map(it => `
          <div class="inv-item-sm">
            <div class="name">${escapeHtml(it.name)}</div>
            <div class="inv-actions">
              <button class="btn sm" data-tostore="${it.id}">Store</button>
            </div>
          </div>`).join('') : '<p class="small muted">No storable items.</p>';
      }
      const sitems = getHQStore();
      const gridS = document.getElementById('gridStorage');
      if(gridS){
        gridS.innerHTML = sitems.length ? sitems.map(it => `
          <div class="store-item">
            <div class="name">${escapeHtml(it.name)}</div>
            <div class="store-actions">
              <button class="btn sm secondary" data-fromstore="${String(it.id)}" data-name="${escapeHtml(it.name)}">Retrieve</button>
            </div>
          </div>`).join('') : '<p class="small muted">Storage is empty.</p>';
      }
      // Wire moves
      if(invBox){
        invBox.querySelectorAll('[data-tostore]').forEach(btn => {
          btn.addEventListener('click', () => moveToStorage(btn.getAttribute('data-tostore')));
        });
      }
      if(gridS){
        gridS.querySelectorAll('[data-fromstore]').forEach(btn => {
          btn.addEventListener('click', () => { const id = btn.getAttribute('data-fromstore'); moveFromStorage(id); });
        });
      }
    }
    function moveToStorage(id){
  const cap = getHQCapacity();
  if(storageUsed() >= cap){ addLog('<span class="red">HQ storage full</span>.'); return; }
  const inv = state.inventory || [];
  const idx = inv.findIndex(x=>x.id===id);
  if(idx<0){ addLog('Item not found.'); return; }
  const it = inv[idx];
  const store = getHQStore();
  // Handle consumables as single-unit moves
  if(it && it.type === 'consumable'){
    // Move exactly one unit of the stack into storage
    const qty = Math.max(1, Number(it.qty)||1);
    if(qty > 1){
      it.qty = qty - 1;
    }else{
      inv.splice(idx,1);
    }
    // Store a lightweight record; retrieval will reconstruct full effect via SHOP_ITEMS
    store.push({ id: it.id, name: it.name, type: 'consumable' });
    pushLog(`Stored 1× ${escapeHtml(it.name)} in HQ.`);
  }else{
    // Equipment/other: move whole item
    inv.splice(idx,1);
    store.push({ id: it.id, name: it.name, slot: it.slot, rarity: it.rarity, type: it.type, invCapAdd: it.invCapAdd, mods: it.mods });
    pushLog(`Stored ${spanItem(it)} in HQ.`);
  }
  scheduleSave();
  renderStorageManager();
  renderInventoryGrid();
  renderHeadquarters();
}
    
    
    function moveFromStorage(id){
  const arr = getHQStore();
  const want = String(id || '').trim();
  let idx = arr.findIndex(x => String(x.id).trim() === want);
  if(idx < 0){
    // Fallback: try by name if unique (helps if ids got sanitized elsewhere)
    const byNameIdx = arr.findIndex(x => String((x.name||'')).trim().toLowerCase() === want.toLowerCase());
    if(byNameIdx >= 0){ idx = byNameIdx; }
  }
  if(idx < 0){
    addLog(`Item not in storage. <span class="small muted debug-block">(id='${escapeHtml(want)}', have=[${arr.map(x=>x.id).join(', ')}])</span>`);
    return;
  }

  const peek = arr[idx];
  // Capacity check BEFORE removing from storage
  // If a consumable will stack, allow even when no free slots (mirrors shop logic)
  let willStack = false;
  if(peek && peek.type === 'consumable'){
    const existing = (state.inventory||[]).find(x => x.type==='consumable' && x.id===peek.id);
    willStack = !!existing;
  }
  if(!willStack && !hasInventorySpace(1)){ addLog('<span class="red">Inventory full</span>.'); return; }

  const [it] = arr.splice(idx,1);

  if(it && it.type === 'consumable'){
    // Rebuild from SHOP_ITEMS by id (or name fallback) and add a single unit
    const shopItem = (SHOP_ITEMS.food.find(x=>x.id===it.id) || SHOP_ITEMS.med.find(x=>x.id===it.id))
                  || (SHOP_ITEMS.food.find(x=>x.name===it.name) || SHOP_ITEMS.med.find(x=>x.name===it.name))
                  || { id: it.id, name: it.name, target: 'hunger', pct: 0 };
    const ok = addConsumableToInventory(shopItem);
    if(!ok){
      // Put it back to storage if something went wrong
      arr.splice(idx, 0, it);
      addLog('<span class="red">Could not retrieve item</span>.');
      return;
    }
    pushLog(`Retrieved 1× ${escapeHtml(shopItem.name)} from HQ.`);
  }else{
    state.inventory = state.inventory || [];
    // Keep original id so it remains the same item
    state.inventory.push({ id: it.id, name: it.name, slot: it.slot, rarity: it.rarity, type: it.type, invCapAdd: it.invCapAdd, mods: it.mods });
    pushLog(`Retrieved ${spanItem(it)} from HQ.`);
  }

  scheduleSave();
  renderStorageManager();
  renderInventoryGrid();
  renderHeadquarters();
}

    function renderHeadquarters(){
      const setText=(id,v)=>{const el=document.getElementById(id); if(el) el.textContent=String(v);};
      setText('hqDbgId', state.hq?.propertyId ?? 'null');
      setText('hqDbgHoldN', (state.properties?.holdings||[]).length);
      setText('hqDbgOffN', (state.properties?.daily?.offers||[]).length);
      try{ setText('hqDbgPoolN', (typeof RENTAL_POOL!=='undefined' && RENTAL_POOL && RENTAL_POOL.length)||0); }catch(e){ setText('hqDbgPoolN','0'); }
      const none = document.getElementById('hqNone');
      const det  = document.getElementById('hqDetails');
      if(!none || !det) return;
      const h = getHQRecord();
      const actions = document.getElementById('hqActions');
      const garageBtn = document.getElementById('btnHQGarage');
      const storeBtn = document.getElementById('btnHQStorage');
      if(!h){ none.classList.remove('hidden'); det.classList.add('hidden'); if(actions) actions.classList.add('hidden'); return; }
      if(actions) actions.classList.remove('hidden'); if(garageBtn) garageBtn.disabled = !(Number(h.garage)>0); if(storeBtn) storeBtn.disabled = false;
      none.classList.add('hidden'); det.classList.remove('hidden');
      const set = (id, v) => { const el = document.getElementById(id); if(el) el.textContent = String(v); };
      set('hqName', h.name); set('hqLoc', h.loc);
      set('hqStorage', h.storage); set('hqGarage', h.garage); set('hqMonthly', '£'+h.monthly);
      try{ const used = storageUsed(); set('hqStorageUsed', used); set('hqStorageCap', h.storage); }catch(e){}
    }
    function advanceGameTime(dtMs){
      // advance by scaled time
      const advance = Math.max(0, Math.floor(dtMs * GAME_TIME_SCALE));
      state.time.gameMs = Math.max(0, (state.time.gameMs||0) + advance);
    }function formatDuration(ms){
      const s = Math.floor(ms/1000);
      const m = Math.floor(s/60);
      const h = Math.floor(m/60);
      const mm = m % 60, ss = s % 60;
      if(h > 0) return `${h}h ${mm}m`;
      if(m > 0) return `${m}m ${ss}s`;
      return `${s}s`;
    }




    function formatGameClock(ms){
      const epoch = (state.time && state.time.epochMs) ? state.time.epochMs : 0;
      const DAY = 24*60*60*1000;
      const dayCount = Math.floor(ms / DAY) + 1; // Day 1 starts at 0ms
      const date = new Date(epoch + ms);
      const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const dw = days[date.getDay()];
      const d  = String(date.getDate()).padStart(2,'0');
      const mon= months[date.getMonth()];
      const HH = String(date.getHours()).padStart(2,'0');
      const MM = String(date.getMinutes()).padStart(2,'0');
      return `Day ${dayCount} · ${dw} ${d} ${mon} — ${HH}:${MM}`;
    }



    
    // === RECRUITMENT SYSTEM ==================================================
    const RECRUIT_FIRST_NAMES = ["Tommy","Riley","Casey","Alex","Morgan","Jordan","Taylor","Sam","Evan","Jamie","Skye","Dee","Kai","Remy","Ash","Rowan","Reese","Charlie","Avery"];
    const RECRUIT_LAST_NAMES  = ["Cole","Rivers","Marlow","Sloan","Carter","Fox","Knight","Hayes","Chen","Singh","Diaz","Patel","Owen","Stone","Hart","Blake","West","Quinn","Lane","King"];
    const RECRUIT_ALIASES     = ["Quickfingers","Shade","Ghost","Pockets","Whisper","Locks","Needle","Slick","Nix","Rook","Switch","Ace","Zero","Blink","Patch","Vex"];
    const RECRUIT_BIO_FRAG    = [
      "Rumoured to have worked the markets since they were twelve.",
      "Keeps a low profile; prefers busy streets and tight crowds.",
      "Swears by gloves and a steady rhythm.",
      "Claims they can spot a mark from twenty paces.",
      "Quiet, patient, and methodical — not much of a talker.",
      "Was once caught, never the same mistake twice.",
      "Carries a lucky coin; refuses to work without it."
    ];
    function seededRand(seed){ let s = seed>>>0; return ()=>{ s = (1664525*s + 1013904223)>>>0; return s/4294967296; }; }
    function ensureRecruitmentDaily(){
      if(!state.recruitment) state.recruitment = { daily:{ dayKey:'', candidates:[] }, crew: [] };
      const key = dateKeyFromGameTime();
      if((state.recruitment.daily.dayKey||'') !== key){
        const seed = key.split('-').reduce((acc,s)=> (acc*131 + parseInt(s,10))|0, 17)>>>0;
        const rnd = seededRand(seed);
        const f = RECRUIT_FIRST_NAMES.slice(); const l = RECRUIT_LAST_NAMES.slice(); const a = RECRUIT_ALIASES.slice();
        const c = 4 + Math.floor(seed % 3); // 4..6
        const picks = [];
        for(let i=0;i<c;i++){
          const fn = f[Math.floor(rnd()*f.length)] || "Alex";
          const ln = l[Math.floor(rnd()*l.length)] || "Quinn";
          const al = a[Math.floor(rnd()*a.length)] || "Shade";
          const bio = RECRUIT_BIO_FRAG[Math.floor(rnd()*RECRUIT_BIO_FRAG.length)] || "";
          const id = `rec-${key}-${i}`;
          picks.push({ id, name: fn+" "+ln, alias: al, bio, cut: 0.5, hireCost: 500 });
        }
        state.recruitment.daily.dayKey = key;
        state.recruitment.daily.candidates = picks;
        pushLog({ html: `<span class="muted">Recruitment refreshed (${c} candidates).</span>` });
        scheduleSave();
      }
    }
    function hireCrew(id){
      ensureRecruitmentDaily();
      const d = state.recruitment.daily;
      const idx = (d.candidates||[]).findIndex(c=>c.id===id);
      if(idx === -1) return;
      const cand = d.candidates[idx];
  // Require an active HQ to hire
  try{
    const hq = getHQRecord && getHQRecord();
    if(!hq){
      pushLog('<span class="red">Hire requires an HQ</span>: set a property as HQ in Property → Holdings.');
      return;
    }
  }catch(e){
    if(!state.hq || !state.hq.propertyId){
      pushLog('<span class="red">Hire requires an HQ</span>: set a property as HQ in Property → Holdings.');
      return;
    }
  }

      if((state.recruitment.crew||[]).length >= 3){ pushLog('<span class="muted">Crew is at capacity.</span>'); return; }
      if(state.money < cand.hireCost){ pushLog('<span class="muted">Not enough cash to hire.</span>'); return; }
      changeMoney(-cand.hireCost, 'crew-hire');
      const member = { id: cand.id, name: cand.name, alias: cand.alias, bio: cand.bio, cut: 0.5, hiredAt: (state.time?.gameMs||0), nextReadyAt: 0, role: "pickpocket", auto: false };
      state.recruitment.crew = state.recruitment.crew || [];
      state.recruitment.crew.push(member);
      d.candidates.splice(idx,1);
      pushLog({ html: `Hired <strong>${escapeHtml(member.name)}</strong> <span class="muted">"${escapeHtml(member.alias)}"</span> for £${cand.hireCost}.` });
      scheduleSave(); renderRecruitmentView(); renderCrewLists(); updateUI();
    }
    function crewSuccessChance(){ return 0.50; } // fixed base per spec
    function crewCooling(member){
      return member.nextReadyAt && (Date.now() < member.nextReadyAt);
    }
    function doCrewPickpocket(memberId, origin='recruitment'){
      const crew = state.recruitment?.crew || [];
      const m = crew.find(x=>x.id===memberId);
      if(!m) return;
      if(crewCooling(m)) return;
      m.nextReadyAt = Date.now() + COOLDOWN_MS;
      // Resolve
      const cutRate = (m.cut ?? 0.5);
      const roll = Math.random();
      if(roll < crewSuccessChance()){
        const cash = randInt(PICK_MIN_CASH, PICK_MAX_CASH);
        const cut = Math.floor(cash * cutRate);
        const you = Math.max(0, cash - cut);
        changeMoney(you, 'crew-pickpocket');
        pushLog({ html: `${origin==='auto' ? '<span class=\'muted\'>[Auto]</span> ' : ''}<span class=\"good\">Success</span>: ${escapeHtml(m.alias)} lifted ${spanMoney(cash)} → cut ${spanMoney(cut)}, you received ${spanMoney(you)}.` });
      }else{
        pushLog({ html: `${origin==='auto' ? '<span class=\'muted\'>[Auto]</span> ' : ''}<span class=\"bad\">Failed</span>: ${escapeHtml(m.alias)} returned empty-handed.` });
      }
      // No heat impact for crew (per spec)
      scheduleSave(); updateUI();
    }
    function renderRecruitmentView(){
      ensureRecruitmentDaily();
      const dayEl = document.getElementById('recruitDayKey'); if(dayEl) dayEl.textContent = state.recruitment.daily.dayKey || '—';
      const nextEl = document.getElementById('recruitNextRefresh'); if(nextEl){
        const d = new Date((state.time?.epochMs||0) + (state.time?.gameMs||0));
        const n = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1, 0,0,0,0);
        nextEl.textContent = n.toDateString();
      }
      const wrap = document.getElementById('recruitCandidates');
      if(wrap){
        const arr = state.recruitment.daily.candidates||[];
        if(arr.length===0){ wrap.innerHTML = '<div class="card"><p class="muted">No candidates right now. Check back after midnight.</p></div>'; }
        else{
          wrap.innerHTML = arr.map(c => {
            const id = c.id;
            return `<div class="card">
              <div class="row" style="justify-content:space-between;align-items:flex-start;gap:12px">
                <div>
                  <div class="prop-name">${escapeHtml(c.name)} <span class="muted small">"${escapeHtml(c.alias)}"</span></div>
                  <div class="small muted" style="margin-top:4px">${escapeHtml(c.bio)}</div>
                  <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
                    <div class="pill">Hire: <strong>£${c.hireCost}</strong></div>
                    <div class="pill">Cut: <strong>${Math.round((c.cut||0.5)*100)}%</strong></div>
                  </div>
                </div>
                <div>
                  <button class="btn" data-hire="${id}">Hire</button>
                </div>
              </div>
              <div class="small codepath debug-block">ID: <strong>${escapeHtml(c.id)}</strong></div>
            </div>`;
          }).join('');
          // bind
          wrap.querySelectorAll('[data-hire]').forEach(btn => {
            if(!btn.dataset.bound){
              btn.addEventListener('click', ()=> hireCrew(btn.getAttribute('data-hire')));
              btn.dataset.bound = '1';
            }
          });
        }
      }
      // debug summary
      const dK = document.getElementById('recruitDbgKey'); if(dK) dK.textContent = state.recruitment.daily.dayKey||'—';
      const dN = document.getElementById('recruitDbgN'); if(dN) dN.textContent = String((state.recruitment.daily.candidates||[]).length);
      const cN = document.getElementById('recruitDbgCrewN'); if(cN) cN.textContent = String((state.recruitment.crew||[]).length);
      renderCrewLists(); // update both crew lists
    }
    function formatCooldown(ms){
      const s = Math.max(0, Math.ceil(ms/1000));
      if(s>=60){ const m = Math.floor(s/60); const ss = s%60; return m+'m '+ss+'s'; }
      return s+'s';
    }
    function renderCrewLists(){
  const targets = [
    { id: 'crewList', origin: 'recruitment' }, // Recruitment tab (read-only)
    { id: 'hqCrewList', origin: 'hq' }         // HQ panel (actions)
  ];
  const now = Date.now();
  const crew = state.recruitment?.crew || [];

  function cardHtml(m, origin){
    const cooling = crewCooling(m);
    const left = cooling ? Math.max(0, m.nextReadyAt - now) : 0;
    const status = cooling ? `Cooldown: ${formatCooldown(left)}` : 'Ready';
    const actionHtml = (origin === 'hq')
      ? `<div class="row" style="gap:8px;flex-wrap:wrap"><button class="btn" data-crew-pick="${escapeHtml(m.id)}" ${cooling ? 'disabled':''}>Send: Pickpocket</button><button class="btn secondary" data-crew-auto="${escapeHtml(m.id)}" aria-pressed="${m.auto?'true':'false'}">${m.auto? 'Auto: ON' : 'Auto: OFF'}</button></div>`
      : `<span class="small muted">Send jobs from <strong>Headquarters → Crew Jobs</strong></span>`;
    return `<div class="card crew-card" data-crew-id="${escapeHtml(m.id)}">
      <div class="row" style="justify-content:space-between;align-items:flex-start;gap:12px">
        <div>
          <div class="prop-name">${escapeHtml(m.name)} <span class="muted small">"${escapeHtml(m.alias)}"</span></div>
          <div class="small muted" style="margin-top:4px">${escapeHtml(m.bio)}</div>
          <div class="row" style="gap:8px;flex-wrap:wrap;margin-top:8px">
            <div class="pill">Cut: <strong>${Math.round(((m.cut??0.5)*100))}%</strong></div>
            <div class="pill">Status: <strong class="crew-status">${status}</strong></div><div class="pill">Auto: <strong class="crew-auto">${m.auto?'ON':'OFF'}</strong></div><div class="pill"><span class="muted">Offline progress</span>: <strong>Not supported</strong></div>
          </div>
        </div>
        <div>${actionHtml}</div>
      </div>
      <div class="small codepath debug-block">nextReadyAt: <strong class="crew-next">${m.nextReadyAt||0}</strong> • origin=<strong>${origin}</strong></div>
    </div>`;
  }

  for(const target of targets){
    const el = document.getElementById(target.id);
    if(!el) continue;
    if(crew.length===0){
      el.innerHTML = '<div class="card"><p class="muted">No crew hired yet.</p></div>';
    }else{
      el.innerHTML = crew.map(m => cardHtml(m, target.origin)).join('');
    }
    if(target.origin === 'hq'){
      el.querySelectorAll('[data-crew-pick]').forEach(btn => {
        if(!btn.dataset.bound){
          btn.addEventListener('click', ()=> doCrewPickpocket(btn.getAttribute('data-crew-pick'), target.origin));
          btn.dataset.bound='1';
        }
      });
      // auto toggle
      el.querySelectorAll('[data-crew-auto]').forEach(btn => {
        if(!btn.dataset.bound){
          btn.addEventListener('click', ()=> toggleCrewAuto(btn.getAttribute('data-crew-auto')));
          btn.dataset.bound='1';
        }
      });
    }
  }
  // update signature used by refreshCrewCooldowns
  try{ window.__prevCrewSigIds = (state.recruitment?.crew||[]).map(c=>c.id).join('|'); }catch(e){}
}


// Lightweight per-tick updater for crew UI to avoid flicker
function refreshCrewCooldowns(){
  const crew = state.recruitment?.crew || [];
  const sig = crew.map(c=>c.id).join('|');
  if(typeof window.__prevCrewSigIds === 'string' && window.__prevCrewSigIds !== sig){
    // Membership changed → re-render fully
    renderCrewLists();
    return;
  }
  const now = Date.now();
  const updateContainer = (id, origin) => {
    const root = document.getElementById(id);
    if(!root) return;
    root.querySelectorAll('.crew-card').forEach(card => {
      const cid = card.getAttribute('data-crew-id');
      const m = crew.find(x => x.id === cid);
      if(!m) return; // skip
      const cooling = crewCooling(m);
      const left = cooling ? Math.max(0, m.nextReadyAt - now) : 0;
      const statusTxt = cooling ? `Cooldown: ${formatCooldown(left)}` : 'Ready';
      const statusEl = card.querySelector('.crew-status');
      if(statusEl && statusEl.textContent !== statusTxt){ statusEl.textContent = statusTxt; }
            const autoEl = card.querySelector('.crew-auto');
      if(autoEl){ autoEl.textContent = (m.auto?'ON':'OFF'); }
      const nextEl = card.querySelector('.crew-next');
      if(nextEl){ nextEl.textContent = String(m.nextReadyAt||0); }
      if(origin === 'hq'){
        const btn = card.querySelector('[data-crew-pick]');
        const autoBtn = card.querySelector('[data-crew-auto]');
        if(autoBtn){
          const label = (m.auto? 'Auto: ON' : 'Auto: OFF');
          if(autoBtn.textContent !== label){ autoBtn.textContent = label; }
          const pressed = (m.auto? 'true' : 'false');
          if(autoBtn.getAttribute('aria-pressed') !== pressed){ autoBtn.setAttribute('aria-pressed', pressed); }
        }
        const autoEl = card.querySelector('.crew-auto');
        if(autoEl){ const txt = m.auto? 'ON':'OFF'; if(autoEl.textContent!==txt){ autoEl.textContent = txt; } }
        if(btn){
          const should = cooling;
          if(!!btn.disabled !== !!should){ btn.disabled = should; }
        }
      }
    });
  };
  updateContainer('crewList', 'recruitment');
  updateContainer('hqCrewList', 'hq');
}


function renderCrewActionsPanel(){
      const panel = document.getElementById('hqCrewPanel');
      if(!panel) return;
      const hasCrew = (state.recruitment?.crew||[]).length > 0;
      panel.classList.toggle('hidden', !hasCrew);
      panel.setAttribute('aria-hidden', String(!hasCrew));
      renderCrewLists();
    }

// Toggle auto-run for a crew member
function toggleCrewAuto(memberId){
  const crew = state.recruitment?.crew || [];
  const m = crew.find(x=>x.id===memberId);
  if(!m) return;
  m.auto = !m.auto;
  if(!m.role){ m.role = 'pickpocket'; }
  pushLog({ html: `Crew <strong>${escapeHtml(m.alias)}</strong>: auto-run ${m.auto ? '<span class="good">enabled</span>' : '<span class="muted">disabled</span>'}.` });
  scheduleSave(); updateUI();
}

// Process auto jobs each tick
function processCrewAutoJobs(){
  try{
    const crew = state.recruitment?.crew || [];
    const hqOk = (function(){ try{ return !!(getHQRecord && getHQRecord()); }catch(e){ return !!(state.hq && state.hq.propertyId); } })();
    if(!hqOk) return;
    for(const m of crew){
      if(!m || !m.auto) continue;
      if(crewCooling(m)) continue;
      const role = (m.role || 'pickpocket');
      if(role === 'pick' || role === 'pickpocket'){
        doCrewPickpocket(m.id, 'auto');
      }
      // Future roles go here
    }
  }catch(e){}
}

function updateUI(){
      document.getElementById("balanceValue").textContent = String(state.money);

      const heatEl = document.getElementById("heatValue");
      heatEl.textContent = String(state.heat);
      heatEl.classList.toggle('heat-hi', state.heat >= 70);
      heatEl.classList.toggle('heat-mid', state.heat >= 35 && state.heat < 70);

      const ch = successChance();
      document.getElementById("chanceValue").textContent = Math.round(ch * 100);
      const base = BASE_SUCCESS;
      const bonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
      const penalty = state.heat * HEAT_PENALTY_PER_HEAT;
      const detEl = document.getElementById("chanceDetail");
      if(detEl){ detEl.textContent = `base ${Math.round(base*100)}% + sleight ${Math.round(bonus*100)}% − heat ${Math.round(penalty*100)}% (clamped 5–90%)`; }

      const logEmpty = document.getElementById("logEmpty");
      const logList  = document.getElementById("logList");
      if(state.log.length === 0){
        logEmpty.classList.remove("hidden");
        logList.classList.add("hidden");
        logList.innerHTML = "";

// --- Search Bags chance + details
(function(){
  const sch = successChanceSearch();
  const sVal = document.getElementById("searchChanceValue");
  if(sVal){ sVal.textContent = Math.round(sch * 100); }
  const sDet = document.getElementById("searchChanceDetail");
  if(sDet){
    const sBase = SEARCH_BASE_SUCCESS;
    const sBonus = getLevel("Sleight of Hand") * SLEIGHT_BONUS_PER_LEVEL;
    const sPenalty = state.heat * HEAT_PENALTY_PER_HEAT;
    sDet.textContent = `base ${Math.round(sBase*100)}% + sleight ${Math.round(sBonus*100)}% − heat ${Math.round(sPenalty*100)}% (clamped 5–90%)`;
  }
})();

// --- One-job-at-a-time gating & unlock note
(function(){
  const pickBtn = document.getElementById("pickBtn");
  const searchBtn = document.getElementById("searchBtn");
  const searchLockedNote = document.getElementById("searchLockedNote");
  const unlocked = canUseSearchBags();
  const cooling = isCooling();
  if(pickBtn){ pickBtn.disabled = cooling; }
  if(searchBtn){ searchBtn.disabled = cooling || !unlocked; }
  if(searchLockedNote){ searchLockedNote.style.display = unlocked ? 'none' : 'inline'; }
})();

// --- Separate progress bars (shared cooldown)
(function(){
  const bar = document.getElementById("progressBar");
  const sBar = document.getElementById("searchProgressBar");
  if(!bar || !sBar){ return; }
  if(!pickEndsAt){
    bar.style.width = "0%";
    sBar.style.width = "0%";
    return;
  }
  const remaining = timeLeft();
  const pct = Math.min(1, Math.max(0, (COOLDOWN_MS - remaining) / COOLDOWN_MS));
  if(currentJob === 'search'){
    sBar.style.width = (pct * 100).toFixed(2) + "%";
    bar.style.width = "0%";
  }else{
    bar.style.width = (pct * 100).toFixed(2) + "%";
    sBar.style.width = "0%";
  }
})();

      }else{
        logEmpty.classList.add("hidden");
        logList.classList.remove("hidden");
        logList.innerHTML = (state.log||[]).map(item => {
          if (typeof item === "string"){
            const ts = fmtTime(new Date().toISOString());
            return `<li class="li"><span class="ts">[${ts}]</span>${escapeHtml(item)}</li>`;
          } else if (item && typeof item === "object"){
            const ts = fmtTime(item.ts || new Date().toISOString());
            const body = item.html ? item.html : escapeHtml(String(item.text ?? ""));
            return `<li class="li"><span class="ts">[${ts}]</span>${body}</li>`;
          }
          return "";
        }).join("");
      }
      // keep chance debug displays fresh each frame
      try{ updateChanceDebug(); }catch(e){}

      const hasStats = Object.keys(state.stats).length > 0;
      const statsEmptyEl = document.getElementById("statsEmpty");
      if(statsEmptyEl){ statsEmptyEl.classList.toggle("hidden", hasStats); }
      const statsList = document.getElementById("statsList");
      renderEquipmentUI();
      renderBuffSummary();
      const aliasText = document.getElementById('aliasText'); if(aliasText){ aliasText.textContent = state.profile.alias ? state.profile.alias : '(unset)'; }
      const hb = document.getElementById('healthBar'); if(hb){ hb.style.width = state.vitals.health + '%'; }
      const ht = document.getElementById('healthText'); if(ht){ ht.textContent = Number(state.vitals.health).toFixed(0) + '%'; }
      const hp = document.getElementById('healthPct'); if(hp){ hp.textContent = Number(state.vitals.health).toFixed(0) + '%'; }
      const gb = document.getElementById('hungerBar'); if(gb){ gb.style.width = state.vitals.hunger + '%'; }
      const gt = document.getElementById('hungerText'); if(gt){ gt.textContent = Number(state.vitals.hunger).toFixed(0) + '%'; }
      const gp = document.getElementById('hungerPct'); if(gp){ gp.textContent = Number(state.vitals.hunger).toFixed(0) + '%'; }
      const ct = document.getElementById('clockText'); if(ct){ ct.textContent = formatGameClock(state.time.gameMs||0); }
      if(statsList){
        statsList.classList.toggle("hidden", !hasStats);
        if(hasStats){
          statsList.innerHTML = Object.entries(state.stats)
            .map(([name, s]) => renderStatRow(name, s))
            .join("");
        }else{
          statsList.innerHTML = "";
        }
      }

      renderInventoryGrid();

      const pickBtn = document.getElementById("pickBtn");
      if(isCooling()){
        pickBtn.disabled = true;
        pickBtn.textContent = `Cooling… ${Math.ceil(timeLeft()/1000)}s`;
      }else{
        pickBtn.disabled = false;
        pickBtn.textContent = "Attempt Pickpocket";
      }

      updateAutoSaveUI();
      // Analytics render
      const m = state.metrics;
      const eEl = document.getElementById("metricEarned");
      if(eEl){
        const earned = m.money.earned|0, spent = m.money.spent|0, net = Math.max(0, earned - spent);
        eEl.textContent = "£" + earned;
        const sEl = document.getElementById("metricSpent"); if(sEl) sEl.textContent = "£" + spent;
        const nEl = document.getElementById("metricNet"); if(nEl){ nEl.textContent = "£" + net; nEl.style.color = (net >= 0 ? "var(--good)" : "var(--danger)"); }
        const eSrc = document.getElementById("metricEarnedSrc"); if(eSrc) eSrc.textContent = String(earned);
        const sSrc2 = document.getElementById("metricSpentSrc"); if(sSrc2) sSrc2.textContent = String(spent);
        // Heat
        const hc = document.getElementById("metricHeatCurrent"); if(hc) hc.textContent = String(state.heat);
        const hp = document.getElementById("metricHeatPeak"); if(hp) hp.textContent = String(m.heat.peak|0);
        const hg = document.getElementById("metricHeatGained"); if(hg) hg.textContent = String(m.heat.gained|0);
        const hco = document.getElementById("metricHeatCooled"); if(hco) hco.textContent = String(m.heat.cooled|0);
        const ha = document.getElementById("metricHeatAvg"); if(ha) ha.textContent = String(m.heat.avg||0);
        const hSrcP = document.getElementById("metricHeatPeakSrc"); if(hSrcP) hSrcP.textContent = String(m.heat.peak|0);
        const hSrcG = document.getElementById("metricHeatGainedSrc"); if(hSrcG) hSrcG.textContent = String(m.heat.gained|0);
        const hSrcC = document.getElementById("metricHeatCooledSrc"); if(hSrcC) hSrcC.textContent = String(m.heat.cooled|0);
        const hSrcA = document.getElementById("metricHeatAvgSrc"); if(hSrcA) hSrcA.textContent = String(m.heat.avg||0);
        const hb = document.getElementById("metricHeatBar"); if(hb){ hb.style.width = Math.min(100, (state.heat/HEAT_MAX)*100).toFixed(2) + "%"; }
      }

    }

    function tick(){
  // Clear active job when cooldown ends
  if (pickEndsAt && timeLeft() <= 0){
    pickEndsAt = null;
    currentJob = null;
  }

  
  // Daily refresh for recruitment at in-game midnight
  (function(){
    try{
      const prev = window.__prevRecruitDayKey || "";
      const cur = dateKeyFromGameTime();
      if(prev !== cur){
        window.__prevRecruitDayKey = cur;
        ensureRecruitmentDaily();
        const recVisible = !document.getElementById('view-recruitment').classList.contains('hidden');
        if(recVisible){ renderRecruitmentView(); }
      }
    }catch(e){}
  })();
// Update both progress bars, but only animate the one for the active job
  const bar = document.getElementById("progressBar");          // pickpocket
  const sBar = document.getElementById("searchProgressBar");   // search bags
  if (bar && sBar){
    if (!pickEndsAt){
      bar.style.width = "0%";
      sBar.style.width = "0%";
    } else {
      const remaining = timeLeft();
      const pct = Math.min(1, Math.max(0, (COOLDOWN_MS - remaining) / COOLDOWN_MS));
      if (currentJob === 'search'){
        sBar.style.width = (pct * 100).toFixed(2) + "%";
        bar.style.width = "0%";
      } else {
        bar.style.width = (pct * 100).toFixed(2) + "%";
        sBar.style.width = "0%";
      }
    }
  // Ensure buttons reflect current state
  try{ syncActionButtons(); }catch(e){}

  }

  decayHeat();
  // Hunger decay
  decayHunger(TICK_MS/1000);
  advanceGameTime(TICK_MS);
  ensureDailyOffers();
  processRandomEncounter(TICK_MS);
  maybeTriggerPoliceEvent();

  
  refreshCrewCooldowns(); // crew cooldown UI
  processCrewAutoJobs(); // auto-run crew tasks
// Metrics sampling
  if(!state.metrics.heat){ state.metrics.heat = { _samples:0, _sum:0, avg:0 }; }
  state.metrics.heat._samples += 1;
  state.metrics.heat._sum += state.heat;
  state.metrics.heat.avg = Math.round((state.metrics.heat._sum / Math.max(1, state.metrics.heat._samples)) * 10) / 10;

  // Sampling (1s)
  const now = Date.now();
  if(!lastSampleAt || now - lastSampleAt >= SAMPLE_EVERY_MS){
    pushSample();
    lastSampleAt = now;
    chartNeedsDraw = true;
  }

  updateUI();
  // draw live chart if analytics visible
  const analyticsVisible = !document.getElementById('view-analytics').classList.contains('hidden');
  if(analyticsVisible && chartNeedsDraw){ drawLiveChart(); chartNeedsDraw = false; }
}

    function resetAll(forceRefresh){
      state.money = 0;
      state.heat = 0;
      state.stats = {};
      ensureDefaultStats();
      state.inventory = [];
      state.log = [];
      state.inventory = [];
      state.equipment = { head:null, chest:null, hands:null, legs:null, feet:null, accessory:null };
      state.profile = { alias: "" };
      state.vitals = { health: 100, hunger: 100 };
      state.storage = { items: [] };
      state.properties = { holdings: [], daily:{ dayKey:'', offers: [] } };
      
      state.recruitment = { daily: { dayKey: "", candidates: [] }, crew: [] }; // wipe crew for new game
state.hq = { propertyId: null };
      state.lifetime = { all: [] };
      if(!state.inventory.length && getHQStore().length===0){ seedFakeItems(); state.lifetime.seededOnce = true; try{ scheduleSave(); }catch(e){} }
      reconcileEquipment();
      
    // Clear battle log history
    try{ if(state.territory){ state.territory.logHistory = []; } }catch(e){}
    try{ const el=document.getElementById('tbLog'); if(el) el.innerHTML=''; const empty=document.getElementById('logEmpty'); if(empty) empty.classList.remove('hidden'); }catch(e){}
// Reset mail inbox and re-seed tutorial/test messages
      try{
        const keepCRT = (state.mail && typeof state.mail.crt === 'boolean') ? state.mail.crt : false;
        state.mail = { inbox: [], unread: 0, nextId: 1, seededWelcome: false, crt: keepCRT };
        if(typeof window.addMail === 'function'){
          const body = [
            "Welcome to CrimIdle! (Fictional game prototype.)",
            "",
            "How it works:",
            "• Activities: try Pickpocket (cooldowns & chances apply).",
            "• XP & Levels: successes (and tries) raise skills for better odds.",
            "• Heat: goes up on actions; decays over time; high heat hurts success.",
            "• Inventory: equip items to boost stats; store extras at your HQ.",
            "• Property/HQ: claim a base and manage storage.",
            "• Shop: grab snacks to manage vitals (placeholders).",
            "• Autosave: your progress saves as you play.",
            "",
            "Tip: Watch the Analytics tab for Balance/Heat trends.",
            "",
            "— Control, ‘CI’ Systems"
          ].join("\n");
          window.addMail({ from: "CI Systems", subject: "Welcome to CrimIdle — Quick Start", body });
          const body2 = [
            "Inbox Demo — Multiple Messages",
            "",
            "This is a second test email so you can see how multiple emails look.",
            "• Newest messages appear at the top",
            "• Click any message on the left to read it on the right",
            "",
            "Have fun testing!",
            "",
            "— CI Systems"
          ].join("\n");
          window.addMail({ from: "CI Systems", subject: "Inbox Demo — Multiple Messages", body: body2 });
          state.mail.seededWelcome = true;
        }
      }catch(e){}
    
      state.metrics = { money: { earned: 0, spent: 0 }, heat: { peak: 0, gained: 0, cooled: 0, avg: 0, _samples: 0, _sum: 0 } };
      state.history = { session: [] };
      state.lifetime = { all: [] };
      state.time = { gameMs: 0, startedAt: Date.now(), epochMs: (function(){ const n=Date.now(); const DAY=24*60*60*1000; return n - (n % DAY); })() };
      state.properties = { holdings: [], daily:{ dayKey:'', offers: [] } };
      pickEndsAt = null;
      lastHeatDecayAt = Date.now();
      window.clearSave();
      updateUI();
    
      // If this was a "fresh reset" triggered by the Reset button,
      // perform a best-effort hard refresh to mimic Ctrl+F5.
      if (forceRefresh) {
        try { hardReload(); } catch(e) {
          try { location.reload(); } catch(_) {}
        }
        return;
      }
}

// Best-effort hard refresh: clear SW caches, unregister service workers,
// then reload with a cache-busting query param to avoid cached assets.
function hardReload(){
  function doReload(){
    try{
      var url = new URL(window.location.href);
      url.searchParams.set('_fresh', String(Date.now()));
      // Use replace() to avoid back/forward cache keeping the old page
      window.location.replace(url.toString());
    }catch(e){
      try{ window.location.reload(); }catch(_) {}
    }
  }
  var tasks = [];
  try{
    if ('serviceWorker' in navigator && navigator.serviceWorker.getRegistrations){
      tasks.push(navigator.serviceWorker.getRegistrations().then(function(regs){
        return Promise.all(regs.map(function(r){ try{ return r.unregister(); }catch(e){ return false; } }));
      }));
    }
  }catch(e){}
  try{
    if (window.caches && caches.keys){
      tasks.push(caches.keys().then(function(keys){
        return Promise.all(keys.map(function(k){ try{ return caches.delete(k); }catch(e){ return false; } }));
      }));
    }
  }catch(e){}
  // Even if something fails, still proceed to reload.
  Promise.allSettled(tasks).then(doReload, doReload);
}



    
    // Category state
    let activeCategory = 'petty';
    function applyCategory(){
      const petty = document.getElementById("cat-petty");
      const small = document.getElementById("cat-small");
      petty.classList.toggle("hidden", activeCategory !== 'petty');
      small.classList.toggle("hidden", activeCategory !== 'small');
      // Toggle button states
      const bPetty = document.getElementById("btnCatPetty");
      const bSmall = document.getElementById("btnCatSmall");
      if(bPetty) bPetty.setAttribute("aria-pressed", String(activeCategory === 'petty'));
      if(bSmall) bSmall.setAttribute("aria-pressed", String(activeCategory === 'small'));
      // Ensure main tab is Activities when a category is switched
      (function(){ const viewAct=document.getElementById("view-activities"); if(viewAct && viewAct.classList.contains("hidden")) setActiveTab("activities"); })();
// Show/hide job cards by data-category (petty/small)
try {
  document.querySelectorAll('.card[data-category]').forEach(function(card){
    card.classList.toggle('hidden', card.dataset.category !== activeCategory);
  });
} catch(e) { /* no-op */ }
}
    // === Property Market: category toggles ==================================
    let activePropertyCategory = 'rent';
    function applyPropertyCategory(){
      const rent = document.getElementById("prop-rent");
      const buy  = document.getElementById("prop-buy");
      const hold = document.getElementById("prop-holdings");
      if(rent) rent.classList.toggle("hidden", activePropertyCategory !== 'rent');
      if(buy)  buy .classList.toggle("hidden", activePropertyCategory !== 'buy');
      if(hold) hold.classList.toggle("hidden", activePropertyCategory !== 'holdings');
      const bRent = document.getElementById("btnPropRent");
      const bBuy  = document.getElementById("btnPropBuy");
      const bHold = document.getElementById("btnPropHoldings");
      if(bRent) bRent.setAttribute("aria-pressed", String(activePropertyCategory === 'rent'));
      if(bBuy)  bBuy .setAttribute("aria-pressed", String(activePropertyCategory === 'buy'));
      if(bHold) bHold.setAttribute("aria-pressed", String(activePropertyCategory === 'holdings'));
      // Refresh only the active property panel (no tab re-entry)
      if(activePropertyCategory === 'rent'){ renderRentOffers(); }
      else if(activePropertyCategory === 'holdings'){ renderHoldings(); }

}
    function setPropertyCategory(cat){
      if(cat === 'buy') activePropertyCategory = 'buy';
      else if(cat === 'holdings') activePropertyCategory = 'holdings';
      else activePropertyCategory = 'rent';
      applyPropertyCategory();
    }

    function setCategory(cat){
      activeCategory = (cat === 'small') ? 'small' : 'petty';
      applyCategory();
    }

    
    // Micro-interaction: button ripple effect
    function attachRipples(){
      document.addEventListener('click', (e) => {
        const btn = e.target.closest && e.target.closest('.btn');
        if(!btn) return;
        const rect = btn.getBoundingClientRect();
        const d = Math.max(rect.width, rect.height);
        const ripple = document.createElement('span');
        ripple.className = 'ripple';
        ripple.style.width = ripple.style.height = d + 'px';
        ripple.style.left = (e.clientX - rect.left - d/2) + 'px';
        ripple.style.top  = (e.clientY - rect.top  - d/2) + 'px';
        btn.appendChild(ripple);
        setTimeout(() => ripple.remove(), 600);
      }, { passive: true });
    }
document.addEventListener("DOMContentLoaded", () => {
      // Click handlers

      // Debug toggle button
      const dbgBtn = document.getElementById('debugBtn');
      if(dbgBtn && !dbgBtn.dataset.bound){ dbgBtn.addEventListener('click', toggleDebug); dbgBtn.dataset.bound='1'; }
      document.getElementById("pickBtn").addEventListener("click", doPickpocket);
            const sb=document.getElementById("searchBtn"); if(sb){ sb.addEventListener("click", doSearchBags); }
(function(){ const rbtn=document.getElementById("resetBtn"); if(rbtn && !rbtn.dataset.bound){ rbtn.addEventListener("click", ()=>resetAll(true)); rbtn.dataset.bound="1"; } })();
      const s10=document.getElementById('sim10mBtn'); if(s10){ s10.addEventListener('click', ()=>simulateOffline(10*60*1000)); }
      const s1h=document.getElementById('sim1hBtn'); if(s1h){ s1h.addEventListener('click', ()=>simulateOffline(60*60*1000)); }
      const aliasBtn = document.getElementById('aliasEditBtn'); if(aliasBtn){ aliasBtn.addEventListener('click', openAliasDialog); }
      const aliasDlg = document.getElementById('aliasDialog');
      const aliasSave = document.getElementById('aliasSaveBtn');
      const aliasInput = document.getElementById('aliasInput');
      const aliasErr = document.getElementById('aliasError');
      if(aliasSave && aliasDlg && aliasInput){
        aliasSave.addEventListener('click', (e)=>{
          e.preventDefault();
          const val = (aliasInput.value||'').trim();
          if(val.length < 1 || val.length > 24){ aliasErr.textContent = 'Name must be 1–24 characters.'; aliasErr.style.display='block'; return; }
          if(/[^a-zA-Z0-9 _-]/.test(val)){ aliasErr.textContent = 'Only letters, numbers, spaces, - and _.'; aliasErr.style.display='block'; return; }
          aliasErr.style.display='none';
          setAlias(val);
          try{ aliasDlg.close(); }catch(e){ aliasDlg.removeAttribute('open'); }
        });
      }
      // Equip slot handlers (figure + badges)
      document.querySelectorAll('.slot').forEach(el=>{ const s = el.getAttribute('data-slot'); if(s){ el.addEventListener('click', ()=>openEquipSlot(s)); }});
// Category buttons
      const bPetty = document.getElementById("btnCatPetty");
      const bSmall = document.getElementById("btnCatSmall");
      if(bPetty && !bPetty.dataset.bound){ bPetty.addEventListener("click", () => setCategory('petty')); bPetty.dataset.bound="1"; }
      if(bSmall && !bSmall.dataset.bound){ bSmall.addEventListener("click", () => setCategory('small')); bSmall.dataset.bound="1"; }
      document.querySelectorAll(".sidelink").forEach(link => {
        link.addEventListener("click", () => setActiveTab(link.dataset.tab));
      });
      renderShop();
      const rangeBar = document.getElementById('chartRanges');
      if(rangeBar){
        rangeBar.querySelectorAll('.rangebtn').forEach(btn => {
          btn.addEventListener('click', () => {
            rangeBar.querySelectorAll('.rangebtn').forEach(b => b.setAttribute('aria-pressed', 'false'));
            btn.setAttribute('aria-pressed','true');
            const r = btn.getAttribute('data-range');
            chartRange = (r === 'all' || r === 'session') ? r : parseInt(r,10);
            const label = document.getElementById('dbgRangeLabel'); if(label){ label.textContent = btn.textContent.trim(); }
            chartNeedsDraw = true; drawChart();
          });
        });
      }

      const copyBtn = document.getElementById("copyKeyBtn");
      if(copyBtn){
        copyBtn.addEventListener("click", async () => {
          try{
            await navigator.clipboard.writeText(SAVE_KEY);
            addLog(`Copied save key: '${SAVE_KEY}'`);
          }catch(e){
            addLog('Could not copy save key.');
          }
          updateUI();
        });
      }

      // Sidebar responsive toggles
      const sidebar = document.getElementById("sidebar");
      const openBtn = document.getElementById("openSidebarBtn");
      const closeBtn = document.getElementById("toggleSidebarBtn");
      if(openBtn){ openBtn.addEventListener("click", () => sidebar.classList.add("open")); }
      if(closeBtn){ closeBtn.addEventListener("click", () => sidebar.classList.remove("open")); }

      // Load + init
      loadGame();
      ensureDefaultStats();
      if(!hasSeededOnce() && !state.inventory.length && getHQStore().length===0){ seedFakeItems(); }
      reconcileEquipment();
      (function(){ const viewAct=document.getElementById("view-activities"); if(viewAct && viewAct.classList.contains("hidden")) setActiveTab("activities"); })();
      applyCategory();
      updateUI();
      applyDebugUI();
      attachRipples();
      setInterval(tick, TICK_MS);
	  
	  // === Debug helpers: cash/xp buttons (visible when Debug is On) ===
      (function(){
        const gCash = document.getElementById('giveCashBtn');
        if (gCash && !gCash.dataset.bound){
          gCash.dataset.bound = '1';
          gCash.addEventListener('click', () => {
            const amt = 100;
            try{ changeMoney(amt, 'debug'); pushLog(`Debug: granted ${spanMoney(amt)}.`); }catch(e){}
            updateUI();
          });
        }
        const gXP = document.getElementById('giveXPBtn');
        if (gXP && !gXP.dataset.bound){
          gXP.dataset.bound = '1';
          gXP.addEventListener('click', () => {
            try{ ensureDefaultStats(); }catch(e){}
            const stats = Object.keys(state.stats || {});
            const per = (XP_AWARD_SUCCESS && Number(XP_AWARD_SUCCESS["Sleight of Hand"])) || 10;
            for (const name of stats){ try{ awardXP(name, per); }catch(e){} }
            try { pushLog(`Debug: +${per} XP to all ${stats.length} stats.`); } catch(e){}
            updateUI();
          });
        }
      })();

    });
  </script>
<dialog id="equipDialog">
<form class="modal-card" method="dialog">
<h3 style="margin-top:0">Equip Slot: <span id="equipSlotName">?</span></h3>
<!-- Filled dynamically -->
<ul aria-busy="false" aria-live="polite" class="list" id="equipList"></ul>
<p class="small muted" id="equipNone" style="display:none"></p>
<div class="debug-block small codepath">
      Code: <strong>state.equipment['<span id="equipSlotKey">?</span>']</strong>
</div>
<div class="modal-actions">
<button class="btn secondary" id="equipUnequipBtn" type="button">Unequip</button>
<button class="btn secondary" value="cancel">Close</button>
</div>
</form>
</dialog>
<dialog id="aliasDialog">
<form class="modal-card" method="dialog">
<h3 style="margin-top:0">Edit Alias</h3>
<div class="field"><label class="small muted" for="aliasInput">Enter a display name (1–24 characters)</label>
<input id="aliasInput" maxlength="24" placeholder="Your alias" type="text"/></div>
<p class="small" id="aliasError" style="color:var(--danger);display:none;margin:6px 0 0 0">Invalid name.</p>
<div class="modal-actions">
<button class="btn secondary" value="cancel">Cancel</button>
<button class="btn" id="aliasSaveBtn">Save</button>
</div>
</form>
</dialog>
<style id="ui-soft-borders" media="all">
  /* Final-pass overrides to remove bright outlines */
  .card,
  .pill,
  .btn,
  .statrow,
  #logList > li,
  .list > li,
  .slot.badge,
  .collapse-btn,
  .progress,
  .equip-wrap .row,
  .equip-wrap .slot,
  .market .row,
  .market .pill,
  .market .card {
    border: none !important;
    box-shadow: inset 0 1px 0 rgba(255,255,255,.035) !important;
  }
  /* Progress tracks specifically shouldn't have strokes */
  .progress{ border: none !important; }
  /* Any 1px outline expressed as box-shadow */
  .has-outline,
  .inv-item.equipped, /* keep green inner stroke but soften the base */
  .list .item{
    box-shadow: inset 0 1px 0 rgba(255,255,255,.035) !important;
  }



/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<!-- Analytics+Tabs Fix Patch: handles duplicate IDs & ensures chart/metrics render reliably -->
<script>
(function(){
  function patch(){
    try{
      // Helper: get all elements that (illegally) share an id
      function allById(id){
        return Array.from(document.querySelectorAll('[id="'+id+'"]'));
      }
      // Helper: set text on all duplicates
      function setAllText(id, txt){
        allById(id).forEach(el => { if(el) el.textContent = txt; });
      }
      // Sync analytics numbers across any duplicate sections
      function syncAnalyticsMirrors(){
        try{
          if(!window.state || !state.metrics) return;
          const m = state.metrics;
          const earned = (m.money && m.money.earned|0) || 0;
          const spent  = (m.money && m.money.spent|0)  || 0;
          const net    = Math.max(0, earned - spent);
          setAllText('metricEarned', '£' + earned);
          setAllText('metricSpent',  '£' + spent);
          setAllText('metricNet',    '£' + net);
          setAllText('metricEarnedSrc', String(earned));
          setAllText('metricSpentSrc',  String(spent));
          // Heat
          const heat = (state.heat|0) || 0;
          setAllText('metricHeatCurrent', String(heat));
          setAllText('metricHeatPeak',    String((m.heat && m.heat.peak|0) || 0));
          setAllText('metricHeatGained',  String((m.heat && m.heat.gained|0) || 0));
          setAllText('metricHeatCooled',  String((m.heat && m.heat.cooled|0) || 0));
          setAllText('metricHeatAvg',     String((m.heat && m.heat.avg) || 0));
          setAllText('metricHeatPeakSrc',   String((m.heat && m.heat.peak|0) || 0));
          setAllText('metricHeatGainedSrc', String((m.heat && m.heat.gained|0) || 0));
          setAllText('metricHeatCooledSrc', String((m.heat && m.heat.cooled|0) || 0));
          setAllText('metricHeatAvgSrc',    String((m.heat && m.heat.avg) || 0));
          // Bars
          allById('metricHeatBar').forEach(hb => {
            try{
              const HEAT_MAX = (window.HEAT_MAX||100);
              hb.style.width = Math.min(100, (heat/HEAT_MAX)*100).toFixed(2) + '%';
            }catch(e){}
          });
        }catch(e){}
      }

      // Bind range buttons for ALL duplicate toolbars
      (function bindAllRangebars(){
        const bars = allById('chartRanges');
        bars.forEach(rangeBar => {
          if(rangeBar && !rangeBar.dataset.bound){
            rangeBar.dataset.bound = '1';
            rangeBar.querySelectorAll('.rangebtn').forEach(btn => {
              btn.addEventListener('click', () => {
                try{
                  rangeBar.querySelectorAll('.rangebtn').forEach(b => b.setAttribute('aria-pressed', 'false'));
                }catch(e){}
                btn.setAttribute('aria-pressed','true');
                const r = btn.getAttribute('data-range');
                window.chartRange = (r === 'all' || r === 'session') ? r : parseInt(r,10);
                allById('dbgRangeLabel').forEach(label => { label.textContent = btn.textContent.trim(); });
                window.chartNeedsDraw = true;
                try{ window.drawChart(); }catch(e){}
              });
            });
          }
        });
      })();

      // Wrap setActiveTab so it toggles ALL duplicate views
      if(typeof window.setActiveTab === 'function' && !window.setActiveTab.__patched){
        const __origSetActiveTab = window.setActiveTab;
        window.setActiveTab = function(id){
          try{ __origSetActiveTab.call(this, id); }catch(e){}
          try{
            const views = ["headquarters","property","activities","stats","inventory","upgrades","shop","analytics","mail","gambling"];
            const catsRowAll = allById('activityCats');
            views.forEach(v => {
              const active = (v === id);
              allById('view-'+v).forEach(el => {
                el.classList.toggle('hidden', !active);
                el.setAttribute('aria-hidden', (!active).toString());
              });
            });
            catsRowAll.forEach(catsRow => catsRow.classList.toggle('hidden', id !== 'activities'));
            if(id === 'analytics'){
              // ensure label matches current selection
              const labelText = (window.chartRange === 'all' ? 'all'
                               : window.chartRange === 'session' ? 'session'
                               : (Math.round(((Number(window.chartRange)||300000)/60000)) + 'm'));
              allById('dbgRangeLabel').forEach(label => { label.textContent = labelText; });
              if((state.lifetime?.all?.length||0)===0 && (state.history?.session?.length||0)===0){
                try{ if(typeof window.pushSample==='function') window.pushSample(); }catch(e){}
              }
              window.chartNeedsDraw = true;
              try{ window.drawChart(); }catch(e){}
            }
          }catch(e){}
        };
        window.setActiveTab.__patched = true;
      }

      // Override drawChart to target the visible canvas (in case of duplicates)
      (function patchDrawChart(){
        function cssVar(name, fallback){
          try{
            const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
            return v || fallback;
          }catch(e){ return fallback; }
        }
        function safeGetSeries(){
          try{ return (typeof window.getSamplesForRange==='function') ? window.getSamplesForRange() : []; }
          catch(e){ return []; }
        }
        function mapY(value, minY, maxY, h, pad){ // mirror of existing helper
          pad = (typeof pad==='number') ? pad : 8;
          if(maxY === minY) return h/2;
          const pct = (value - minY) / (maxY - minY);
          return Math.round((1 - pct) * (h - pad*2) + pad);
        }
        function drawPatched(){
          const list = Array.from(document.querySelectorAll('[id="analyticsChart"]'));
          if(list.length === 0) return;
          const target = list.find(c => c.offsetWidth > 0 && c.offsetHeight > 0 && !c.closest('.hidden')) || list[0];
          const c = target;
          const ctx = c.getContext('2d');
          const w = c.width = c.clientWidth || c.width || 600;
          const h = c.height = 220;

          const series = safeGetSeries();
          const count = series.length;

          // Determine Y bounds with padding
          let minY = Infinity, maxY = -Infinity;
          for(const s of series){
            if(s.money < minY) minY = s.money;
            if(s.money > maxY) maxY = s.money;
            if(s.heat  < minY) minY = Math.min(minY, s.heat);
            if(s.heat  > maxY) maxY = Math.max(maxY, s.heat);
            if(Number.isFinite(s.spent)){ // allow 0
              if(s.spent < minY) minY = Math.min(minY, s.spent);
              if(s.spent > maxY) maxY = Math.max(maxY, s.spent);
            }
          }
          if(!isFinite(minY) || !isFinite(maxY)){
            minY = 0; maxY = Math.max(10, (state?.money|0) + 10);
          }
          if(minY === maxY){ maxY = minY + 1; }

          // Clear
          ctx.clearRect(0,0,w,h);
          ctx.fillStyle = '#0b0f14';
          ctx.fillRect(0,0,w,h);

          // Grid
          ctx.strokeStyle = 'rgba(255,255,255,0.08)';
          ctx.lineWidth = 1;
          const stripes = 5;
          for(let i=1;i<stripes;i++){
            const y = Math.round((h/stripes)*i);
            ctx.beginPath();
            ctx.moveTo(0,y);
            ctx.lineTo(w,y);
            ctx.stroke();
          }

          // Draw helper
          function lineFor(key, stroke, dash){
            if(count < 1) return;
            ctx.beginPath();
            ctx.setLineDash(dash||[]);
            ctx.lineWidth = 2;
            ctx.strokeStyle = stroke;
            for(let i=0;i<count;i++){
              const s = series[i];
              const x = Math.round((i/(Math.max(1,count-1))) * (w-2)) + 1;
              const yv = key==='money' ? s.money : (key==='heat' ? s.heat : (s.spent||0));
              const y = mapY(yv, minY, maxY, h, 8);
              if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
          }

          const colMoney = cssVar('--good', '#22c55e');
          const colHeat  = cssVar('--accent-warm', '#f59e0b');
          const colSpent = cssVar('--danger', '#ef4444');

          // Money & Heat always; Spent if present
          lineFor('money', colMoney);
          lineFor('heat',  colHeat);
          if(series.some(s => Number.isFinite(s.spent))) lineFor('spent', colSpent, [5,4]);

          // Legend (top-right-ish)
          ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial';
          ctx.textBaseline = 'top';
          const items = [
            ['Money', colMoney],
            ['Heat',  colHeat],
            ['Outgoings', colSpent]
          ];
          let lx = w - 120, ly = 6;
          items.forEach(([label,color]) => {
            ctx.fillStyle = color;
            ctx.fillRect(lx, ly+3, 10, 10);
            ctx.fillStyle = '#e5e7eb';
            ctx.fillText(label, lx+14, ly);
            ly += 16;
          });
        }

        // Replace global drawChart/drawLiveChart with patched versions
        window.drawChart = drawPatched;
        window.drawLiveChart = function(){ try{ drawPatched(); }catch(e){} };
      })();

      // Replace analyticsVisible check to consider ALL duplicates
      if(typeof window.tick === 'function' && !window.tick.__analyticsPatched){
        const __origTick = window.tick;
        window.tick = function(){
          try{ __origTick.call(this); }catch(e){}
          try{
            // After original tick, ensure mirrors are synced
            syncAnalyticsMirrors();
          }catch(e){}
        };
        window.tick.__analyticsPatched = true;
      }else{
        // Fallback: periodically sync mirrors
        try{ setInterval(syncAnalyticsMirrors, 1000); }catch(e){}
      }

      // Initial sync once
      syncAnalyticsMirrors();

    }catch(e){ /* swallow */ }
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', patch);
  }else{
    patch();
  }
})();
</script>
<!-- Compatibility stubs: prevent errors if optional systems are omitted -->
<script>
// Define no-op fallbacks if these hooks aren't present in this build.
if (typeof window.processRandomEncounter !== 'function') {
  window.processRandomEncounter = function(/*dt*/){ /* no-op (compat) */ };
}
if (typeof window.maybeTriggerPoliceEvent !== 'function') {
  window.maybeTriggerPoliceEvent = function(){ /* no-op (compat) */ };
}
</script>
<script>
(function(){
  // Guard: ensure global state object exists
  window.state = window.state || {};

  function escapeHtml(str){
    try {
      return String(str).replace(/[&<>"']/g, s => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
    } catch(e){ return String(str); }
  }

  function ensureMailState(){
    if(!window.state) window.state = {};
    if(!state.mail) state.mail = { inbox: [], unread: 0, nextId: 1, seededWelcome: false, crt: false, selectedId: null, lastReadId: null };
    if(!Array.isArray(state.mail.inbox)) state.mail.inbox = [];
    if(typeof state.mail.unread!=='number') state.mail.unread = 0;
    if(typeof state.mail.nextId!=='number') state.mail.nextId = Math.max(1, state.mail.inbox.length+1);
    if(typeof state.mail.seededWelcome!=='boolean') state.mail.seededWelcome = false;
    if(typeof state.mail.crt!=='boolean') state.mail.crt = false;
    if(state.mail.selectedId && typeof state.mail.selectedId!=='string') state.mail.selectedId = null;
    if(state.mail.lastReadId && typeof state.mail.lastReadId!=='string') state.mail.lastReadId = null;
  }

  function sanitizeMail(data){
    const out = { inbox: [], unread: 0, nextId: 1, seededWelcome: false, crt: false, selectedId: null, lastReadId: null };
    if(!data || typeof data!=='object') return out;
    out.inbox = Array.isArray(data.inbox) ? data.inbox.slice(0,200).map(m=>{
      if(!m || typeof m!=='object') return null;
      return {
        id: String(m.id||'').slice(0,40) || ('m'+Math.random().toString(36).slice(2,8)),
        from: String(m.from||'System').slice(0,80),
        subject: String(m.subject||'(no subject)').slice(0,160),
        body: String(m.body||''),
        ts: Math.max(0, Math.floor(Number(m.ts)||Date.now())),
        read: !!m.read
      };
    }).filter(Boolean) : [];
    out.unread = out.inbox.reduce((n,m)=> n + (!m.read ? 1 : 0), 0);
    out.nextId = Math.max(1, Number.isFinite(data.nextId) ? Math.floor(data.nextId) : (out.inbox.length+1));
    out.crt = !!data.crt;
    out.selectedId = (typeof data.selectedId==='string') ? data.selectedId : null;
    out.lastReadId = (typeof data.lastReadId==='string') ? data.lastReadId : null;
    out.seededWelcome = !!data.seededWelcome;
    out.crt = !!data.crt;
    return out;
  }

  function updateMailBadge(){
    const badge = document.getElementById('mailBadge');
    if(!badge) return;
    const n = Math.max(0, Array.isArray(state.mail?.inbox) ? state.mail.inbox.reduce((k,m)=>k+(!m.read?1:0),0) : (state.mail?.unread|0));
    badge.textContent = String(n);
    badge.classList.toggle('hidden', n===0);
  }

  function renderMailList(selectedId){
    ensureMailState();
    const ul = document.getElementById('mailList');
    if(!ul) return;
    const rows = state.mail.inbox.map(m=>{
      const selected = (m.id === selectedId);
      const classes = ['mail-item']; if(!m.read) classes.push('unread'); if(selected) classes.push('selected');
      const ago = (typeof window.formatTimeAgo==='function') ? window.formatTimeAgo(m.ts) : '';
      return `<li class="${classes.join(' ')}" data-id="${escapeHtml(m.id)}" tabindex="0" role="button" aria-pressed="${selected}">
        <div class="sender">${escapeHtml(m.from)}</div>
        <div class="subj">${escapeHtml(m.subject)}</div>
        <div class="meta"><span>${ago}</span></div>
      </li>`;
    }).join('');
    ul.innerHTML = rows || '';
    const empty = document.getElementById('mailEmpty');
    const reader = document.getElementById('mailRead');
    if(empty) empty.classList.toggle('hidden', !!state.mail.inbox.length);
    if(reader) reader.classList.toggle('hidden', !selectedId);
    ul.querySelectorAll('.mail-item').forEach(li=>{
      li.addEventListener('click', ()=>openMail(li.getAttribute('data-id')));
      li.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); openMail(li.getAttribute('data-id')); }});
    });
  }

  function openMail(id){
    ensureMailState();
    const m = state.mail.inbox.find(x=>x && x.id===id);
    const box = document.getElementById('mailRead');
    const empty = document.getElementById('mailEmpty');
    if(!m || !box) return;
    document.getElementById('mailSubj').textContent = m.subject;
    document.getElementById('mailFrom').textContent = m.from;
    document.getElementById('mailAgo').textContent = (typeof window.formatTimeAgo==='function') ? window.formatTimeAgo(m.ts) : '';
    document.getElementById('mailBody').textContent = m.body;
    box.classList.remove('hidden'); box.setAttribute('aria-hidden','false');
    // Remember selection
    try{ state.mail.selectedId = id; if (typeof window.scheduleSave==='function') window.scheduleSave(); }catch(e){}
    if(empty) empty.classList.add('hidden');
    markMailRead(id);
    renderMailList(id);
  }

  function renderMailView(){
    ensureMailState();
    let sel = (state.mail && state.mail.selectedId) || (state.mail && state.mail.lastReadId) || ((state.mail && state.mail.inbox[0] && state.mail.inbox[0].id) || '');
    renderMailList(sel);
    updateMailBadge();
    if(sel) openMail(sel);
  }

  function addMail({from, subject, body, ts}){
    ensureMailState();
    const id = 'm'+(state.mail.nextId++);
    const msg = { id, from: String(from||'System'), subject: String(subject||'(no subject)'), body: String(body||''), ts: ts||Date.now(), read: false };
    state.mail.inbox.unshift(msg);
    state.mail.unread++;
    updateMailBadge();
    if (typeof window.pushLog === 'function'){
      try{ window.pushLog(`New mail: <strong>${escapeHtml(msg.subject)}</strong>`); }catch(e){}
    }
    if (typeof window.scheduleSave === 'function'){ window.scheduleSave(); }
      try{ if(typeof window.saveGame==='function') window.saveGame({silent:true}); }catch(e){}
    const mailView = document.getElementById('view-mail');
    if(mailView && !mailView.classList.contains('hidden')) renderMailView();
    const badge = document.getElementById('mailBadge');
    if(badge){ badge.classList.add('bump'); setTimeout(()=>badge.classList.remove('bump'), 300); }
    return msg;
  }

  function markMailRead(id){
    ensureMailState();
    const m = state.mail.inbox.find(x=>x && x.id===id);
    if(m && !m.read){
      m.read = true;
      m.readAt = Date.now();
      state.mail.unread = Math.max(0, state.mail.unread - 1);
      state.mail.lastReadId = id;
      state.mail.selectedId = id;
      updateMailBadge();
      if (typeof window.scheduleSave === 'function'){ window.scheduleSave(); }
      try{ if(typeof window.saveGame==='function') window.saveGame({silent:true}); }catch(e){}
    }
  }

  // Expose a convenience API
  window.pushMail = (from, subject, body) => addMail({from, subject, body});

  // Inject hooks into save/load if present; otherwise leave state.mail as-is to avoid breakage.
  try {
    // Hook saveGame by shallowly adding mail to payload stringification (non-invasive wrapper)
    if (typeof window.saveGame === 'function' && !window.saveGame.__mailWrapped){
      const _saveGame = window.saveGame;
      window.saveGame = function(){
        ensureMailState();
        try{ return _saveGame.apply(this, arguments); }
        finally {
          // No-op: existing saveGame likely serializes state wholesale; mail lives on state so it's persisted anyway.
        }
      };
      window.saveGame.__mailWrapped = true;
    }
  } catch(e){}

  // After DOM is ready, ensure state, seed welcome once, wire tab behavior
  const onReady = () => {
    ensureMailState();
    // If the app has its own loadGame that hydrates state async, wait a tick.
    setTimeout(()=>{
      try {
        // Attempt to sanitize any loaded mail
        if (state.mail) state.mail = sanitizeMail(state.mail);
      } catch(e){}
      // Seed initial welcome mail once per profile
      if(!state.mail.seededWelcome){
        const body = [
          "Welcome to CrimIdle! (Fictional game prototype.)",
          "",
          "How it works:",
          "• Activities: try Pickpocket (cooldowns & chances apply).",
          "• XP & Levels: successes (and tries) raise skills for better odds.",
          "• Heat: goes up on actions; decays over time; high heat hurts success.",
          "• Inventory: equip items to boost stats; store extras at your HQ.",
          "• Property/HQ: claim a base and manage storage.",
          "• Shop: grab snacks to manage vitals (placeholders).",
          "• Autosave: your progress saves as you play.",
          "",
          "Tip: Watch the Analytics tab for Balance/Heat trends.",
          "",
          "— Control, ‘CI’ Systems"
        ].join("\n");
        addMail({ from: "CI Systems", subject: "Welcome to CrimIdle — Quick Start", body });
        const body2 = [
          "Inbox Demo — Multiple Messages",
          "",
          "This is a second test email so you can see how multiple emails look.",
          "• Newest messages appear at the top",
          "• Click any message on the left to read it on the right",
          "",
          "Have fun testing!",
          "",
          "— CI Systems"
        ].join("\n");
        addMail({ from: "CI Systems", subject: "Inbox Demo — Multiple Messages", body: body2 });
    
        state.mail.seededWelcome = true;
        if (typeof window.scheduleSave === 'function'){ window.scheduleSave(); }
      try{ if(typeof window.saveGame==='function') window.saveGame({silent:true}); }catch(e){}
      }
      updateMailBadge();
      // If your tab system uses setActiveTab and a known views list, try to auto-render when visiting "mail"
      // We add a small observer on sidebar clicks for safety.
      const mailLink = document.getElementById('mailLink');
      if(mailLink){
        mailLink.addEventListener('click', ()=>{ renderMailView(); });
      }
    }, 0);
  };

  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", onReady, { once: true });
  } else {
    onReady();
  }
})();
</script>
<script>
(function(){
  try{
    if(typeof window.setActiveTab === 'function' && !window.setActiveTab.__mailHooked){
      const _setActiveTab = window.setActiveTab;
      window.setActiveTab = function(id){
        const ret = _setActiveTab.apply(this, arguments);
        if(id === 'mail' && typeof window.renderMailView === 'function'){ try{ window.renderMailView(); }catch(e){} }
        return ret;
      };
      window.setActiveTab.__mailHooked = true;
    }
  }catch(e){}
})();
</script>
<script>
(function(){
  try{
    if(typeof window.loadGame === 'function' && !window.loadGame.__mailHooked){
      const _loadGame = window.loadGame;
      window.loadGame = function(){
        const ret = _loadGame.apply(this, arguments);
        try{
          if(typeof window.sanitizeMail === 'function'){
            if(!window.state) window.state = {};
            window.state.mail = window.sanitizeMail(window.state.mail);
          }
          if(typeof window.ensureMailState === 'function'){ window.ensureMailState(); }
        }catch(e){}
        return ret;
      };
      window.loadGame.__mailHooked = true;
    }
  }catch(e){}
})();
</script>
<script id="mail-crt-toggle">
(function(){
  function applyCRT(){
    var root = document.getElementById('view-mail');
    if(!root) return;
    if(!window.state) window.state = {};
    if(!state.mail) state.mail = {};
    if(typeof state.mail.crt !== 'boolean') state.mail.crt = false; // default OFF by default
    root.classList.toggle('crt-on', !!state.mail.crt);
    var btn = document.getElementById('mailThemeToggle');
    if(btn){ btn.textContent = state.mail.crt ? 'CRT: ON' : 'CRT: OFF'; }
  }
  function initCRT(){
    applyCRT();
    var btn = document.getElementById('mailThemeToggle');
    if(btn){
      btn.addEventListener('click', function(){
        if(!window.state) window.state = {};
        if(!state.mail) state.mail = {};
        state.mail.crt = !state.mail.crt;
        applyCRT();
        if(typeof window.scheduleSave === 'function') try{ window.scheduleSave(); }catch(e){}
      });
    }
  }
  if(document.readyState==='loading'){
    document.addEventListener('DOMContentLoaded', initCRT, { once: true });
  }else{
    initCRT();
  }
})();

// === Gambling (Tiered) =======================================================
(function(){
  let gamblingBound = false;
  const REEL_STRIPS = [["🍋", "⭐", "⭐", "🍒", "🍒", "🔔", "🍒", "🍋", "🍒", "🍋", "🍒", "🔔", "7️⃣", "🍋", "🍒", "🔔", "🔔", "🍋", "🍒", "🔔", "🔔", "⭐", "🍒", "🔔", "🍒", "🍒", "🍒", "🍋", "⭐", "🍋", "🔔", "🍋", "🔔", "🍒", "🍒", "🍒", "🍋", "🔔", "🍒", "⭐", "🔔", "🔔", "⭐", "🍋", "🔔", "🔔", "🍋", "⭐", "7️⃣", "🍒", "⭐", "🍋", "🔔", "⭐", "🍋", "7️⃣", "🍋", "🔔", "🍒", "⭐", "🍒", "7️⃣", "⭐", "🍋", "🔔", "🍋", "🍋", "⭐", "🍒", "🍋", "⭐", "7️⃣", "🔔", "⭐", "7️⃣", "7️⃣", "🍒", "🍋", "🔔", "7️⃣", "🍒", "7️⃣", "7️⃣", "⭐", "🍋", "⭐", "🍒", "⭐", "🍒", "🍋", "⭐", "🍋", "🔔", "🍒", "🔔", "🍒", "🍒", "🍋", "🍒", "🍒", "🔔", "7️⃣", "🔔", "🍋", "🔔", "🍒", "7️⃣", "🍋", "🍋", "7️⃣", "🔔", "⭐", "🍒", "🍒", "🍒", "🔔", "7️⃣", "🍒", "⭐", "🔔", "🍋", "⭐", "🔔", "🍋", "⭐", "🍋", "🍒", "🍋"], ["🍒", "🍋", "🔔", "🔔", "🍒", "🔔", "🍋", "🔔", "🔔", "🔔", "🍋", "🔔", "🔔", "🍋", "🍋", "7️⃣", "🍋", "⭐", "🍒", "🍒", "7️⃣", "🍒", "🔔", "🍒", "⭐", "🍒", "🔔", "7️⃣", "🍒", "⭐", "🔔", "🍒", "7️⃣", "🍒", "⭐", "⭐", "7️⃣", "🔔", "⭐", "🍒", "🔔", "🍒", "🍋", "🍒", "🍒", "🍋", "7️⃣", "⭐", "🍒", "🍒", "🍒", "⭐", "7️⃣", "🔔", "🍋", "🔔", "🍋", "🔔", "🍋", "🍋", "🍒", "🍋", "7️⃣", "⭐", "⭐", "🍒", "🍋", "🍒", "🍒", "🔔", "🍒", "⭐", "🔔", "7️⃣", "⭐", "🔔", "⭐", "🔔", "🔔", "🍋", "🔔", "⭐", "🍒", "🍋", "7️⃣", "⭐", "🔔", "🍋", "⭐", "⭐", "⭐", "🔔", "7️⃣", "⭐", "🍋", "⭐", "🍋", "🔔", "🍋", "🍋", "🍒", "7️⃣", "🍒", "🍒", "🍋", "🍒", "🔔", "🔔", "7️⃣", "🔔", "⭐", "🍒", "🍋", "🍋", "🍒", "⭐", "🍋", "7️⃣", "🍋", "🍋", "🍋", "🍒", "🍒", "🍒", "🔔", "🍋", "🍋", "🔔"], ["🍒", "⭐", "🍒", "🔔", "🍒", "🔔", "🍋", "7️⃣", "🔔", "⭐", "🍒", "🔔", "⭐", "🍒", "7️⃣", "🔔", "🔔", "🔔", "🍋", "🔔", "🍋", "7️⃣", "🔔", "🍋", "🔔", "⭐", "7️⃣", "🍒", "⭐", "🍋", "🔔", "🍋", "7️⃣", "🍒", "🔔", "🍋", "⭐", "⭐", "🍋", "🔔", "🍒", "🍒", "🔔", "⭐", "🍋", "🔔", "⭐", "7️⃣", "🔔", "7️⃣", "🍒", "⭐", "🔔", "⭐", "🍋", "⭐", "🔔", "🔔", "🍒", "🍒", "🔔", "⭐", "⭐", "🍋", "🔔", "7️⃣", "⭐", "🍋", "⭐", "🍒", "🍒", "🍋", "🔔", "⭐", "🍒", "🍒", "🍋", "🍋", "🔔", "🍒", "🍋", "🍒", "🍋", "🍋", "🔔", "🍋", "🍒", "🔔", "🍒", "⭐", "🍋", "🍒", "🔔", "7️⃣", "🔔", "7️⃣", "🍒", "7️⃣", "🔔", "🍒", "🍋", "🍒", "🍋", "🍋", "🔔", "⭐", "🍋", "🍒", "🔔", "7️⃣", "🔔", "🔔", "🍒", "⭐", "🍋", "🍋", "🍋", "🍋", "🍒", "⭐", "⭐", "🍒", "🍒", "7️⃣", "🍋", "🍋", "🍒", "7️⃣"]];

function spinReels(){
  return REEL_STRIPS.map(strip => strip[Math.floor(Math.random()*strip.length)]);
}

  
  function renderTierHint(){
    const el = document.getElementById('tbTierHint'); if(!el) return;
    const cap = getCapturedCount();
    const maxTier = Math.min(6, cap+1);
    if(maxTier >= 6){
      el.textContent = `Captured ${cap}/6 • All tiers unlocked`;
    }else{
      el.textContent = `Captured ${cap}/6 • Unlocked: T1–T${maxTier} • Next unlock at ${cap+1}/6`;
    }
  }
function setTier(n){
    const btn1 = document.getElementById('btnTier1');
    const btn2 = document.getElementById('btnTier2');
    const btn3 = document.getElementById('btnTier3');
    const t1 = document.getElementById('tier-1');
    const t2 = document.getElementById('tier-2');
    const t3 = document.getElementById('tier-3');
    if(!btn1||!btn2||!btn3||!t1||!t2||!t3) return;
    btn1.setAttribute('aria-pressed', String(n===1));
    btn2.setAttribute('aria-pressed', String(n===2));
    btn3.setAttribute('aria-pressed', String(n===3));
    t1.classList.toggle('hidden', n!==1);
    t2.classList.toggle('hidden', n!==2);
    t3.classList.toggle('hidden', n!==3);
  
    if(n===2){ try{ bindRouletteUI(); }catch(e){} }

    if(n===1){ try{ setTimeout(()=> window.dispatchEvent(new Event('resize')), 0); }catch(e){} }
}

  function getBet(){ 
    const inp = document.getElementById('betInput'); 
    let v = parseInt(inp && inp.value || '1',10); 
    if(isNaN(v) || v < 1) v = 1; 
    return v; 
  }
  function setSpinCostLabel(){
    const cost = document.getElementById('spinCost'); 
    if(cost){ cost.textContent = String(getBet()); }
  }
  function applySlotPayout(a,b,c){
    // Cost upfront
    const bet = getBet();
    if((state.money|0) < bet){
      pushLog('' + `<span class="logpiece tbad">Insufficient funds for spin (£${bet})</span>`);
      return { paid:false, win:0 };
    }
    changeMoney(-bet, 'slot-cost');

    // Determine win
    
    let winMult = 0;
    const triple = (a===b && b===c);
    if(triple){
      if(a==='7️⃣') winMult = 20;
      else if(a==='⭐') winMult = 10;
      else if(a==='🔔') winMult = 6;
      else if(a==='🍒') winMult = 4;
    }else{
      // Pairs (more realistic)
      if(a===b || a===c || b===c){
        const pairSym = (a===b||a===c)? a : b;
        if(pairSym==='7️⃣') winMult = 3;
        else if(pairSym==='⭐') winMult = 2;
        else if(pairSym==='🔔') winMult = 1;
        else if(pairSym==='🍒') winMult = 1;
      }
      // Cherry on first reel: refund if still no win
      if(winMult===0 && a==='🍒') winMult = 1;
    }
    const win = winMult * bet;

    if(win>0){
      changeMoney(win, 'slot-win');
    }
    // Log
    const reelsHTML = `<span class="logpiece">${a} ${b} ${c}</span>`;
    if(win>0){
      const detail = winMult ? ` (${winMult}× on £${bet})` : '';
      pushLog({ html: `Fruit machine ${reelsHTML} → <span class="logpiece tmoney">+£${win}</span>${detail}` });
    }else{
      pushLog({ html: `Fruit machine ${reelsHTML} → ${'<span class="logpiece tbad">No win</span>'}` });
    }
    scheduleSave();
    return { paid:true, win };
  }

  function doSlotSpin(){
    const [r1,r2,r3] = spinReels();
    const reels = document.getElementById('reels');
    if(reels) reels.textContent = `${r1} ${r2} ${r3}`;
    
    try{ if(window.slot && typeof window.slot.visualSpin === 'function'){ window.slot.visualSpin([r1,r2,r3]); } }catch(e){}
const res = applySlotPayout(r1,r2,r3);
    const msg = document.getElementById('slotMsg');
    if(msg){
      if(res.paid){
        msg.textContent = res.win>0 ? `You won £${res.win}!` : `No win this time.`;
      }else{
        msg.textContent = `You need at least £${getBet()} to spin.`;
      }
    }
    updateUI();
  }

  function doAutoSpins(n=10){
    let i = 0;
    function step(){
      if(i>=n) return;
      if((state.money|0) < 1) return;
      doSlotSpin();
      i++;
      setTimeout(step, 180); // quick cadence
    }
    step();
  }

  function bindGamblingUI(){
    if(gamblingBound) return;
    const b1 = document.getElementById('btnTier1');
    const b2 = document.getElementById('btnTier2');
    const b3 = document.getElementById('btnTier3');
    if(b1 && !b1.dataset.bound){ b1.addEventListener('click', ()=> setTier(1)); b1.dataset.bound='1'; 
    // Bind roulette controls when Tier 2 is active
    try{ if(document.getElementById('tier-2') && !document.getElementById('tier-2').classList.contains('hidden')) bindRouletteUI(); }catch(e){}
}
    
function doDemoSpin(){
  // Free, silent spin for UI/demo purposes
  const [r1,r2,r3] = spinReels();
  const reels = document.getElementById('reels');
  if(reels) reels.textContent = `${r1} ${r2} ${r3}`;
  try{ if(window.slot && typeof window.slot.visualSpin === 'function'){ window.slot.visualSpin([r1,r2,r3]); } }catch(e){}
  const msg = document.getElementById('slotMsg');
  if(msg){ msg.textContent = 'Demo spin (free) — try your luck!'; }
  // No payout / money change / log
}
if(b2 && !b2.dataset.bound){ b2.addEventListener('click', ()=> setTier(2)); b2.dataset.bound='1'; }
    if(b3 && !b3.dataset.bound){ b3.addEventListener('click', ()=> setTier(3)); b3.dataset.bound='1'; }

    const spinBtn = document.getElementById('spinBtn');
    const autoBtn = document.getElementById('spinAutoBtn');
    if(spinBtn && !spinBtn.dataset.bound){
  spinBtn.addEventListener('click', ()=>{ try{ window.__lastUserGestureAt = (performance&&performance.now?performance.now():Date.now()); }catch(e){}; doSlotSpin(); });
  spinBtn.dataset.bound='1';
}
    if(autoBtn && !autoBtn.dataset.bound){ autoBtn.addEventListener('click', ()=> doAutoSpins(10)); autoBtn.dataset.bound='1'; }
    const betInput = document.getElementById('betInput');
    if(betInput && !betInput.dataset.bound){ betInput.addEventListener('input', setSpinCostLabel); betInput.dataset.bound='1'; }

    gamblingBound = true;
  
    // Bind roulette controls when Tier 2 is active
    try{ if(document.getElementById('tier-2') && !document.getElementById('tier-2').classList.contains('hidden')) bindRouletteUI(); }catch(e){}
}

  // Render hook when switching tabs
  const _origSetActiveTab = window.setActiveTab;
  window.setActiveTab = function(id){
    if(typeof _origSetActiveTab === 'function'){ _origSetActiveTab(id); }
    if(id === 'gambling'){
      // sync visible balance
      const balEl = document.getElementById('gambleBalance');
      if(balEl) balEl.textContent = String(state.money|0);
      setSpinCostLabel();
      bindGamblingUI();
      setTimeout(()=>{ try{ doDemoSpin(); }catch(e){} }, 0);
    }
  };

  // Keep gambling balance in sync on updateUI
  const _origUpdateUI = window.updateUI;
  window.updateUI = function(){
    if(typeof _origUpdateUI === 'function'){ _origUpdateUI(); }
    try{
      const balEl = document.getElementById('gambleBalance');
      if(balEl) balEl.textContent = String(state.money|0);
      const rbal = document.getElementById('rouletteBalance'); if(rbal) rbal.textContent = String(state.money|0);
      setSpinCostLabel();
    }catch(e){}
  };

  // === ROULETTE (Tier 2) =====================================================
  let rouletteBound = false;
  let rouletteLastBets = [];
  let rouletteHistory = [];

  const EU_SEQUENCE = [0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
  const REDS = new Set([32,19,21,25,34,27,36,30,23,5,16,1,14,9,18,7,12,3]);
  function isRed(n){ return REDS.has(n); }
  function isBlack(n){ return n!==0 && !REDS.has(n); }

  function buildRouletteTable(){
    const table = document.getElementById('rouletteTable');
    if(!table || table.dataset.built) return;
    table.dataset.built = '1';
    // Build 3 rows x 12 columns grid for numbers + zero + outside bets
    // First column reserved for 0 spanning rows
    // Numbers rows: 3..36 descending each column mod 3
    const frag = document.createDocumentFragment();
    // Zero
    const zero = document.createElement('div');
    zero.className = 'rt-cell rt-zero';
    zero.textContent = '0';
    zero.dataset.type = 'straight'; zero.dataset.value = '0';
    frag.appendChild(zero);

    // Number grid 1..36 laid out like standard table (rows 3-36)
    const nums = [];
    for(let r=0;r<3;r++){
      for(let c=0;c<12;c++){
        const n = (3*(c+1)) - r; // 3,6,9... top row; 2nd row 2,5,8; bottom 1,4,7
        nums.push(n);
        const d = document.createElement('div');
        d.className = 'rt-cell rt-num ' + (isRed(n)?'rt-red':'rt-black');
        d.textContent = String(n);
        d.dataset.type = 'straight';
        d.dataset.value = String(n);
        frag.appendChild(d);
      }
    }
    // Outside bets row(s)
    const outLabels = [
      { key:'1-12', label:'1st 12', type:'dozen', covers: Array.from({length:12},(_,i)=>i+1) },
      { key:'13-24', label:'2nd 12', type:'dozen', covers: Array.from({length:12},(_,i)=>i+13) },
      { key:'25-36', label:'3rd 12', type:'dozen', covers: Array.from({length:12},(_,i)=>i+25) },
      { key:'col1', label:'Column 1', type:'column', covers: Array.from({length:12},(_,i)=>1+3*i) },
      { key:'col2', label:'Column 2', type:'column', covers: Array.from({length:12},(_,i)=>2+3*i) },
      { key:'col3', label:'Column 3', type:'column', covers: Array.from({length:12},(_,i)=>3+3*i) },
      { key:'red', label:'Red', type:'even', covers: Array.from({length:36},(_,i)=>i+1).filter(isRed) },
      { key:'black', label:'Black', type:'even', covers: Array.from({length:36},(_,i)=>i+1).filter(isBlack) },
      { key:'odd', label:'Odd', type:'even', covers: Array.from({length:36},(_,i)=>i+1).filter(n=>n%2===1) },
      { key:'even', label:'Even', type:'even', covers: Array.from({length:36},(_,i)=>i+1).filter(n=>n%2===0) },
      { key:'low', label:'Low 1-18', type:'even', covers: Array.from({length:18},(_,i)=>i+1) },
      { key:'high', label:'High 19-36', type:'even', covers: Array.from({length:18},(_,i)=>i+19) }
    ];
    outLabels.forEach(cfg=>{
      const d = document.createElement('div');
      d.className = 'rt-cell rt-out';
      d.textContent = cfg.label;
      d.dataset.type = cfg.type;
      d.dataset.value = cfg.key;
      frag.appendChild(d);
    });
    table.appendChild(frag);
  }

  function getChip(){
    const el = document.getElementById('rouletteChip');
    let v = parseInt(el?.value||'1',10);
    if(!Number.isFinite(v) || v<1) v = 1;
    return v|0;
  }
  function updateRouletteTotals(){
    const tot = rouletteBets.reduce((s,b)=>s+b.amount,0);
    const el = document.getElementById('rouletteTotal');
    if(el) el.textContent = String(tot);
  }
  function renderPlacedBets(){
    const ul = document.getElementById('rouletteBets');
    if(!ul) return;
    ul.innerHTML='';
    rouletteBets.forEach((b,idx)=>{
      const li = document.createElement('li');
      li.innerHTML = `<span>${b.label}</span> <span>£${b.amount}</span>`;
      li.className = 'row';
      li.style.justifyContent='space-between';
      li.style.cursor='pointer';
      li.title = 'Click to remove this bet';
      li.addEventListener('click', ()=>{ rouletteBets.splice(idx,1); updateRouletteTotals(); renderPlacedBets(); });
      ul.appendChild(li);
    });
  }

  const PAYOUTS = {
    'straight': 35,
    'dozen': 2,
    'column': 2,
    'even': 1
  };

  let rouletteBets = [];

  function addBet(type, value, label, covers){
    const chip = getChip();
    rouletteBets.push({ type, value, label, covers, amount: chip });
    updateRouletteTotals();
    renderPlacedBets();
  }

  function bindRouletteTable(){
    const table = document.getElementById('rouletteTable');
    if(!table || table.dataset.bound) return;
    table.dataset.bound='1';
    table.addEventListener('click', (e)=>{
      const cell = e.target.closest('.rt-cell');
      if(!cell) return;
      const type = cell.dataset.type;
      const value = cell.dataset.value;
      if(type==='straight'){
        const n = parseInt(value,10);
        addBet('straight', n, `Straight ${n}`, [n]);
      }else if(type==='dozen'){
        const start = (value==='1-12')?1:(value==='13-24')?13:25;
        const covers = Array.from({length:12},(_,i)=>start+i);
        addBet('dozen', value, cell.textContent, covers);
      }else if(type==='column'){
        const colIndex = (value==='col1')?1:(value==='col2')?2:3;
        const covers = Array.from({length:12},(_,i)=>colIndex+3*i);
        addBet('column', value, cell.textContent, covers);
      }else if(type==='even'){
        let covers=[];
        if(value==='red') covers = Array.from({length:36},(_,i)=>i+1).filter(isRed);
        else if(value==='black') covers = Array.from({length:36},(_,i)=>i+1).filter(isBlack);
        else if(value==='odd') covers = Array.from({length:36},(_,i)=>i+1).filter(n=>n%2===1);
        else if(value==='even') covers = Array.from({length:36},(_,i)=>i+1).filter(n=>n%2===0);
        else if(value==='low') covers = Array.from({length:18},(_,i)=>i+1);
        else if(value==='high') covers = Array.from({length:18},(_,i)=>i+19);
        addBet('even', value, cell.textContent, covers);
      }
    });
  }

  // Canvas wheel + spin
  let wheelAngle = 0;
  let ballAngle = 0;
  let spinning = false;

  function drawWheel(ctx, cx, cy, radius){
    ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
    const sectors = EU_SEQUENCE.length;
    const step = (Math.PI*2)/sectors;
    // Wheel
    for(let i=0;i<sectors;i++){
      const ang = wheelAngle + i*step;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,radius, ang, ang+step);
      ctx.closePath();
      const n = EU_SEQUENCE[i];
      if(n===0) ctx.fillStyle = '#073b4c';
      else ctx.fillStyle = isRed(n)?'#a11a1a':'#1f2937';
      ctx.fill();
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(ang+step/2);
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillStyle='#e5e7eb';
      ctx.font='bold 12px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
      ctx.fillText(String(n), radius*0.78, 0);
      ctx.restore();
    }
    // Rim
    ctx.beginPath();
    ctx.arc(cx,cy,radius,0,Math.PI*2);
    ctx.lineWidth=6; ctx.strokeStyle='#0f172a'; ctx.stroke();

    // Ball
    const ballR = radius*0.9;
    const bx = cx + Math.cos(ballAngle)*ballR;
    const by = cy + Math.sin(ballAngle)*ballR;
    ctx.beginPath();
    ctx.arc(bx,by,6,0,Math.PI*2);
    ctx.fillStyle='#fbbf24'; ctx.fill();
    ctx.strokeStyle='#111827'; ctx.lineWidth=2; ctx.stroke();
  }

  
  function spinRoulette(callback){
    if(spinning) return;
    const canvas = document.getElementById('rouletteCanvas');
    const msg = document.getElementById('rouletteMsg');
    const ctx = canvas?.getContext('2d');
    if(!canvas || !ctx) return;
    spinning = true;

    const sectors = EU_SEQUENCE.length;
    const step = (Math.PI*2)/sectors;

    // Random fair winning pocket
    const winIndex = Math.floor(Math.random()*sectors);
    const winNumber = EU_SEQUENCE[winIndex];

    // Physics-inspired params
    const totalDuration = 5500 + Math.floor(Math.random()*1800); // ~5.5s–7.3s
    const start = performance.now();

    // Independent angular velocities (rad/s). Ball opposite spin.
    let wheelVel = 6 + Math.random()*2;      // ~6–8 rad/s (CCW)
    let ballVel  = -(16 + Math.random()*6);  // ~-16 to -22 rad/s (CW, opposite)

    // Friction coefficients per second (we'll apply exponentially by dt)
    const wheelFriction = 0.85 + Math.random()*0.04; // effective multiplier per second
    const ballFriction  = 0.78 + Math.random()*0.05; // ball slows faster

    let captured = false;
    let lastT = start;

    function frame(now){
      const elapsed = now - start;
      const dt = Math.max(0.001, (now - lastT) / 1000); // seconds
      lastT = now;

      // Exponential friction (v *= f^(dt))
      wheelVel *= Math.pow(wheelFriction, dt);
      ballVel  *= Math.pow(ballFriction,  dt);

      // Integrate angles
      wheelAngle += wheelVel * dt;
      ballAngle  += ballVel  * dt;

      // Normalize
      if(wheelAngle > Math.PI*2 || wheelAngle < -Math.PI*2) wheelAngle %= (Math.PI*2);
      if(ballAngle  > Math.PI*2 || ballAngle  < -Math.PI*2)  ballAngle  %= (Math.PI*2);

      // Capture phase: once ball slow enough OR near the end
      const nearEnd = elapsed > totalDuration * 0.7;
      if(!captured && (Math.abs(ballVel) < 1.0 || nearEnd)){
        captured = true;
        // From here, steer ball to the target pocket center over the remainder time
        const remain = Math.max(400, totalDuration - elapsed); // at least 0.4s to settle
        const startBallAngle = ballAngle;
        const startWheelAngle = wheelAngle;
        const targetAngle = () => (wheelAngle + winIndex*step + step/2);

        const settleStart = now;
        const settleEnd = now + remain;

        function settleFrame(ts){
          // Update wheel with a gentle tail decel
          const dt2 = Math.max(0.001, (ts - lastT) / 1000);
          lastT = ts;
          wheelVel *= Math.pow(wheelFriction, dt2);
          wheelAngle += wheelVel * dt2;

          const t = Math.min(1, (ts - settleStart) / (settleEnd - settleStart));
          const ease = 1 - Math.pow(1 - t, 3); // easeOutCubic
          const target = targetAngle();

          // Interpolate ball toward target with slight overshoot + damping rattle
          const base = startBallAngle + (target - startBallAngle) * ease;
          const rattle = (1 - t) * 0.06 * Math.sin(18 * t * Math.PI); // decaying small oscillation
          ballAngle = base + rattle;

          drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);
          if(t < 1){
            requestAnimationFrame(settleFrame);
          }else{
            // Snap exactly to pocket center
            ballAngle = target;
            drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);
            spinning = false;
            callback && callback(winNumber);
          }
        }
        requestAnimationFrame(settleFrame);
        return;
      }

      drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);

      if(elapsed < totalDuration){
        requestAnimationFrame(frame);
      }else{
        // Failsafe: ensure we enter capture if somehow skipped
        if(!captured){
          captured = true;
          const target = wheelAngle + winIndex*step + step/2;
          ballAngle = target;
          drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);
        }
        spinning = false;
        callback && callback(winNumber);
      }
    }
    requestAnimationFrame(frame);
  }

  function settleRoulette(win){
    let totalStake = rouletteBets.reduce((s,b)=>s+b.amount,0);
    if((state.money|0) < totalStake){
      pushLog('' + `<span class="logpiece tbad">Insufficient funds (£${totalStake})</span>`);
      const m = document.getElementById('rouletteMsg'); if(m) m.textContent = `You need £${totalStake} to spin.`;
      return false;
    }
    // Pay cost
    changeMoney(-totalStake, 'roulette-stake');
    let totalWin = 0;
    rouletteBets.forEach(b=>{
      if(win!==0 && b.type==='straight' && b.covers.includes(win)) totalWin += b.amount*(PAYOUTS.straight+1);
      else if(win!==0 && b.type==='dozen' && b.covers.includes(win)) totalWin += b.amount*(PAYOUTS.dozen+1);
      else if(win!==0 && b.type==='column' && b.covers.includes(win)) totalWin += b.amount*(PAYOUTS.column+1);
      else if(b.type==='even'){
        // Even-money bets lose on 0
        if(win!==0 && b.covers.includes(win)) totalWin += b.amount*(PAYOUTS.even+1);
      }
    });
    if(totalWin>0) changeMoney(totalWin, 'roulette-payout');
    const net = totalWin - totalStake;
    const resultMsg = net>=0 ? `<span class="tgood">WIN £${totalWin} (net +£${net})</span>` : `<span class="tbad">LOSE (net -£${-net})</span>`;
    pushLog('' + `Roulette — result: <strong>${win}</strong> • ${resultMsg}`);
    const m = document.getElementById('rouletteMsg');
    if(m) m.innerHTML = `Result: <strong>${win}</strong>. ${net>=0?'You won':'You lost'} £${Math.abs(net)}.`;
    // History
    rouletteHistory.unshift(win);
    rouletteHistory = rouletteHistory.slice(0,10);
    const h = document.getElementById('rouletteHistory');
    if(h) h.textContent = rouletteHistory.join(', ');
    // Rebet memory
    rouletteLastBets = rouletteBets.map(x=>Object.assign({},x));
    // Clear current bets
    rouletteBets = [];
    updateRouletteTotals();
    renderPlacedBets();
    updateUI();
    return true;
  }

  function bindRouletteUI(){
    if(rouletteBound) return;
    rouletteBound = true;
    buildRouletteTable();
    bindRouletteTable();
    const spin = document.getElementById('rouletteSpin');
    const clearBtn = document.getElementById('rouletteClear');
    const rebetBtn = document.getElementById('rouletteRebet');
    const canvas = document.getElementById('rouletteCanvas');
    const ctx = canvas?.getContext('2d');
    if(ctx) drawWheel(ctx, canvas.width/2, canvas.height/2, Math.min(canvas.width,canvas.height)/2 - 20);
    if(spin && !spin.dataset.bound){
      spin.addEventListener('click', ()=>{
        if(rouletteBets.length===0){
          const m = document.getElementById('rouletteMsg'); if(m) m.textContent = 'Place at least one bet.';
          return;
        }
        spinRoulette((win)=> settleRoulette(win));
      });
      spin.dataset.bound='1';
    }
    if(clearBtn && !clearBtn.dataset.bound){
      clearBtn.addEventListener('click', ()=>{ rouletteBets = []; updateRouletteTotals(); renderPlacedBets(); const m=document.getElementById('rouletteMsg'); if(m) m.textContent=''; });
      clearBtn.dataset.bound='1';
    }
    if(rebetBtn && !rebetBtn.dataset.bound){
      rebetBtn.addEventListener('click', ()=>{
        rouletteBets = rouletteLastBets.map(x=>Object.assign({},x));
        updateRouletteTotals(); renderPlacedBets();
      });
      rebetBtn.dataset.bound='1';
    }
  }
})();
// ============================================================================
</script>
<script>
// === Canvas Slot Machine (Reel Strip + Timeline Stops, v5) ===================
document.addEventListener('DOMContentLoaded', function(){
  if (window.__slotCanvasInit) return; window.__slotCanvasInit = true;
  const canvas = document.getElementById('slotCanvas');
  const frame = document.getElementById('slotCanvasFrame');
  if(!canvas || !frame) return;
  const ctx = canvas.getContext('2d');
  const wrap = frame.closest('.slotCanvas-wrap');
  let __suppressDemoMsg = false;


  // Geometry (responsive)
  let W = 0, H = 0;
  const reelsCount = 3;
  let reelGap = 18;
  let reelW = 0;
  let reelH = 0;
  let symbolH = 64;
  let spacing = 14;
  let cellH = 64+14;
  let centerY = 0;
  let CENTER_BASE = 0; // align symbol center to payline
  let PAD = 10;
  let offsetX = 0; // horizontal centering offset        // inner vertical padding for the window
  const ASPECT = 140/360; // keep look similar to original

  function recalcGeometry(){
    // Fit canvas width to frame; height from aspect
    const bw = Math.max(0, (frame.getBoundingClientRect?.().width || frame.clientWidth || canvas.clientWidth || 360));
    const targetW = Math.max(340, Math.round(bw));
    const targetH = Math.max(140, Math.round(targetW * ASPECT));
    canvas.width = targetW;
    canvas.height = targetH;
    frame.style.height = targetH + 'px';
    __lastMeasuredW = targetW; __lastMeasuredH = targetH;

    W = targetW; H = targetH;
    reelGap = Math.max(10, Math.round(W * 0.02)); // ~2% of width
    reelW = Math.round((W - reelGap*(reelsCount-1)) / reelsCount);
    reelH = H;
    HPAD = 0; // flush to edges
    const innerW = Math.max(0, W - HPAD*2);
    // Compute reel width from inner window, not full canvas
    reelW = Math.floor((innerW - reelGap*(reelsCount-1)) / reelsCount);
    let used = reelW*reelsCount + reelGap*(reelsCount-1);
    const remainder = Math.max(0, innerW - used);
    // Align to left inner padding; we'll distribute remainder across reels
    offsetX = HPAD;
    window.__slotRemainder = remainder;
    PAD = Math.max(6, Math.round(H * 0.06));      // subtle top/bottom padding
    // Make the fruits fill most of the window height
    symbolH = Math.max(44, Math.round((H - PAD*2) * 0.72));
    spacing = Math.max(6, Math.round((H - PAD*2) * 0.08));
    cellH = symbolH + spacing;
    centerY = Math.floor(H/2);
    CENTER_BASE = PAD + (symbolH/2) - centerY;
  }

  // Simple debounce
  function _debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }


  // Track last measured size to avoid unnecessary work
  let __lastMeasuredW = 0, __lastMeasuredH = 0;

  recalcGeometry();
  window.addEventListener('resize', _debounce(()=>{ recalcGeometry(); }, 80));
  window.addEventListener('orientationchange', ()=>{ setTimeout(recalcGeometry, 50); setTimeout(recalcGeometry, 250); });

  // Use ResizeObserver to react to container resizes (more reliable than window resize)
  try{
    const ro = new ResizeObserver(()=>{ recalcGeometry(); });
    ro.observe(frame);
  }catch(e){ /* older browsers */ }

  // Stage a couple of recalcs after the first paint — helps when layout CSS applies late
  requestAnimationFrame(()=> recalcGeometry());
  setTimeout(()=> recalcGeometry(), 120);
  setTimeout(()=> recalcGeometry(), 400);

// align symbol center to payline

  // Vector fruit drawing
  function drawFruit(kind, x, y, scale=1, blur=0){
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    if(blur>0){ ctx.filter = `blur(${blur}px)`; }
    ctx.lineWidth = 2;
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    if(kind===0){ // cherry
      ctx.fillStyle = '#e11d48'; ctx.beginPath(); ctx.arc(-10,8,10,0,Math.PI*2); ctx.arc(10,8,10,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#16a34a'; ctx.beginPath(); ctx.moveTo(0,-12); ctx.quadraticCurveTo(-10,-24,-20,-8); ctx.quadraticCurveTo(-2,-10,0,-12); ctx.quadraticCurveTo(10,-24,20,-8); ctx.quadraticCurveTo(2,-10,0,-12); ctx.fill(); ctx.stroke();
    }else if(kind===1){ // lemon
      ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.ellipse(0,0,22,16,0,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }else if(kind===2){ // bell
      ctx.fillStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(-18,0); ctx.quadraticCurveTo(-20,-18,0,-22); ctx.quadraticCurveTo(20,-18,18,0); ctx.lineTo(18,8); ctx.quadraticCurveTo(0,16,-18,8); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.fillStyle = '#7c3aed'; ctx.beginPath(); ctx.arc(0,10,5,0,Math.PI*2); ctx.fill();
    }else if(kind===3){ // star
      ctx.fillStyle = '#eab308'; ctx.beginPath();
      for(let i=0;i<5;i++){ const a=(i*72-90)*Math.PI/180; const ax=Math.cos(a)*18, ay=Math.sin(a)*18; const b=a+36*Math.PI/180; const bx=Math.cos(b)*8, by=Math.sin(b)*8; if(i===0) ctx.moveTo(ax,ay); else ctx.lineTo(ax,ay); ctx.lineTo(bx,by); }
      ctx.closePath(); ctx.fill(); ctx.stroke();
     }else if(kind===4){ // seven
      // Option A (default): crisp vector '7' drawn as a filled polygon (no strokes -> no AA glitches)
      if(!window.slotUseEmojiSeven){
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        // shadow for depth
        ctx.shadowColor = 'rgba(0,0,0,0.25)';
        ctx.shadowBlur = 6;
        // red fill
        ctx.fillStyle = '#ef4444';
        ctx.beginPath();
        // Top bar
        ctx.moveTo(-18,-18);
        ctx.lineTo(18,-18);
        // Knee to diagonal
        ctx.lineTo(8,-6);
        // Diagonal leg
        ctx.lineTo(-4,18);
        ctx.lineTo(-14,18);
        // Inner notch to give a classic 7 shape
        ctx.lineTo(-2,-2);
        ctx.lineTo(-18,-2);
        ctx.closePath();
        ctx.fill();

        // subtle highlight
        const g = ctx.createLinearGradient(-18,-20,18,-4);
        g.addColorStop(0,'rgba(255,255,255,0.18)');
        g.addColorStop(1,'rgba(255,255,255,0.0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.moveTo(-18,-18);
        ctx.lineTo(18,-18);
        ctx.lineTo(8,-6);
        ctx.lineTo(-2,-6);
        ctx.closePath();
        ctx.fill();
      } else {
        // Option B: system emoji '7️⃣' (may vary by OS, but some users prefer it)
        ctx.shadowColor = 'rgba(0,0,0,0.30)';
        ctx.shadowBlur = 8;
        ctx.font = '46px system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('7️⃣', 0, 0);
      }
    } else{ // clover
      ctx.fillStyle = '#16a34a'; for(let i=0;i<4;i++){ const a=(i*90)*Math.PI/180; ctx.beginPath(); ctx.arc(Math.cos(a)*10, Math.sin(a)*10, 8, 0, Math.PI*2); ctx.fill(); }
      ctx.fillRect(-4,-2,8,16);
    }
    ctx.restore();
  }

  // Build per-reel strips
  const WEIGHTED = [0,0,0,1,1,2,2,3,4,5,6,7];
  function buildStrip(len=64){
    const strip = [];
    while(strip.length < len){ strip.push(WEIGHTED[Math.floor(Math.random()*WEIGHTED.length)]); }
    for(let s=0;s<8;s++){ if(!strip.includes(s)){ strip[Math.floor(Math.random()*strip.length)] = s; } }
    return strip;
  }
  const STRIPS = Array.from({length:3}, ()=> buildStrip(64));
  const STRIP_LEN = STRIPS[0].length;

  // Mapping between indices and emojis for external sync
  const IDX_TO_EMOJI = ["🍒","🍋","🔔","⭐","7️⃣","🍇","🍉","🍀"];
  const EMOJI_TO_IDX = Object.fromEntries(IDX_TO_EMOJI.map((e,i)=>[e,i]));

  function normalizeOutcomeArray(arr){
    if(!Array.isArray(arr)) return null;
    if(arr.length < 3) return null;
    // If it's numbers:
    if(typeof arr[0] === 'number') return arr.slice(0,3).map(x=> (x|0)%8);
    // If it's strings/emojis:
    return arr.slice(0,3).map(v=> (v in EMOJI_TO_IDX) ? EMOJI_TO_IDX[v] : 0);
  }
  function toEmoji(arr){ return arr.map(i=> IDX_TO_EMOJI[i%8]); }


  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

  class Reel {
    constructor(index){
      this.index = index;
      this.basePos = 0;      // px at spin start
      this.pos = 0;          // px (live)
      this.state = 'idle';
      this.t0 = 0;           // spin start time
      this.tAccel = 0;       // end of accel
      this.tCruise = 0;      // end of cruise
      this.tEnd = 0;         // end of decel (final)
      this.maxVel = 2800 + 200*index; // small variance per reel
      this.blur = 0;
      this.targetSymbol = 0;
      this.targetAbsCell = 0;
      this.posAtDecel = 0;
    }
    currentCell(){
      const cell = Math.floor(((this.pos - CENTER_BASE) / cellH)) % STRIP_LEN;
      return (cell + STRIP_LEN) % STRIP_LEN;
    }
    schedule(now, {delay=0, accelMs=500, cruiseMs=1200, decelMs=900}, targetSymbol, extraTurns){
      this.t0 = now + delay;
      this.tAccel = this.t0 + accelMs;
      this.tCruise = this.tAccel + cruiseMs;
      this.tEnd = this.tCruise + decelMs;
      this.state = 'accel';
      this.blur = 0;
      this.basePos = this.pos;
      this.targetSymbol = targetSymbol;

      // compute landing
      const baseCell = this.currentCell();
      const strip = STRIPS[this.index];
      const startIdx = (baseCell + extraTurns * STRIP_LEN) % STRIP_LEN;
      let found = -1;
      for(let i=0;i<STRIP_LEN;i++){
        const idx = (startIdx + i) % STRIP_LEN;
        if(strip[idx] === targetSymbol){ found = (baseCell + extraTurns*STRIP_LEN + i); break; }
      }
      if(found < 0){ found = baseCell + extraTurns*STRIP_LEN; }
      this.targetAbsCell = found;
      const stopAt = this.pos + (this.targetAbsCell - baseCell) * cellH + CENTER_BASE;
      this.stopAt = stopAt;
      this.posAtDecel = 0; // will capture when decel starts
    }
    isSpinning(){ return this.state !== 'idle'; }
    symbolAtCenter(){
      const cell = Math.round(((this.pos - CENTER_BASE)/cellH)) % STRIP_LEN;
      const idx = (cell + STRIP_LEN) % STRIP_LEN;
      return STRIPS[this.index][idx];
    }
    update(now, dt){
      if(this.state === 'idle') return;
      if(now < this.t0) return; // delay window

      // phase switching
      if(now >= this.tEnd){
        // hard stop
        const cells = Math.round((this.stopAt - CENTER_BASE)/cellH);
        this.pos = cells * cellH + CENTER_BASE;
        this.state = 'idle';
        this.blur = 0;
        return;
      } else if(now >= this.tCruise){
        if(this.state !== 'decel'){
          this.state = 'decel';
          this.posAtDecel = this.pos;
        }
      } else if(now >= this.tAccel){
        this.state = 'cruise';
      }

      // integrate per phase
      if(this.state === 'accel'){
        // accelerate up to maxVel
        const k = Math.min(1, (now - this.t0) / (this.tAccel - this.t0));
        const v = this.maxVel * k;
        this.pos += v * dt;
        this.blur = Math.min(1.4, this.blur + 2.0*dt);
      } else if(this.state === 'cruise'){
        const v = this.maxVel;
        this.pos += v * dt;
        this.blur = 1.2;
      } else if(this.state === 'decel'){
        const p = Math.min(1, (now - this.tCruise) / (this.tEnd - this.tCruise));
        const eased = easeOutCubic(p);
        const target = this.stopAt;
        const start = this.posAtDecel;
        this.pos = start + (target - start) * eased;
        this.blur = Math.max(0, 1.2 * (1 - eased));
      }

      const loop = cellH * STRIP_LEN;
      if(this.pos > 1e9) this.pos = this.pos % loop; // keep number sane
    }
    draw(x, w = reelW){
      const reelHLocal = reelH;
      ctx.save();
      ctx.beginPath();
      ctx.roundRect(x, 10, reelW, reelHLocal-20, 10);
      ctx.clip();

      // bg per reel
      const grad = ctx.createLinearGradient(0,PAD,0,reelHLocal-PAD);
      grad.addColorStop(0,'#101a36'); grad.addColorStop(1,'#0a1128');
      ctx.fillStyle = grad; ctx.fillRect(x,PAD,w,reelHLocal-(PAD*2));

      const base = ((this.pos % (cellH*STRIP_LEN)) + (cellH*STRIP_LEN)) % (cellH*STRIP_LEN);
      const firstCell = Math.floor((base - 10)/cellH) - 2;
      const lastCell  = firstCell + Math.ceil((reelHLocal+40)/cellH) + 2;
      for(let k=firstCell; k<=lastCell; k++){
        const y = Math.floor(-base + k*cellH + PAD);
        const idx = (k % STRIP_LEN + STRIP_LEN) % STRIP_LEN;
        const blur = this.blur>0.05 ? this.blur : 0;
        drawFruit(STRIPS[this.index][idx], x + w/2, y + symbolH/2, 1, blur);
      }
      ctx.restore();
      // rim shadow
      const g = ctx.createLinearGradient(x,0,x+w,reelHLocal);
      g.addColorStop(0, 'rgba(0,0,0,0.35)');
      g.addColorStop(0.08, 'rgba(0,0,0,0)');
      g.addColorStop(0.92, 'rgba(0,0,0,0)');
      g.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle = g; ctx.fillRect(x,0,w,reelHLocal);
    }
  }

  const reels = [...Array(reelsCount)].map((_,i)=> new Reel(i));

  // Money + UI helpers (with safe fallbacks)
  function getBet(){
    const el = document.getElementById("betInput");
    const n = Math.max(1, Math.floor(Number(el?.value||1)));
    if(el) el.value = n;
    const spinCost = document.getElementById("spinCost");
    if(spinCost) spinCost.textContent = String(n);
    return n;
  }
  function getMoney(){ try{ return (window?.state?.money|0) || 0; }catch(e){ return 0; } }
  function changeMoneySafe(delta, reason){
    try{ if(typeof window.changeMoney === "function"){ window.changeMoney(delta, reason); return; } }catch(e){}
    window.state = window.state || {}; window.state.money = (getMoney() + delta);
  }
  function updateGambleUI(){
    const b = document.getElementById("gambleBalance"); if(b) b.textContent = String(getMoney());
  }
  function setMsg(txt){
    const m = document.getElementById("slotMsg"); if(m) m.textContent = txt;
  }

  // Continuous RAF
  let last = performance.now();
  function rafLoop(now){
    // auto-correct geometry if frame size drifted
    const cw = Math.round(frame.getBoundingClientRect?.().width || frame.clientWidth || canvas.clientWidth || 0);
    const ch = Math.round(cw * ASPECT);
    if(cw && (cw !== __lastMeasuredW || ch !== __lastMeasuredH)){
      __lastMeasuredW = cw; __lastMeasuredH = ch;
      recalcGeometry();
    }
    const dt = Math.min(0.033, (now - last)/1000); last = now;
    for(const r of reels) r.update(now, dt);
    // backdrop
    const bg = ctx.createLinearGradient(0,0,0,H);
    bg.addColorStop(0,'#0b132a'); bg.addColorStop(1,'#0a0f22');
    ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);
    // reels
    
    let accX = offsetX;
    let rem = window.__slotRemainder|0;
    const baseExtra = Math.floor(rem / reelsCount);
    let mod = rem % reelsCount;
    for(let i=0;i<reelsCount;i++){
      const extra = baseExtra + (mod>0 ? 1 : 0);
      if(mod>0) mod--;
      const w = reelW + extra;
      reels[i].draw(accX, w);
      accX += w + reelGap;
    }

    // payline
    ctx.fillStyle = 'rgba(255,255,255,0.06)'; ctx.fillRect(0, centerY-1, W, 2);
    requestAnimationFrame(rafLoop);
  }
  requestAnimationFrame(rafLoop);

  function startSpin(demo=false){
    if(reels.some(r=> r.isSpinning())) return;
    const bet = getBet(), money = getMoney();
    let charge = false;
    if(!demo){
      if(money >= bet){ charge = true; }
      else demo = true;
    }
    if(charge){ changeMoneySafe(-bet, 'slot-reel-bet'); updateGambleUI(); }
    if(!(demo && __suppressDemoMsg)) setMsg(demo ? 'Demo spin…' : 'Spinning…');
    try{ wrap && wrap.classList.add('slot-pending'); }catch(e){}

    // Targets per reel (prefer external outcome if provided)
    let targets;
    const takePending = pendingOutcome; pendingOutcome = null;
    if(takePending){ targets = takePending; }
    else if(Array.isArray(window.slotOutcome)){ targets = normalizeOutcomeArray(window.slotOutcome); window.slotOutcome = null; }
    else if(typeof window.getFruitMachineOutcome === 'function'){ try{ targets = normalizeOutcomeArray(window.getFruitMachineOutcome()); }catch(e){} }
    if(!targets){
      const pool = [0,0,0,1,1,2,2,3,4,5,6,7];
      targets = [0,1,2].map(()=> pool[Math.floor(Math.random()*pool.length)]);
    }
const now = performance.now();
    const delays = [0, 150, 300];
    const cfgs = [
      { delay:delays[0], accelMs:520, cruiseMs:1200, decelMs:900 },
      { delay:delays[1], accelMs:520, cruiseMs:1400, decelMs:960 },
      { delay:delays[2], accelMs:520, cruiseMs:1600, decelMs:1020 },
    ];
    const turns = [6,7,8];
    for(let i=0;i<reelsCount;i++){
      reels[i].schedule(now, cfgs[i], targets[i], turns[i]);
    }

    // Finalize on stop (poll with absolute timeout)
    const tHardEnd = now + 10000; // 10s hard cap
    const poll = setInterval(()=>{
      const allIdle = reels.every(r=> !r.isSpinning());
      const over = performance.now() >= tHardEnd;
      if(allIdle || over){
        clearInterval(poll);
        // Force idle if timeout
        if(over){
          for(const r of reels){ r.state='idle'; r.blur=0; }
          setMsg('Recovered from long spin.');
        }
        if(!demo){
          const a = reels[0].symbolAtCenter(), b = reels[1].symbolAtCenter(), c = reels[2].symbolAtCenter();
          const bet2 = getBet();
          if(a===b && b===c){
            const mult = (a===4) ? 20 : (a===3 ? 10 : (a===2 ? 6 : 4));
            const win = mult * bet2; changeMoneySafe(win, "slot-win"); setMsg(`WIN! pays ${mult}× (£${win}).`); flashWin();
          } else if(a===b || b===c || a===c){
            const pair = a===b ? a : (b===c ? b : a);
            const mult = (pair===4) ? 3 : (pair===3 ? 2 : 1);
            const win = mult * bet2; changeMoneySafe(win, "slot-pair"); setMsg(`Pair! pays ${mult}× (£${win}).`); flashWin();
          } else if(a===0){
            changeMoneySafe(bet2, "slot-refund"); setMsg("Cherry up front! Bet refunded.");
          } else {
            setMsg("No win this time.");
          }
          updateGambleUI();
          try{ wrap && wrap.classList.remove('slot-pending'); }catch(e){} __suppressDemoMsg = false;
          __suppressDemoMsg = false;
          if(typeof window.onSlotResult === 'function'){
            try{ window.onSlotResult([a,b,c].map(x=> IDX_TO_EMOJI[x] ?? x)); }catch(e){}
          }
        } else {
          if(!__suppressDemoMsg) setMsg('Add credits to play for real.');
        try{ wrap && wrap.classList.remove('slot-pending'); }catch(e){} __suppressDemoMsg = false;
          __suppressDemoMsg = false;
        }
      }
    }, 80);
  }

  function flashWin(){
    frame.classList.remove('win'); void frame.offsetWidth; frame.classList.add('win');
    setTimeout(()=> frame.classList.remove('win'), 900);
  }

  // Buttons
  const spinBtn = document.getElementById('spinBtn');
  const autoBtn = document.getElementById('spinAutoBtn');
  /* unified: Spin button bound in main UI (doSlotSpin). Canvas won't bind it here. */
autoBtn?.addEventListener('click', async ()=>{
    for(let i=0;i<10;i++){
      startSpin(false);
      while(reels.some(r=> r.isSpinning())){ await new Promise(r=> setTimeout(r, 60)); }
      if(getMoney() < getBet()) break;
      await new Promise(r=> setTimeout(r, 140));
    }
  });

  // Credits fallback + auto demo
  if(typeof window.state === 'undefined'){ window.state = { money: 20 }; }
  if(getMoney() < 1){ window.state.money = 20; }
  updateGambleUI(); getBet();
  setTimeout(()=> startSpin(true), 500);

  // Expose API for external sync
  let pendingOutcome = null;
  function spinWithOutcome(outcome, opts={}){
    __suppressDemoMsg = !!opts.visualOnly;
    pendingOutcome = normalizeOutcomeArray(outcome);
    const visualOnly = !!opts.visualOnly;
    startSpin(visualOnly);
  }
  function visualSpin(outcome){ spinWithOutcome(outcome, {visualOnly:true}); }
  window.slot = { startSpin, spin: spinWithOutcome, visualSpin, reels, STRIPS, cellH, toEmoji, normalizeOutcomeArray };
  // === Activity Log Sync (passive) ======================================
  // Drive the canvas to match the Activity Log. We watch for new entries
  // that contain "Fruit machine" and parse the three symbols, then run a
  // visual-only spin to those outcomes (no balance or payouts changed).
  (function(){
    const EMOJI_SET = ["🍒","🍋","🔔","⭐","7️⃣","🍇","🍉","🍀"];
    const NUM_TO_SEVEN = {'7': '7️⃣'};
    let lastKey = null;
    let lastAt = 0;

    function extractTripleFromText(text){
      const m = text.match(/Fruit machine[\s\S]*?([🍒🍋🔔⭐7️⃣🍇🍉🍀7])[\s,]+([🍒🍋🔔⭐7️⃣🍇🍉🍀7])[\s,]+([🍒🍋🔔⭐7️⃣🍇🍉🍀7])/i);
      if(!m) return null;
      const arr = [m[1], m[2], m[3]].map(ch => NUM_TO_SEVEN[ch] || ch);
      if(!arr.every(x => EMOJI_SET.includes(x))) return null;
      return arr;
    }

    function scanAndSpin(){
      try{ if(reels && reels.some(r=> r.isSpinning())) return; }catch(e){}
// find the latest node containing "Fruit machine"
      const nodes = Array.from(document.querySelectorAll('body *')).filter(el => el.childElementCount === 0 && /Fruit machine/i.test(el.textContent||""));
      if(nodes.length === 0) return;
      const lastNode = nodes[nodes.length - 1];
      const text = lastNode.closest('*')?.textContent || lastNode.textContent || "";
      const trip = extractTripleFromText(text);
      if(!trip) return;
      const key = trip.join('|');
      const now = performance.now();
      if(key === lastKey && now - lastAt < 1500) return; // ignore duplicates
      lastKey = key; lastAt = now;
      // Spin visuals only to match the log outcome
      try{ visualSpin(trip); }catch(e){ /* no-op */ }
    }

    const mo = new MutationObserver((mutations) => {
      for(const m of mutations){
        if(m.type === 'childList' && (m.addedNodes?.length || m.removedNodes?.length)){
          scanAndSpin();
        } else if(m.type === 'characterData'){
          scanAndSpin();
        }
      }
    });
    mo.observe(document.body, { childList: true, characterData: true, subtree: true });

    // Initial attempt (in case the log is already present)
    setTimeout(scanAndSpin, 500);
  })();
  // ======================================================================


});
// ============================================================================
</script>
<script>
// === Delay 'Fruit machine' Activity Log until reels settle =====================
(function(){
  if(window.__slotLogDelay) return; window.__slotLogDelay = true;
  const FRUIT_RE = /Fruit machine\b/i;
  const EM_TRIPLE_RE = /([🍒🍋🔔⭐7️⃣🍇🍉🍀7])\s+([🍒🍋🔔⭐7️⃣🍇🍉🍀7])\s+([🍒🍋🔔⭐7️⃣🍇🍉🍀7])/;
  const toSeven = {'7':'7️⃣'};
  const queue = [];
  let waiting = false;

  function enqueue(entry){
    queue.push(entry);
    if(!waiting){
      waiting = true;
      const once = (ev)=>{ try{ flush(); }finally{ window.removeEventListener('slot-settled', once); waiting=false; } };
      window.addEventListener('slot-settled', once, { once:true });
      // Hard fallback after 6s to avoid losing logs
      setTimeout(()=>{ if(waiting){ flush(); waiting=false; } }, 6000);
    }
  }
  function flush(){
    const _orig = window.__origPushLog;
    while(queue.length){ try{ _orig(queue.shift()); }catch(e){ break; } }
  }

  // Hook pushLog
  if(typeof window.pushLog === 'function' && !window.__origPushLog){
    window.__origPushLog = window.pushLog;
    window.pushLog = function(entry){
      const raw = (typeof entry==='string') ? entry : (entry && (entry.html||entry.text)||'');
      if(FRUIT_RE.test(String(raw))){
        enqueue(entry);
        // in case canvas didn't get a visual outcome yet, try to extract and drive
        try{
          const t = String(raw).replace(/<[^>]+>/g,'');
          const m = t.match(EM_TRIPLE_RE);
          if(m && window.slot && typeof window.slot.visualSpin === 'function'){
            const trip = [m[1],m[2],m[3]].map(ch=> toSeven[ch] || ch);
            window.slot.visualSpin(trip);
          }
        }catch(e){}
        return;
      }
      return window.__origPushLog.apply(this, arguments);
    };
  }
})();
// ==============================================================================
</script>
<script id="slot-debug-addon">
(function(){
  // Build a readable description of the current slot state
  function makeSlotDebugDesc(){
    try{
      const s = window.slot || {};
      const ctx = window.__slotCtx || {};
      // Safely find internals if available in closure scope via known globals we set
      const reels = window.slotReels || (typeof getReels === 'function' ? getReels() : null);
      const IDX = (window.IDX_TO_EMOJI || ["🍒","🍋","🔔","⭐","7️⃣","🍇","🍉","🍀"]);
      const parts = [];

      if (reels && reels.length) {
        const symbols = reels.map(r => IDX[r.symbolAtCenter?.() ?? 0]).join(' ');
        parts.push(`payline: ${symbols}`);
        parts.push(reels.map((r,i)=>{
          const cell = (typeof r.currentCell==='function') ? r.currentCell() : '?';
          const tgt  = (r.targetAbsCell!=null) ? (r.targetAbsCell % (window.STRIP_LEN||64)) : '?';
          const st   = r.state || 'idle';
          return `R${i+1}{st:${st},cell:${cell},tgt:${tgt}}`;
        }).join(' · '));
      } else if (s.getLastResult) {
        parts.push(`payline: ${(s.getLastResult()||[]).join(' ')}`);
      } else {
        parts.push('payline: (unavailable)');
      }

      // Include basic geometry if exposed
      if (typeof window.slotGeom === 'function') {
        const g = window.slotGeom();
        parts.push(`W×H:${g.W}×${g.H} reelW:${g.reelW} gap:${g.reelGap}`);
      }

      return `Fruit machine debug → ${parts.join(' | ')}`;
    }catch(e){
      return `Fruit machine debug → (error generating description: ${e&&e.message})`;
    }
  }

  // Expose on the slot API
  window.slot = window.slot || {};
  window.slot.debugDescription = makeSlotDebugDesc;

  // Optional helper to fetch geometry if the slot code exported it
  if (!window.slot.slotGeom && typeof window.slotGeom === 'function') {
    window.slot.slotGeom = window.slotGeom;
  }

  // Hook a Debug button if present
  function bindDebugButton(){
    var btn = document.getElementById('debugBtn') || document.querySelector('[data-debug-button]');
    if(!btn) return;
    if(btn.__slotDebugBound) return;
    btn.__slotDebugBound = true;
    btn.addEventListener('click', function(){
      var text = makeSlotDebugDesc();
      try{
        if (typeof window.pushLog === 'function') {
          pushLog({ html: `🔧 ${text}` });
        } else {
          console.log(text);
          try { alert(text); } catch(e){}
        }
      }catch(e){
        console.log(text);
      }
    }, false);
  }

  // Try now and also after load
  bindDebugButton();
  document.addEventListener('DOMContentLoaded', bindDebugButton);
  setTimeout(bindDebugButton, 500);
})();
</script>
<!-- affordability-guard v1 -->
<style>
/* Visual + interaction lock when unaffordable */
#spinBtn[disabled], #spinAutoBtn[disabled],
#spinBtn[aria-disabled="true"], #spinAutoBtn[aria-disabled="true"]{
  opacity: .6; cursor: not-allowed; pointer-events: none;
}

/* Locked/disabled tier buttons */
.btn.disabled, .btn:disabled {
  opacity: 0.45;
  cursor: not-allowed;
  filter: grayscale(0.6);
  box-shadow: none;
}
.btn.disabled:focus, .btn:disabled:focus { outline: none; }

</style>
<script>
/* Fruit Machine Affordability Guard (v1.5)
   - Drives disabled state from the UI balance (#gambleBalance) and bet input (#betInput)
   - Very light: a single MutationObserver on #gambleBalance text and an input listener on #betInput
   - Still blocks programmatic spin paths (doSlotSpin/startSpin/visualSpin) if unaffordable
*/
(function(){
  function getBetAmount(){
    const el = document.getElementById('betInput');
    let v = Number(el && el.value);
    if(!Number.isFinite(v)) v = 1;
    return Math.max(1, Math.floor(v));
  }
  function getUiMoney(){
    const el = document.getElementById('gambleBalance');
    const n = Number(el && el.textContent);
    return Number.isFinite(n) ? n : 0;
  }
  function canAfford(){ return getUiMoney() >= getBetAmount(); }
  function setDisabled(el, v){
    if(!el) return;
    // only change if needed (avoid loops)
    if(!!el.disabled !== !!v){ el.disabled = !!v; }
    const want = v ? 'true' : 'false';
    if(el.getAttribute('aria-disabled') !== want){ el.setAttribute('aria-disabled', want); }
    if(v){ el.tabIndex = -1; } else { el.tabIndex = 0; }
  }
  function updateButtons(){
  const spinBtn = document.getElementById('spinBtn');
  const autoBtn = document.getElementById('spinAutoBtn');
  const afford = canAfford();
  // Keep Spin clickable for demo spins; only disable Auto.
  setDisabled(autoBtn, !afford);
  if(spinBtn){
    // subtle styling/title to hint it's a demo when broke
    try{ spinBtn.classList.toggle('secondary', !afford); }catch(e){}
    try{ spinBtn.title = afford ? '' : 'Demo spin (free)'; }catch(e){}
  }
}

  // Keep buttons in sync with UI balance & bet changes
  function bindObservers(){
    const bal = document.getElementById('gambleBalance');
    if(bal && !bal.__obs){
      const obs = new MutationObserver(updateButtons);
      obs.observe(bal, { characterData: true, subtree: true, childList: true });
      bal.__obs = obs;
    }
    const bet = document.getElementById('betInput');
    if(bet && !bet.__bound){
      bet.addEventListener('input', updateButtons);
      bet.__bound = true;
    }
  }

  // Belt-and-braces: block programmatic spins
  function wrapEntryPoints(){
  try{
    if(typeof window.doSlotSpin === 'function' && !window.doSlotSpin.__wrapped){
      const _f = window.doSlotSpin;
      window.doSlotSpin = function(){
        // Allow user-initiated clicks to demo-spin when broke,
        // but still block programmatic spins without funds.
        const now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
        const recentGesture = (window.__lastUserGestureAt && (now - window.__lastUserGestureAt) < 1200);
        if(!canAfford() && !recentGesture){ return; }
        return _f.apply(this, arguments);
      };
      window.doSlotSpin.__wrapped = true;
    }
if(typeof window.doAutoSpins === 'function' && !window.doAutoSpins.__wrapped){
        const _a = window.doAutoSpins;
        window.doAutoSpins = function(n){
          if(!canAfford()){ return; }
          return _a.apply(this, arguments);
        };
        window.doAutoSpins.__wrapped = true;
      }
      if(typeof window.startSpin === 'function' && !window.startSpin.__wrapped){
        const _s = window.startSpin;
        window.startSpin = function(demo){
          if(!canAfford()){ return; }
          return _s.apply(this, arguments);
        };
        window.startSpin.__wrapped = true;
      }
      if(window.slot && typeof window.slot.visualSpin === 'function' && !window.slot.visualSpin.__wrapped){
        const _v = window.slot.visualSpin;
        window.slot.visualSpin = function(){
          if(!canAfford()){ return; }
          return _v.apply(this, arguments);
        };
        window.slot.visualSpin.__wrapped = true;
      }
    }catch(e){}
  }

  
function restoreTBLog(){
  try{
    if(window.__tbLogRestored) return;
    const el = document.getElementById('tbLog'); if(!el) return;
    let hist = (state.territory && state.territory.logHistory) || [];
    
    // Fallback: if no dedicated history, reconstruct recent battle lines from global Activity Log
    let list = hist;
    try{
      if((!hist || hist.length===0) && Array.isArray(state.log)){
        const cand = [];
        for(const it of state.log){
          const raw = (it && (it.html || it.text || '')).toString();
          if(/Wave\s+\d+\s*:/.test(raw) || /Tier\s+\d+\s+cleared/.test(raw) || /Region captured!/.test(raw)){
            cand.push({ ts: (it.ts||''), html: it.html || it.text });
            if(cand.length>=50) break;
          }
        }
        list = cand.reverse();
      }
    }catch(_){}

    if(list && list.length){
      const empty = document.getElementById('logEmpty'); if(empty){ empty.classList.add('hidden'); }
      // render oldest -> newest so that future tbLog() prepend keeps order
      for(const item of list){
        const li = document.createElement('li'); li.className='li';
        const ts = item.ts ? `<span class="ts">[${item.ts}]</span>` : '';
        li.innerHTML = ts + (item.html || '');
        el.appendChild(li);
      }
    }
    window.__tbLogRestored = true;
  }catch(e){}
}

function init(){
    bindObservers();
    updateButtons();
    wrapEntryPoints(); restoreTBLog(); }

  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', init);
  }else{
    init();
  }

  // Also re-run when the game's updateUI ticks
  try{
    const prev = window.updateUI;
    if(typeof prev === 'function' && !window.__affordHook){
      window.__affordHook = true;
      window.updateUI = function(){
        const r = prev.apply(this, arguments);
        try{ updateButtons(); wrapEntryPoints(); }catch(e){}
        return r;
      };
    }
  }catch(e){}
})();

// === Territory Battle & Combat Stats =======================================
(function(){
  // Extend default stats to include Strength and Toughness
  try{
    if(Array.isArray(DEFAULT_STATS)){
      if(!DEFAULT_STATS.includes('Strength')) DEFAULT_STATS.unshift('Strength');
      if(!DEFAULT_STATS.includes('Toughness')) DEFAULT_STATS.splice(1,0,'Toughness');
    }
  }catch(e){}

  // Extend equipped buff totals with strength/toughness adds
  const _origGetBuffs = typeof getEquippedBuffTotals === 'function' ? getEquippedBuffTotals : null;
  window.getEquippedBuffTotals = function(){
    const t = _origGetBuffs ? _origGetBuffs() : { moneyMult:0, heatGainMult:0, heatDecayMult:0, successAdd:{}, statXpMult:{} };
    t.strAdd = 0; t.toughAdd = 0;
    try{
      const items = getEquippedItems();
      for(const it of items){
        const mods = Array.isArray(it?.mods) ? it.mods : [];
        for(const m of mods){
          if(!m || typeof m!=='object') continue;
          if(m.kind==='strAdd') t.strAdd += Number(m.value)||0;
          if(m.kind==='toughAdd') t.toughAdd += Number(m.value)||0;
        }
      }
    }catch(e){}
    return t;
  };

  function getDerivedCombat(){
    const baseStr = (state.stats['Strength']?.level||0);
    const baseTgh = (state.stats['Toughness']?.level||0);
    const buffs = getEquippedBuffTotals();
    const strength = Math.max(0, Math.floor(baseStr + (buffs.strAdd||0)));
    const toughness = Math.max(0, Math.floor(baseTgh + (buffs.toughAdd||0)));
    const power = strength; // simple NGU-like: power == strength
    const hpMax = Math.max(30, power * 3);
    const regen = Math.max(0, toughness * 0.03); // HP per sec
    return { strength, toughness, power, hpMax, regen };
  }
  window.getDerivedCombat = getDerivedCombat;

  // Passive health regen (very slow, boosted by toughness)
  const PASSIVE_BASE = 0.01; // % per sec
  function passiveHealthRegen(dtSec){
    try{
      const { toughness } = getDerivedCombat();
      const bonusPctPerSec = Math.min(0.04, toughness * 0.001); // +0.1% per 100 toughness, cap +4%
      const pct = (PASSIVE_BASE + bonusPctPerSec) * dtSec * (state.vitals.health<100?1:0);
      if(pct>0){ addHealth(pct); }
    }catch(e){}
  }

  // Territory state (non-persistent)
  state.territory = state.territory || { tier:1, wave:1, active:false, enemy:null, lootQueue: [] };

  const ENEMY_NAMES = ['Street Thug','Rowdy Hooligan','Rival Grunt','Shifty Mugger','Pushy Enforcer','Crooked Brawler'];

  
  // Scale enemy by tier 1..6 and wave 1..10
  function scaleEnemy(tier, wave){
    const w = Math.max(1, Math.min(10, wave|0));
    const t = Math.max(1, Math.min(6, tier|0));
    const basePow = 1 + (t-1)*5;
    const baseTgh = Math.max(0, (t-1)*4);
    const Mmax = 1.6 + (t-1)*0.2;
    const k = 0.34;
    const M_e = 1 + (Mmax-1) * (1 - Math.exp(-k * (w-1)));
    const pow = Math.max(1, Math.round(basePow * M_e + 0.5*(w-1)));
    const tgh = Math.max(0, Math.round(baseTgh + 0.6*(w-1)));
    const L = (t-1)*10 + w;
    const name = ENEMY_NAMES[(L + pow + tgh) % ENEMY_NAMES.length];
    return { name, power: pow, strength: pow, toughness: tgh };
  }


  function simulateDuel(you, foe){
    // NGU-like: per-second hits; damage is (power - toughness) floored at 1
    const yourHPmax = Math.max(30, you.power * 3);
    const foeHPmax = Math.max(3, foe.power * 3);
    const yourRegen = you.toughness * 0.03;
    const foeRegen = foe.toughness * 0.03;

    const yourRaw = Math.max(1, you.power - foe.toughness);
    const foeRaw  = Math.max(1, foe.power - you.toughness);

    const yourDPS = Math.max(0, yourRaw - foeRegen);
    const foeDPS  = Math.max(0,   foeRaw - yourRegen);

    const tKillFoe = (yourDPS>0) ? (foeHPmax / yourDPS) : Infinity;
    const tKillYou = (foeDPS>0)  ? (yourHPmax / foeDPS) : Infinity;

    const youWin = tKillFoe <= tKillYou;
    const time = Math.min(tKillFoe, tKillYou);
    const youDamage = Math.min(yourHPmax, foeDPS * time);
    const foeDamage = Math.min(foeHPmax, yourDPS * time);
    return { youWin, time, youDamage, foeDamage, yourHPmax, foeHPmax, yourDPS, foeDPS, yourRaw, foeRaw };
  }

  function tbLog(line){ 
    const ts = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    try{
    const el = document.getElementById('tbLog'); if(!el) return;
    const ts = new Date().toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
    const li = document.createElement('li'); li.className='li';
    li.innerHTML = `<span class="ts">[${ts}]</span>${line}`;
    el.prepend(li);
    const empty = document.getElementById('logEmpty'); if(empty){ empty.classList.add('hidden'); }
  }catch(e){} 

// Persist to history so logs survive refresh
try{
  state.territory = state.territory || {};
  const hist = state.territory.logHistory = state.territory.logHistory || [];
  hist.unshift({ ts, html: line });
  if(hist.length > 200) hist.length = 200;
  if(typeof scheduleSave === 'function'){ scheduleSave(); }
  try{ if(typeof saveGame==='function') saveGame({ silent: true }); }catch(e){}

  try{ if(typeof pushLog==='function'){ pushLog({ html: line }); } }catch(e){}
}catch(_){}
}

  function renderTB(){ renderMap(); renderTBDebug();
    try{
      const msg = document.getElementById('tbMsg');
      const waveEl = document.getElementById('tbWave');
      const hb = document.getElementById('tbHealthBar');
      const hpct = document.getElementById('tbHealthPct');

      const you = getDerivedCombat();
      const foe = state.territory.enemy || scaleEnemy(state.territory.tier, state.territory.wave);

      document.getElementById('tbYouStr').textContent = you.strength;
      document.getElementById('tbYouTgh').textContent = you.toughness;
      document.getElementById('tbYouPow').textContent = you.power;
      document.getElementById('tbEnemyName').textContent = foe.name;
      document.getElementById('tbEnemyStr').textContent = foe.strength;
      document.getElementById('tbEnemyTgh').textContent = foe.toughness;
      document.getElementById('tbEnemyPow').textContent = foe.power;

      if(waveEl) waveEl.textContent = String(state.territory.wave);
      // Show simulated player HP during an active battle; otherwise show real vitals
let playerPct = (state.vitals.health||0);
if(state.territory && state.territory.battle && state.territory.battle.youHPMax>0){
  playerPct = Math.max(0, Math.min(100, Math.round((state.territory.battle.youHP / state.territory.battle.youHPMax) * 100)));
// Update battle progress bar
try{
  const pbar = document.getElementById('tbBattleProgBar');
  const ptxt = document.getElementById('tbBattleProgText');
  if(pbar && ptxt){
    let pct = 0;
    let txt = 'Ready';
    const b = state.territory && state.territory.battle;
    if(b && b.active && b.durationMs && b.startMs){
      const elapsed = Math.max(0, performance.now() - b.startMs);
      const t = Math.max(0, Math.min(1, elapsed / b.durationMs));
      pct = Math.round(t * 100);
      const left = Math.max(0, b.durationMs - elapsed) / 1000;
      txt = left.toFixed(1) + 's left';
    
try{ setTierButtons(state.territory && state.territory.tier || 1); }catch(e){}
}
    pbar.style.width = pct + '%';
    ptxt.textContent = txt;
  }
}catch(e){}

}
if(hb) hb.style.width = playerPct + '%';
if(hpct) hpct.textContent = (Number(playerPct).toFixed(0) + '%');

      
// Update enemy health bar (progress view)
try{
  const ehb = document.getElementById('tbEnemyHealthBar');
  const ehpct = document.getElementById('tbEnemyHealthPct');
  if(ehb && ehpct){
    let pct = 100;
    if(state.territory && state.territory.battle && state.territory.battle.enemyHPMax>0){
      pct = Math.max(0, Math.min(100, Math.round((state.territory.battle.enemyHP / state.territory.battle.enemyHPMax) * 100)));
    }
    ehb.style.width = pct + '%';
    ehpct.textContent = (Number(pct).toFixed(0) + '%');
  }
}catch(e){}
if(msg){
        const outf = simulateDuel(you, foe);
        const pwin = isFinite(outf.yourDPS) && isFinite(outf.foeDPS) && outf.yourDPS>0 ? (1) : (outf.youWin?1:0);
        msg.textContent = outf.youWin
          ? `Odds look good: est. TTK ${outf.time.toFixed(1)}s; you take ~${Math.round(100*outf.youDamage/outf.yourHPmax)}% damage if you win.`
          : `Careful: est. loss in ${outf.time.toFixed(1)}s; enemy would deal ~${Math.round(100*outf.youDamage/outf.yourHPmax)}% of your max HP.`;
      }
    }catch(e){}
  }
  window.renderTerritoryBattle = renderTB;

  function startOrNextWave(){
    if(state.vitals.health <= 0){
      tbLog('You are too injured. Heal up first.');
      return;
    }
    if(state.territory.active){ 
      // already active; treat as skip to result
    }
    const foe = scaleEnemy(state.territory.tier, state.territory.wave);
    state.territory.enemy = foe;
    const you = getDerivedCombat();
    const result = simulateDuel(you, foe);
    if(result.youWin){
      const dmgPct = Math.round((result.youDamage / result.yourHPmax) * 100);
      if(dmgPct >= (state.vitals.health||0)){
      // Too injured to survive the fight; count as a loss
      addHealth(-100);
      tbLog(`Wave ${state.territory.wave}: You tried to fight the <strong>${foe.name}</strong> but passed out from injuries.`);
    }else{
      addHealth(-dmgPct);
      }
      tbLog(`Wave ${state.territory.wave}: You beat the <strong>${foe.name}</strong>. Took <strong class="tbad">-${dmgPct}%</strong> health.`);
      maybeDropLoot(state.territory.tier, state.territory.wave);
      if(state.territory.wave < 10){
        state.territory.wave += 1;
      }else{
        tbLog(`<strong>Tier ${state.territory.tier} cleared!</strong> Tougher foes await.`);
        state.territory.wave = 1;
        state.territory.tier = Math.min(2, state.territory.tier + 1);
        // Update tier buttons
        setTierButtons(state.territory.tier);
      }
    }else{
      addHealth(-100);
      tbLog(`Wave ${state.territory.wave}: You were defeated by the <strong>${foe.name}</strong>.`);
    }
    renderTB(); scheduleSave(); renderLootList(); updateUI(); scheduleSave();
  }

  
  function renderLootList(){
    const list = document.getElementById('tbLootList');
    const empty = document.getElementById('tbLootEmpty');
    if(!list) return;
    const q = state.territory.lootQueue || [];
    if(empty) empty.classList.toggle('hidden', q.length>0);
    list.innerHTML = q.map((it, idx) => {
      const isStr = (it.mods && it.mods[0] && it.mods[0].kind === 'strAdd');
      const val = it.mods && it.mods[0] ? it.mods[0].value : 0;
      const stat = isStr ? ('+'+val+' Strength') : ('+'+val+' Toughness');
      return `
        <li class="li" data-idx="${idx}">
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <span class="pill ${it.rarity||'common'}">${it.rarity||'common'}</span>
            <strong>${escapeHtml(it.name)}</strong>
            <span class="muted small">Slot: ${escapeHtml(it.slot||'—')}</span>
            <span class="pill">${stat}</span>
            <span class="grow"></span>
            <button class="btn" data-claim="${idx}">Transfer</button>
            <button class="btn secondary" data-discard="${idx}">Discard</button>
          </div>
        </li>`;
    }).join('');

    // Bind buttons
    list.querySelectorAll('[data-claim]').forEach(btn=>{
      if(btn.dataset.bound) return;
      btn.addEventListener('click', ()=>{
        const idx = Number(btn.getAttribute('data-claim'));
        const item = (state.territory.lootQueue||[])[idx];
        if(!item) return;
        if(!hasInventorySpace(1)){ tbLog('Inventory full. Free up a slot.'); return; }
        state.inventory.push(item);
        state.territory.lootQueue.splice(idx,1);
        tbLog(`Transferred <strong>${escapeHtml(item.name)}</strong> to inventory.`);
        renderLootList(); scheduleSave(); updateUI();
      });
      btn.dataset.bound='1';
    });
    list.querySelectorAll('[data-discard]').forEach(btn=>{
      if(btn.dataset.bound) return;
      btn.addEventListener('click', ()=>{
        const idx = Number(btn.getAttribute('data-discard'));
        const item = (state.territory.lootQueue||[])[idx];
        if(!item) return;
        state.territory.lootQueue.splice(idx,1);
        tbLog(`Discarded <strong>${escapeHtml(item.name)}</strong>.`);
        renderLootList(); scheduleSave(); updateUI();
      });
      btn.dataset.bound='1';
    });
  }

  function maybeDropLoot(tier, wave){
    const chance = 0.25; // 25% per win
    if(Math.random() > chance) return;
    const pool = [
      { id:`loot-knuckles-${Date.now()}-${Math.random()}`, name:'Weighted Knuckles', slot:'hands', rarity:'common', mods:[{kind:'strAdd',  value: 3}] },
      { id:`loot-vest-${Date.now()}-${Math.random()}`,     name:'Padded Vest',       slot:'chest', rarity:'common', mods:[{kind:'toughAdd', value: 3}] },
      { id:`loot-wraps-${Date.now()}-${Math.random()}`,    name:'Wrist Wraps',       slot:'hands', rarity:'common', mods:[{kind:'strAdd',  value: 2}] },
      { id:`loot-cap-${Date.now()}-${Math.random()}`,      name:'Padded Cap',        slot:'head',  rarity:'common', mods:[{kind:'toughAdd', value: 2}] }
    ];
    const it = pool[Math.floor(Math.random()*pool.length)];
    state.territory.lootQueue = state.territory.lootQueue || [];
    state.territory.lootQueue.push(it);
    renderLootList();
  }

  function setTier(tier){
    state.territory.tier = tier;
    state.territory.wave = 1;
    state.territory.enemy = null;
    setTierButtons(tier);
    tbLog(`Switched to Tier ${tier}.`);
    renderTB();
  }

  // Wire up
  function wireTB(){
    const start = document.getElementById('tbStartBtn');
    const sim = document.getElementById('tbSimBtn');
    const t1 = document.getElementById('tbTier1');
    const t2 = document.getElementById('tbTier2');
    const take = document.getElementById('tbLootTake');
    if(start && !start.dataset.bound){ start.addEventListener('click', startOrNextWave); start.dataset.bound='1'; }
    if(sim && !sim.dataset.bound){ 
      sim.addEventListener('click', ()=>{
        for(let i=0;i<10;i++){ if(state.vitals.health<=0) break; startOrNextWave(); }
      }); sim.dataset.bound='1';
    }
    if(t1 && !t1.dataset.bound){ t1.addEventListener('click', ()=> setTier(1)); t1.dataset.bound='1'; }
    if(t2 && !t2.dataset.bound){ t2.addEventListener('click', ()=> setTier(2)); t2.dataset.bound='1'; }
    if(take && !take.dataset.bound){ take.addEventListener('click', takeLoot); take.dataset.bound='1'; }
  }

  // Show derived Strength/Toughness in Player Info
  // Hook into updateUI and tick
  const _origUpdateUI = window.updateUI;
  window.updateUI = function(){ try{ _origUpdateUI && _origUpdateUI(); }catch(e){} renderTB(); };

  const _origTick = window.tick;
  window.tick = function(){
    try{ _origTick && _origTick(); }catch(e){}
    try{ passiveHealthRegen(TICK_MS/1000); }catch(e){}
  };

  // Minimal view switcher for Territory link (non-invasive)
  (function(){
    const link = document.getElementById('territoryLink');
    if(link && !link.dataset.bound){
      link.addEventListener('click', function(){
        // Hide all views
        document.querySelectorAll('main .container section[role="tabpanel"]').forEach(sec=>{
          sec.classList.add('hidden'); sec.setAttribute('aria-hidden','true');
        });
        // Unselect all links
        document.querySelectorAll('aside .sidelink').forEach(a=> a.removeAttribute('aria-current'));
        // Show our view
        const sec = document.getElementById('view-territory');
        if(sec){ sec.classList.remove('hidden'); sec.setAttribute('aria-hidden','false'); }
        this.setAttribute('aria-current','page');
        wireTB(); setTierButtons((state.territory&&state.territory.tier)||1); renderTB();
      });
      link.dataset.bound='1';
    }
  })();

  // Also ensure TB UI wired on load, in case user lands there via saved state
  window.addEventListener('load', ()=> { try{ wireTB(); setTierButtons((state.territory&&state.territory.tier)||1); renderTB(); renderLootList(); renderMap(); renderTBDebug(); if (typeof renderTierHint === 'function') renderTierHint(); }catch(e){} });

  // Global sidebar navigation: show only the selected view
  function selectTab(tab){
    // Hide all tabpanels
    document.querySelectorAll('main .container section[role="tabpanel"]').forEach(sec=>{
      sec.classList.add('hidden'); sec.setAttribute('aria-hidden','true');
    });
    // Unselect
    document.querySelectorAll('aside .sidelink').forEach(a=> a.removeAttribute('aria-current'));
    // Show
    const id = `view-${tab}`;
    const sec = document.getElementById(id);
    if(sec){ sec.classList.remove('hidden'); sec.setAttribute('aria-hidden','false'); }
    const link = document.querySelector(`.sidelink[data-tab="${tab}"]`);
    if(link){ link.setAttribute('aria-current','page'); }
    if(tab==='territory'){ wireTB(); setTierButtons((state.territory&&state.territory.tier)||1); renderTB(); renderLootList(); }
  }
  window.selectTab = selectTab;

  (function wireGlobalNav(){
    document.querySelectorAll('.sidelink[data-tab]').forEach(a=>{
      if(a.dataset.bound) return;
      a.addEventListener('click', ()=> selectTab(a.getAttribute('data-tab')));
      a.dataset.bound='1';
    });
    // Initial: pick Stats if present, otherwise first tab
    const defaultTab = document.querySelector('.sidelink[data-tab="stats"]') ? 'stats'
                        : (document.querySelector('.sidelink[data-tab]')?.getAttribute('data-tab')||'stats');
    // On first run, hide everything then show default
    selectTab(defaultTab);
  })();

  // --- Regions & Map and Capture Flow ---
  const REGION_NAMES = ['Downtown','Harbor','Old Town','Heights','Industrial','Suburbs'];
  const REGION_COLORS = { captured:'#2ecc71', target:'#f1c40f', locked:'#2c3e50' };

  function initTerritoryRegions(){
    if(!state.territory) state.territory = {};
    if(!Array.isArray(state.territory.regions) || state.territory.regions.length!==6){
      state.territory.regions = REGION_NAMES.map((name,i)=>({ id:i, name, status: i===0?'target':'locked' }));
    }
    if(typeof state.territory.currentTarget !== 'number'){
      state.territory.currentTarget = state.territory.regions.findIndex(r=>r.status==='target');
      if(state.territory.currentTarget<0) state.territory.currentTarget = Math.min(5, (state.territory.regions.filter(r=>r.status==='captured').length)||0);
    }
    const captured = state.territory.regions.filter(r=>r.status==='captured').length;
    state.territory.tier = Math.max(1, Math.min(6, captured + 1, state.territory.tier||1));
  }

  function renderMap(){
    try{
      initTerritoryRegions();
      const svg = document.getElementById('tbMap');
      if(!svg) return;
      const rects = svg.querySelectorAll('[data-r]');
      const labels = svg.querySelectorAll('#tbMapLabels text');
      state.territory.regions.forEach((r,i)=>{
        const rect = rects[i];
        const lab = labels[i];
        if(rect){
          const col = (r.status==='captured')?REGION_COLORS.captured : (r.status==='target'?REGION_COLORS.target : REGION_COLORS.locked);
          rect.setAttribute('fill', col);
          rect.setAttribute('stroke', '#121821');
          rect.setAttribute('stroke-width','2');
        }
        if(lab){ lab.textContent = r.name; }
      });
    }catch(e){}
  }

  function markRegionCaptured(idx){
    try{
      const r = state.territory.regions[idx];
      if(!r) return;
      r.status = 'captured';
      const next = state.territory.regions.findIndex(rr=>rr.status==='locked');
      if(next>=0){
        state.territory.regions[next].status = 'target';
        state.territory.currentTarget = next;
      }else{
        state.territory.currentTarget = idx;
      }
    }catch(e){}
  }

  function getCapturedCount(){ return (state.territory.regions||[]).filter(r=>r.status==='captured').length; }

  // Override setTierButtons to support 1..6
  
  function setTierButtons(tier){
    const cap = getCapturedCount();
    const maxTier = Math.min(6, cap+1);
    for(let i=1;i<=6;i++){
      const b = document.getElementById('tbTier'+i);
      if(!b) continue;
      b.setAttribute('aria-pressed', String(i===tier));
      const locked = i > maxTier;
      b.disabled = locked;
      b.setAttribute('aria-disabled', String(locked)); b.classList.toggle('disabled', locked);
      b.title = locked ? `Locked — capture ${i-1} region(s) first` : `Go to Tier ${i}`;
      if(!b.dataset.bound){
        b.addEventListener('click', ()=>{
          if(b.disabled){
            tbLog(`Tier ${i} is locked — capture ${i-1} region(s) first. (You have ${cap}.)`);
            return;
          }
          setTier(i);
        });
        b.dataset.bound='1';
      }
    }
    if (typeof renderTierHint === 'function') renderTierHint(); }

  // Override setTier to lock to captured+1 and retarget region
  const _origSetTier = setTier;
  setTier = function(tier){
    const cap = getCapturedCount();
    const maxTier = Math.min(6, cap+1);
    const req = (tier|0) - 1;
    const t = Math.max(1, Math.min(maxTier, tier|0));
    if(t !== (tier|0)){
      tbLog(`Tier ${tier} is locked — capture ${req} region(s) first. Staying at Tier ${t}.`);
    }
    state.territory.tier = t;
    state.territory.wave = 1;
    state.territory.enemy = null;
    const next = (state.territory.regions||[]).findIndex(r=>r.status!=='captured');
    if(next>=0){
      state.territory.regions.forEach((r)=>{ if(r.status==='target') r.status='locked'; });
      state.territory.regions[next].status='target';
      state.territory.currentTarget = next;
    }
    setTierButtons(t);
    tbLog(`Switched to Tier ${t}.`);
    renderMap(); renderTBDebug(); renderTB(); scheduleSave();
  };

  // Override startOrNextWave to capture region at wave 10 clear
  const _oldStartOrNextWave = startOrNextWave;
startOrNextWave = function(){
  // If a battle is currently active, skip/finish it immediately
  if(state.territory && state.territory.battle && state.territory.battle.active){
    try{ finishBattle(state.territory.battle.resultSnapshot, { skipped:true }); }catch(e){}
    return;
  }
  if(state.vitals.health <= 0){
    tbLog('You are too injured. Heal up first.');
    return;
  }
  const foe = scaleEnemy(state.territory.tier, state.territory.wave);
  state.territory.enemy = foe;
  const you = getDerivedCombat();
  const result = simulateDuel(you, foe);
  // Begin a 5s presentation of the battle where the enemy health decreases relative to your DPS
  beginBattle(you, foe, result, 5000);
};

// === Progressive 5s Battle Presentation =====================================
function beginBattle(you, foe, result, durationMs){
  try{
    state.territory = state.territory || {};
    const dur = Math.max(500, Number(durationMs)||5000);

    // Extract duel numbers from the already-computed result
    const foeHPmax  = Math.max(1, Math.round(result.foeHPmax||0));
    const yourDPS   = Math.max(0, Number(result.yourDPS||0));
    const yourHPmax = Math.max(1, Math.round(result.yourHPmax||0));
    const foeDPS    = Math.max(0, Number(result.foeDPS||0));

    // Player starts each wave at their current health %, not full
    const startPct      = Math.max(0, Math.min(100, Number(state.vitals?.health||0)));
    const initialYouHP  = Math.round(yourHPmax * (startPct/100));

    // Work out how long the *fight* would actually last (using current HP as the cap)
    const tKillFoe   = (yourDPS>0) ? (foeHPmax     / yourDPS) : Infinity;
    const tKillYou   = (foeDPS>0)  ? (initialYouHP / foeDPS)   : Infinity;
    const simTimeCap = Math.min(tKillFoe, tKillYou); // seconds to end if left to run

    // If the fight wouldn't progress (e.g. zero DPS on both sides), resolve instantly
    if(!Number.isFinite(simTimeCap) || simTimeCap <= 0){
      try{ instantResolveBattle(you, foe, result); }catch(_){}
      return;
    }

    // Final HPs if the fight runs to completion under current conditions
    const wouldYouWin  = (tKillFoe <= tKillYou);
    const endEnemyHP   = wouldYouWin ? 0 : Math.max(0, Math.round(foeHPmax - yourDPS * tKillYou));
    const endYouHP     = wouldYouWin ? Math.max(0, Math.round(initialYouHP - foeDPS * tKillFoe))
                                     : 0;

    const battle = {
      active: true,
      startMs: performance.now(),
      durationMs: dur,
      // Enemy
      enemyHPMax: foeHPmax,
      enemyHP: foeHPmax,
      // Player (simulated within this duel only)
      youHPMax: yourHPmax,
      youHP: initialYouHP,
      // End targets for interpolation/simulation
      endEnemyHP,
      endYouHP,
      foe,
      you,
      // Keep the original duel result so finishBattle can compute % loss consistently
      resultSnapshot: {
        foe, you,
        foeHPmax, yourHPmax,
        yourDPS, foeDPS,
        youDamage: Math.max(0, Math.round(result.youDamage||0)),
        foeDamage: Math.max(0, Math.round(result.foeDamage||0)),
        youWin: Boolean(result.youWin)
      },
      timerId: null
    };
    state.territory.battle = battle;

    // Disable the start button while animating
    const startBtn = document.getElementById('tbStartBtn');
    if(startBtn){ startBtn.disabled = true; startBtn.textContent = 'Battling…'; }

    // Each RAF tick advances *simulated* time linearly to the fight's end within dur
    let last = performance.now();
    let simTime = 0;                      // seconds mapped into the duel
    const simRate = simTimeCap / dur;     // seconds of duel per ms of real time

    function step(now){
      if(!state.territory?.battle?.active) return; // aborted elsewhere
      const dtMs = Math.max(0, now - last);
      last = now;

      // Advance simulated time
      simTime = Math.min(simTimeCap, simTime + dtMs * simRate);

      // Update HP based on DPS * simulated time
      const curEnemyHP = Math.max(0, Math.round(foeHPmax - yourDPS * simTime));
      const curYouHP   = Math.max(0, Math.round(initialYouHP - foeDPS * simTime));
      battle.enemyHP = curEnemyHP;
      battle.youHP   = curYouHP;

      // Update UI
      try{ renderTB(); }catch(_){}

      // Check end conditions
      if(simTime >= simTimeCap - 1e-6 || curEnemyHP <= 0 || curYouHP <= 0){
        // Auto-finish and commit results
        try{ finishBattle(battle.resultSnapshot); }catch(_){}
        return;
      }

      // Continue animation
      battle.timerId = requestAnimationFrame(step);
    }

    // Kick off
    battle.timerId = requestAnimationFrame(step);
  }catch(e){
    console.error('beginBattle error', e);
    // Fallback: if something goes wrong, resolve instantly (commits health)
    try{ instantResolveBattle(you, foe, result); }catch(_){}
  }
}

function finishBattle(snap, { skipped } = { skipped:false }){
  try{
    const battle = state.territory?.battle;
    if(battle && battle.timerId){ cancelAnimationFrame(battle.timerId); }
  }catch(e){}
  // Clear active state
  try{
    if(state.territory){ delete state.territory.battle; }
  }catch(e){}
  // Re-enable button
  const startBtn = document.getElementById('tbStartBtn'); 
  if(startBtn){ startBtn.disabled = false; startBtn.textContent = 'Start / Next Wave'; }

  const foe = state.territory.enemy || snap?.foe;
  const tier = snap?.tier || state.territory.tier;
  const wave = snap?.wave || state.territory.wave;
  const youDamage = snap?.youDamage || 0;
  const yourHPmax = snap?.yourHPmax || 1;
  const youWin = !!snap?.youWin;

  if(youWin){
    const dmgPct = Math.round((youDamage / yourHPmax) * 100);
    if(dmgPct >= (state.vitals.health||0)){
      // Too injured to survive the fight; count as a loss
      addHealth(-100);
      tbLog(`Wave ${wave}: You tried to fight the <strong>${foe.name}</strong> but passed out from injuries.`);
    }else{
      addHealth(-dmgPct);
      tbLog(`Wave ${wave}: You beat the <strong>${foe.name}</strong>. Took <strong class="tbad">-${dmgPct}%</strong> health.`);
      maybeDropLoot(tier, wave);
      if(state.territory.wave < 10){
        state.territory.wave += 1;
      }else{
        const idx = state.territory.currentTarget||0;
        markRegionCaptured(idx);
        const cap = getCapturedCount();
        tbLog(`<strong>Region captured!</strong> ${cap}/6 controlled.`);
        state.territory.wave = 1;
        state.territory.tier = Math.min(6, cap + 1);
        setTierButtons(state.territory.tier);
      }
    }
  }else{
    addHealth(-100);
    tbLog(`Wave ${wave}: You were defeated by the <strong>${foe.name}</strong>.`);
  }

  
// Preview next enemy for the new wave so players can decide before starting
try{
  state.territory.enemy = scaleEnemy(state.territory.tier, state.territory.wave);
}catch(e){}

renderMap(); try{ renderTBDebug(); }catch(e){}
  renderTB(); (typeof renderTierHint==='function') && renderTierHint(); updateUI && updateUI(); scheduleSave && scheduleSave();
}

function instantResolveBattle(you, foe, result){
  // Original fall-back resolution (instant) in case progressive flow fails
  if(result.youWin){
    const dmgPct = Math.round((result.youDamage / result.yourHPmax) * 100);
    if(dmgPct >= (state.vitals.health||0)){
      addHealth(-100);
      tbLog(`Wave ${state.territory.wave}: You tried to fight the <strong>${foe.name}</strong> but passed out from injuries.`);
    }else{
      addHealth(-dmgPct);
      tbLog(`Wave ${state.territory.wave}: You beat the <strong>${foe.name}</strong>. Took <strong class="tbad">-${dmgPct}%</strong> health.`);
      maybeDropLoot(state.territory.tier, state.territory.wave);
      if(state.territory.wave < 10){
        state.territory.wave += 1;
      }else{
        const idx = state.territory.currentTarget||0;
        markRegionCaptured(idx);
        const cap = getCapturedCount();
        tbLog(`<strong>Region captured!</strong> ${cap}/6 controlled.`);
        state.territory.wave = 1;
        state.territory.tier = Math.min(6, cap + 1);
        setTierButtons(state.territory.tier);
      }
    }
  }else{
    addHealth(-100);
    tbLog(`Wave ${state.territory.wave}: You were defeated by the <strong>${foe.name}</strong>.`);
  }
  renderMap(); try{ renderTBDebug(); }catch(e){}
  renderTB(); (typeof renderTierHint==='function') && renderTierHint(); updateUI && updateUI(); scheduleSave && scheduleSave();
}

  // Debug panel content
  function renderTBDebug(){
    try{
      const el = document.getElementById('tbDebug'); if(!el) return;
      const you = getDerivedCombat();
      const foe = state.territory.enemy || scaleEnemy(state.territory.tier, state.territory.wave);
      const out = simulateDuel(you, foe);
      const cap = getCapturedCount();
      const target = state.territory.currentTarget;
      const r = (state.territory.regions||[])[target];
      el.innerHTML = `
        <div><strong>Debug</strong></div>
        <div>Tier ${state.territory.tier} • Wave ${state.territory.wave} • Captured ${cap}/6 • Target: ${target} (${r?escapeHtml(r.name):'n/a'})</div>
        <div>You: STR ${you.strength} TGH ${you.toughness} POW ${you.power} HPmax ${(you.power*3).toFixed(0)} Regen ${(you.toughness*0.03).toFixed(2)}/s</div>
        <div>Foe: STR ${foe.strength} TGH ${foe.toughness} POW ${foe.power} HPmax ${(foe.power*3).toFixed(0)} Regen ${(foe.toughness*0.03).toFixed(2)}/s</div>
      `;
    }catch(e){}
  }

})();
</script>
<!-- end affordability-guard -->



<!-- Basement 3D: lightweight first-person scene for Damp Basement HQ (Global build for local file:// use) -->
<script src="https://unpkg.com/three@0.149.0/build/three.min.js"></script>
<script>
(function(){
  let __basement = null;
  let __resizeObserver = null;

  function isDampBasement(h){
    try{
      const nm = String(h && h.name || '').toLowerCase().trim();
      return nm === 'damp basement';
    }catch(e){ return false; }
  }

  function ensureCanvasSize(renderer){
    try{
      const wrap = document.getElementById('basement3DWrap');
      if(!wrap || !renderer) return;
      const canvas = renderer.domElement;
      const w = wrap.clientWidth || 600;
      const h = wrap.clientHeight || 260;
      if(canvas.width !== w || canvas.height !== h){
        renderer.setSize(w, h, false);
        if(renderer.camera){
          const c = renderer.domElement;
          renderer.camera.aspect = c.clientWidth / Math.max(1, c.clientHeight);
          renderer.camera.updateProjectionMatrix();
        }
      }
    }catch(e){}
  }

  function mountBasement3D(){
    if(__basement) return __basement;
    const wrap = document.getElementById('basement3DWrap');
    const canvas = document.getElementById('basement3DCanvas');
    if(!wrap || !canvas || !window.THREE) return null;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);
    const camera = new THREE.PerspectiveCamera(75, 1, 0.1, 100);
    camera.position.set(0, 1.6, 4);

    
    camera.rotation.order = 'YXZ';
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio||1));
    renderer.camera = camera; // allow ensureCanvasSize to update projection

    // Make sure we size immediately (even if shown just now)
    ensureCanvasSize(renderer);

    // Lights
    const hemi = new THREE.HemisphereLight(0xddeeff, 0x0a0a0a, 0.9);
    scene.add(hemi);
    const amb  = new THREE.AmbientLight(0xffffff, 0.55);
    scene.add(amb);
    const spotA = new THREE.SpotLight(0xffffff, 2.8, 16, Math.PI/5, 0.35, 1.2);
    spotA.position.set(-1.5, 2.4, 1.2);
    scene.add(spotA);
    const spotB = new THREE.SpotLight(0xb0c8ff, 2.0, 16, Math.PI/5, 0.4, 1.0);
    spotB.position.set(2.2, 2.6, -1.2);
    scene.add(spotB);
// Floor & walls (simple room ~6x6m)
    const room = new THREE.Group();
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x22272e, roughness: 0.9, metalness: 0.0 });
    const wallMat  = new THREE.MeshStandardMaterial({ color: 0x1a1f27, roughness: 0.95, metalness: 0.0 });

    const plane = (w,h,rx,ry,rz,px,py,pz,mat)=>{
      const g = new THREE.PlaneGeometry(w,h);
      const m = new THREE.Mesh(g, mat);
      m.rotation.set(rx, ry, rz);
      m.position.set(px, py, pz);
      room.add(m);
    };
    // floor
    plane(6,6, -Math.PI/2, 0, 0, 0, 0, 0, floorMat);
    // ceiling (darker)
    const ceilMat = new THREE.MeshStandardMaterial({ color: 0x12161d, roughness: 0.95 });
    plane(6,6,  Math.PI/2, 0, 0, 0, 3, 0, ceilMat);
    // walls
    plane(6,3, 0,  Math.PI, 0,   0, 1.5, -3, wallMat);   // back
    plane(6,3, 0, 0, 0,      0, 1.5,  3, wallMat);       // front
    plane(6,3, 0,  Math.PI/2, 0, -3, 1.5, 0, wallMat);   // left
    plane(6,3, 0, -Math.PI/2, 0,  3, 1.5, 0, wallMat);   // right

    // Props: boxes / pipes
    const boxMat = new THREE.MeshStandardMaterial({ color: 0x2b323c, roughness: 0.85 });
    for(let i=0;i<5;i++){
      const g = new THREE.BoxGeometry(0.6+Math.random()*0.4, 0.3+Math.random()*0.6, 0.6+Math.random()*0.4);
      const m = new THREE.Mesh(g, boxMat);
      m.position.set(-2.4 + Math.random()*4.8, 0.2, -2.2 + Math.random()*2.0);
      m.castShadow = false; m.receiveShadow = true;
      room.add(m);
    }
    scene.add(room);


// --- First Aid Cabinet (procedural) -------------------------------------
(function buildProceduralFirstAid(scene){
  const g = new THREE.Group();
  // Dimensions (meters)
  const W = 0.48, H = 0.62, D = 0.18;
  // Position on back wall (z ~ -3), at eye height
  g.position.set(-0.85, 1.45, -2.98);
  // Make sure it faces into the room
  g.rotation.y = Math.PI;

  // Materials
  const cabMat  = new THREE.MeshStandardMaterial({ color: 0xe6e8ea, roughness: 0.7, metalness: 0.05 });
  const rimMat  = new THREE.MeshStandardMaterial({ color: 0xbfc5cc, roughness: 0.5, metalness: 0.3 });
  const glassMat= new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.0, transmission: 0.8, transparent: true, thickness: 0.01 });
  const redMat  = new THREE.MeshStandardMaterial({ color: 0xc81e1e, roughness: 0.6, metalness: 0.0 });

  // Main box (shallow depth)
  const body = new THREE.Mesh(new THREE.BoxGeometry(W, H, D), cabMat);
  body.castShadow = false; body.receiveShadow = true;
  g.add(body);

  // Slightly inset door panel
  const door = new THREE.Mesh(new THREE.BoxGeometry(W*0.96, H*0.96, D*0.02), rimMat);
  door.position.set(0, 0, D*0.51);
  g.add(door);

  // Glass window on door
  const glass = new THREE.Mesh(new THREE.PlaneGeometry(W*0.6, H*0.48), glassMat);
  glass.position.set(0, 0, D*0.52 + 0.001);
  g.add(glass);

  // Red cross emblem (two thin boxes)
  const crossH = new THREE.Mesh(new THREE.BoxGeometry(W*0.4, H*0.08, D*0.005), redMat);
  crossH.position.set(0, 0, D*0.525);
  const crossV = new THREE.Mesh(new THREE.BoxGeometry(W*0.08, H*0.4, D*0.005), redMat);
  crossV.position.set(0, 0, D*0.525);
  g.add(crossH, crossV);

  // Small handle
  const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.007, 0.007, 0.06, 16), rimMat);
  handle.rotation.z = Math.PI/2;
  handle.position.set(W*0.43, 0, D*0.52);
  g.add(handle);

  // Mount flush to wall: nudge forward a bit to avoid z-fighting
  g.position.z += 0.005;

  // Expose for later tweaks
  scene.__firstAidCabinet = g;
  scene.add(g);
})(scene);




// --- Ceiling Lights ------------------------------------------------------
(function addCeilingLights(scene){
  const positions = [ -1.8, 0, 1.8 ];
  positions.forEach((x) => {
    const light = new THREE.PointLight(0xffffff, 1.2, 8, 2.0);
    light.position.set(x, 2.4, 0);
    light.castShadow = true;
    scene.add(light);

    const stripMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffffff,
      emissiveIntensity: 2.2,
      roughness: 0.3,
      metalness: 0.0
    });
    const strip = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.04, 0.08), stripMat);
    strip.position.set(x, 2.45, 0);
    scene.add(strip);
  });
})(scene);



    // Basic first-person controls (pointer lock + WASD)
    let yaw=0, pitch=0;
    const vel = { x:0, z:0 };
    const keys = { w:false, a:false, s:false, d:false };
    const speed = 1.8; // m/s
    const damping = 0.86;

    function onResize(){
      if(!renderer) return;
      ensureCanvasSize(renderer);
      const c = renderer.domElement;
      camera.aspect = c.clientWidth / Math.max(1, c.clientHeight);
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    wrap.addEventListener('click', () => {
      try{ canvas.requestPointerLock(); }catch(e){}
    });

    function onMouseMove(e){
      if(document.pointerLockElement === canvas){
        const sens = 0.0025;
        yaw -= e.movementX * sens;
        pitch -= e.movementY * sens;
        const clamp = Math.PI/2 - 0.05;
        if(pitch > clamp) pitch = clamp;
        if(pitch < -clamp) pitch = -clamp;
      }
    }
    document.addEventListener('mousemove', onMouseMove);

    function onKey(e, down){
      const k = e.key.toLowerCase();
      if(k==='w') keys.w = down;
      if(k==='a') keys.a = down;
      if(k==='s') keys.s = down;
      if(k==='d') keys.d = down;
    }
    document.addEventListener('keydown', e=>onKey(e,true));
    document.addEventListener('keyup',   e=>onKey(e,false));

    function tick(ts){
      const dt = Math.min(0.033, (renderer.__lastTs ? (ts-renderer.__lastTs)/1000 : 0.016));
      renderer.__lastTs = ts;

      // Integrate velocity from keys (local space)
      const fwdX = Math.sin(yaw), fwdZ = Math.cos(yaw);
      const rightX = Math.cos(yaw), rightZ = -Math.sin(yaw);

      if(keys.w) { vel.x += fwdX * speed * dt; vel.z += fwdZ * speed * dt; }
      if(keys.s) { vel.x -= fwdX * speed * dt; vel.z -= fwdZ * speed * dt; }
      if(keys.a) { vel.x -= rightX * speed * dt; vel.z -= rightZ * speed * dt; }
      if(keys.d) { vel.x += rightX * speed * dt; vel.z += rightZ * speed * dt; }

      // Damping
      vel.x *= damping; vel.z *= damping;

      // Move camera; clamp within room bounds (a bit inset from walls)
      camera.position.x += vel.x;
      camera.position.z += vel.z;
      camera.position.x = Math.max(-2.7, Math.min(2.7, camera.position.x));
      camera.position.z = Math.max(-2.7, Math.min(2.7, camera.position.z));

      // Apply look
      camera.rotation.x = pitch;
      camera.rotation.y = yaw;

      renderer.render(scene, camera);
      renderer.__raf = requestAnimationFrame(tick);
    }
    renderer.__raf = requestAnimationFrame(tick);

    // Public cleanup
    function cleanup(){
      try{ cancelAnimationFrame(renderer.__raf); }catch(e){}
      window.removeEventListener('resize', onResize);
      document.removeEventListener('mousemove', onMouseMove);
      // release pointer lock if ours
      try{ if(document.pointerLockElement===canvas) document.exitPointerLock(); }catch(e){}
      // dispose
      try{
        scene.traverse(obj => {
          if(obj.geometry) obj.geometry.dispose?.();
          if(obj.material){
            if(Array.isArray(obj.material)){ obj.material.forEach(m=>m.dispose?.()); }
            else obj.material.dispose?.();
          }
        });
        renderer.dispose();
      }catch(e){}
      __basement = null;
    }

    __basement = { renderer, scene, camera, cleanup };
    onResize();
    return __basement;
  }

  function destroyBasement3D(){
    if(__basement && __basement.cleanup){ __basement.cleanup(); }
    __basement = null;
  }

  // Hook into renderHeadquarters to mount/unmount based on HQ name
  const __origRenderHQ = window.renderHeadquarters;
  window.renderHeadquarters = function(){
    try{ __origRenderHQ && __origRenderHQ.apply(this, arguments); }catch(e){}
    try{
      const container = document.getElementById('hqBasement3D');
      if(!container) return;
      // Attempt to resolve current HQ record via helper if present
      let h = null;
      try{ h = (typeof window.getHQRecord==='function') ? window.getHQRecord() : null; }catch(e){}
      const shouldShow = !!(h && isDampBasement(h));
      container.classList.toggle('hidden', !shouldShow);
      container.setAttribute('aria-hidden', String(!shouldShow));
      if(shouldShow){
        // (re)mount if needed
        if(!__basement){ mountBasement3D(); }
        else{
          // ensure renderer resizes if coming back from hidden
          try{ __basement.renderer.__lastTs = null; }catch(e){}
        }
      }else{
        // Not damp basement -> destroy
        destroyBasement3D();
      }
    }catch(e){}
  };

  // Also clean up when switching away from HQ
  const __origSetActiveTab2 = window.setActiveTab;
  window.setActiveTab = function(id){
    try{
      if(id !== 'headquarters'){ destroyBasement3D(); }
    }catch(e){}
    try{ __origSetActiveTab2 && __origSetActiveTab2.apply(this, arguments); }catch(e){}
  };

})();</script>


<script>
  // Register Service Worker for offline + updates
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', async () => {
      try {
        const reg = await navigator.serviceWorker.register('/service-worker.js', { scope: '/' });
        // Listen for new SW waiting to activate
        navigator.serviceWorker.addEventListener('message', (event) => {
          if (event.data && event.data.type === 'SW_UPDATE_AVAILABLE') {
            // Use a small helper to prompt user to refresh
            import('/sw-update.js').then(mod => mod.default(reg));
          }
        });
      } catch (err) {
        console.error('SW registration failed:', err);
      }
    });
  }
</script>
</body>
</html>

/* Ensure pending logs are saved before the page unloads */
try{
  window.addEventListener('beforeunload', function(){
    try{ if(typeof saveGame==='function') saveGame({ silent: true }); }catch(e){}
  });
}catch(e){}    
